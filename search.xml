<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Scrapy]]></title>
    <url>%2F2019%2F02%2F25%2FScrapy%2F</url>
    <content type="text"><![CDATA[ScrapyScrapy是一个为了爬取网站数据，提取结构性数据而编写的应用框架。 其可以应用在数据挖掘，信息处理或存储历史数据等一系列的程序中。其最初是为了页面抓取 (更确切来说, 网络抓取 )所设计的， 也可以应用在获取API所返回的数据(例如 Amazon Associates Web Services ) 或者通用的网络爬虫。Scrapy用途广泛，可以用于数据挖掘、监测和自动化测试。 Scrapy 使用了 Twisted异步网络库来处理网络通讯。整体架构大致如下 Scrapy主要包括了以下组件： 引擎(Scrapy)用来处理整个系统的数据流处理, 触发事务(框架核心) 调度器(Scheduler)用来接受引擎发过来的请求, 压入队列中, 并在引擎再次请求的时候返回. 可以想像成一个URL（抓取网页的网址或者说是链接）的优先队列, 由它来决定下一个要抓取的网址是什么, 同时去除重复的网址 下载器(Downloader)用于下载网页内容, 并将网页内容返回给蜘蛛(Scrapy下载器是建立在twisted这个高效的异步模型上的) 爬虫(Spiders)爬虫是主要干活的, 用于从特定的网页中提取自己需要的信息, 即所谓的实体(Item)。用户也可以从中提取出链接,让Scrapy继续抓取下一个页面 项目管道(Pipeline)负责处理爬虫从网页中抽取的实体，主要的功能是持久化实体、验证实体的有效性、清除不需要的信息。当页面被爬虫解析后，将被发送到项目管道，并经过几个特定的次序处理数据。 下载器中间件(Downloader Middlewares)位于Scrapy引擎和下载器之间的框架，主要是处理Scrapy引擎与下载器之间的请求及响应。 爬虫中间件(Spider Middlewares)介于Scrapy引擎和爬虫之间的框架，主要工作是处理蜘蛛的响应输入和请求输出。 调度中间件(Scheduler Middewares)介于Scrapy引擎和调度之间的中间件，从Scrapy引擎发送到调度的请求和响应。 Scrapy运行流程大概如下： 引擎从调度器中取出一个链接(URL)用于接下来的抓取 引擎把URL封装成一个请求(Request)传给下载器 下载器把资源下载下来，并封装成应答包(Response) 爬虫解析Response 解析出实体（Item）,则交给实体管道进行进一步的处理 解析出的是链接（URL）,则把URL交给调度器等待抓取 一、安装Linux1pip3 install scrapy Windows12345pip3 install wheel下载twisted http://www.lfd.uci.edu/~gohlke/pythonlibs/#twisted进入下载目录，执行 pip3 install Twisted‑17.1.0‑cp35‑cp35m‑win_amd64.whlpip3 install pywin32pip3 install scrapy 二、基本使用1. 基本命令1234567891011121314151617181. scrapy startproject 项目名称 - 在当前目录中创建中创建一个项目文件（类似于Django） 2. cd 项目目录 scrapy genspider &lt;name&gt; &lt;domain&gt; - 创建爬虫应用 如： scrapy gensipider oldboy oldboy.com scrapy gensipider autohome autohome.com.cn PS: 查看所有命令：scrapy gensipider -l 查看模板命令：scrapy gensipider -d 模板名称 3. scrapy list - 展示爬虫应用列表 4. scrapy crawl 爬虫应用名称 - 运行单独爬虫应用 2.项目结构以及爬虫应用简介12345678910111213project_name/ scrapy.cfg # 配置文件(部署)项目的主配置信息 project_name/ __init__.py items.py # 设置数据存储模板，用于结构化数据，如：Django的Model pipelines.py # 数据处理行为，如：一般结构化的数据持久化 settings.py # 配置文件(爬虫)，如：递归的层数、并发数，延迟下载等 middlewares.py # 中间件 spiders/ # 爬虫目录，如：创建文件，编写爬虫规则 __init__.py 爬虫1.py 爬虫2.py 爬虫3.py 注意：一般创建爬虫文件时，以网站域名命名 爬虫1.py 1234567891011import scrapy class XiaoHuarSpider(scrapy.spiders.Spider): name = "xiaohuar" # 爬虫名称 ***** allowed_domains = ["xiaohuar.com"] # 允许的域名 start_urls = [ "http://www.xiaohuar.com/hua/", # 其实URL ] def parse(self, response): # 访问起始URL并获取结果后的回调函数 关于windows编码 12import sys,ossys.stdout=io.TextIOWrapper(sys.stdout.buffer,encoding='gb18030') 3. 小试牛刀1234567891011121314151617181920212223242526272829303132333435363738394041import scrapyfrom scrapy.selector import HtmlXPathSelectorfrom scrapy.http.request import Request class DigSpider(scrapy.Spider): # 爬虫应用的名称，通过此名称启动爬虫命令 name = "dig" # 允许的域名 allowed_domains = ["chouti.com"] # 起始URL start_urls = [ 'http://dig.chouti.com/', ] has_request_set = &#123;&#125; def parse(self, response): print(response.url) hxs = HtmlXPathSelector(response) page_list = hxs.select('//div[@id="dig_lcpage"]//a[re:test(@href, "/all/hot/recent/\d+")]/@href').extract() for page in page_list: page_url = 'http://dig.chouti.com%s' % page key = self.md5(page_url) if key in self.has_request_set: pass else: self.has_request_set[key] = page_url obj = Request(url=page_url, method='GET', callback=self.parse) yield obj @staticmethod def md5(val): import hashlib ha = hashlib.md5() ha.update(bytes(val, encoding='utf-8')) key = ha.hexdigest() return key 执行此爬虫文件，则在终端进入项目目录执行如下命令： 1`scrapy crawl dig ``-``-``nolog` 对于上述代码重要之处在于： Request是一个封装用户请求的类，在回调函数中yield该对象表示继续访问 HtmlXpathSelector用于结构化HTML代码并提供选择器功能 4. 选择器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#!/usr/bin/env python# -*- coding:utf-8 -*-from scrapy.selector import Selector, HtmlXPathSelectorfrom scrapy.http import HtmlResponsehtml = """&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li class="item-"&gt;&lt;a id='i1' href="link.html"&gt;first item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-0"&gt;&lt;a id='i2' href="llink.html"&gt;first item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-1"&gt;&lt;a href="llink2.html"&gt;second item&lt;span&gt;vv&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div&gt;&lt;a href="llink2.html"&gt;second item&lt;/a&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;"""response = HtmlResponse(url='http://example.com', body=html,encoding='utf-8')# hxs = HtmlXPathSelector(response)# print(hxs)# hxs = Selector(response=response).xpath('//a')# print(hxs)# hxs = Selector(response=response).xpath('//a[2]')# print(hxs)# hxs = Selector(response=response).xpath('//a[@id]')# print(hxs)# hxs = Selector(response=response).xpath('//a[@id="i1"]')# print(hxs)# hxs = Selector(response=response).xpath('//a[@href="link.html"][@id="i1"]')# print(hxs)# hxs = Selector(response=response).xpath('//a[contains(@href, "link")]')# print(hxs)# hxs = Selector(response=response).xpath('//a[starts-with(@href, "link")]')# print(hxs)# hxs = Selector(response=response).xpath('//a[re:test(@id, "i\d+")]')# print(hxs)# hxs = Selector(response=response).xpath('//a[re:test(@id, "i\d+")]/text()').extract()# print(hxs)# hxs = Selector(response=response).xpath('//a[re:test(@id, "i\d+")]/@href').extract()# print(hxs)# hxs = Selector(response=response).xpath('/html/body/ul/li/a/@href').extract()# print(hxs)# hxs = Selector(response=response).xpath('//body/ul/li/a/@href').extract_first()# print(hxs) # ul_list = Selector(response=response).xpath('//body/ul/li')# for item in ul_list:# v = item.xpath('./a/span')# # 或# # v = item.xpath('a/span')# # 或# # v = item.xpath('*/a/span')# print(v) 示例：自动登陆抽屉并点赞 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384# -*- coding: utf-8 -*-import scrapyfrom scrapy.selector import HtmlXPathSelectorfrom scrapy.http.request import Requestfrom scrapy.http.cookies import CookieJarfrom scrapy import FormRequestclass ChouTiSpider(scrapy.Spider): # 爬虫应用的名称，通过此名称启动爬虫命令 name = "chouti" # 允许的域名 allowed_domains = ["chouti.com"] cookie_dict = &#123;&#125; has_request_set = &#123;&#125; def start_requests(self): url = 'http://dig.chouti.com/' # return [Request(url=url, callback=self.login)] yield Request(url=url, callback=self.login) def login(self, response): cookie_jar = CookieJar() cookie_jar.extract_cookies(response, response.request) for k, v in cookie_jar._cookies.items(): for i, j in v.items(): for m, n in j.items(): self.cookie_dict[m] = n.value req = Request( url='http://dig.chouti.com/login', method='POST', headers=&#123;'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8'&#125;, body='phone=8615131255089&amp;password=pppppppp&amp;oneMonth=1', cookies=self.cookie_dict, callback=self.check_login ) yield req def check_login(self, response): req = Request( url='http://dig.chouti.com/', method='GET', callback=self.show, cookies=self.cookie_dict, dont_filter=True ) yield req def show(self, response): # print(response) hxs = HtmlXPathSelector(response) news_list = hxs.select('//div[@id="content-list"]/div[@class="item"]') for new in news_list: # temp = new.xpath('div/div[@class="part2"]/@share-linkid').extract() link_id = new.xpath('*/div[@class="part2"]/@share-linkid').extract_first() yield Request( url='http://dig.chouti.com/link/vote?linksId=%s' %(link_id,), method='POST', cookies=self.cookie_dict, callback=self.do_favor ) page_list = hxs.select('//div[@id="dig_lcpage"]//a[re:test(@href, "/all/hot/recent/\d+")]/@href').extract() for page in page_list: page_url = 'http://dig.chouti.com%s' % page import hashlib hash = hashlib.md5() hash.update(bytes(page_url,encoding='utf-8')) key = hash.hexdigest() if key in self.has_request_set: pass else: self.has_request_set[key] = page_url yield Request( url=page_url, method='GET', callback=self.show ) def do_favor(self, response): print(response.text) 注意：settings.py中设置DEPTH_LIMIT = 1来指定“递归”的层数。 5. 格式化处理上述实例只是简单的处理，所以在parse方法中直接处理。如果对于想要获取更多的数据处理，则可以利用Scrapy的items将数据格式化，然后统一交由pipelines来处理。 spiders/xiahuar.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import scrapyfrom scrapy.selector import HtmlXPathSelectorfrom scrapy.http.request import Requestfrom scrapy.http.cookies import CookieJarfrom scrapy import FormRequestclass XiaoHuarSpider(scrapy.Spider): # 爬虫应用的名称，通过此名称启动爬虫命令 name = "xiaohuar" # 允许的域名 allowed_domains = ["xiaohuar.com"] start_urls = [ "http://www.xiaohuar.com/list-1-1.html", ] # custom_settings = &#123; # 'ITEM_PIPELINES':&#123; # 'spider1.pipelines.JsonPipeline': 100 # &#125; # &#125; has_request_set = &#123;&#125; def parse(self, response): # 分析页面 # 找到页面中符合规则的内容（校花图片），保存 # 找到所有的a标签，再访问其他a标签，一层一层的搞下去 hxs = HtmlXPathSelector(response) items = hxs.select('//div[@class="item_list infinite_scroll"]/div') for item in items: src = item.select('.//div[@class="img"]/a/img/@src').extract_first() name = item.select('.//div[@class="img"]/span/text()').extract_first() school = item.select('.//div[@class="img"]/div[@class="btns"]/a/text()').extract_first() url = "http://www.xiaohuar.com%s" % src from ..items import XiaoHuarItem obj = XiaoHuarItem(name=name, school=school, url=url) yield obj urls = hxs.select('//a[re:test(@href, "http://www.xiaohuar.com/list-1-\d+.html")]/@href') for url in urls: key = self.md5(url) if key in self.has_request_set: pass else: self.has_request_set[key] = url req = Request(url=url,method='GET',callback=self.parse) yield req @staticmethod def md5(val): import hashlib ha = hashlib.md5() ha.update(bytes(val, encoding='utf-8')) key = ha.hexdigest() return key items 123456import scrapyclass XiaoHuarItem(scrapy.Item): name = scrapy.Field() school = scrapy.Field() url = scrapy.Field() pipelines 12345678910111213141516171819202122232425262728import jsonimport osimport requestsclass JsonPipeline(object): def __init__(self): self.file = open('xiaohua.txt', 'w') def process_item(self, item, spider): v = json.dumps(dict(item), ensure_ascii=False) self.file.write(v) self.file.write('\n') self.file.flush() return itemclass FilePipeline(object): def __init__(self): if not os.path.exists('imgs'): os.makedirs('imgs') def process_item(self, item, spider): response = requests.get(item['url'], stream=True) file_name = '%s_%s.jpg' % (item['name'], item['school']) with open(os.path.join('imgs', file_name), mode='wb') as f: f.write(response.content) return item settings 12345ITEM_PIPELINES = &#123; 'spider1.pipelines.JsonPipeline': 100, 'spider1.pipelines.FilePipeline': 300,&#125;# 每行后面的整型值，确定了他们运行的顺序，item按数字从低到高的顺序，通过pipeline，通常将这些数字定义在0-1000范围内。 对于pipeline可以做更多，如下自定义pipeline 1234567891011121314151617181920212223242526272829303132333435363738394041from scrapy.exceptions import DropItemclass CustomPipeline(object): def __init__(self,v): self.value = v def process_item(self, item, spider): # 操作并进行持久化 # return表示会被后续的pipeline继续处理 return item # 表示将item丢弃，不会被后续pipeline处理 # raise DropItem() @classmethod def from_crawler(cls, crawler): """ 初始化时候，用于创建pipeline对象 :param crawler: :return: """ val = crawler.settings.getint('MMMM') return cls(val) def open_spider(self,spider): """ 爬虫开始执行时，调用 :param spider: :return: """ print('000000') def close_spider(self,spider): """ 爬虫关闭时，被调用 :param spider: :return: """ print('111111') 6.中间件爬虫中间件 12345678910111213141516171819202122232425262728293031323334353637383940class SpiderMiddleware(object): def process_spider_input(self,response, spider): """ 下载完成，执行，然后交给parse处理 :param response: :param spider: :return: """ pass def process_spider_output(self,response, result, spider): """ spider处理完成，返回时调用 :param response: :param result: :param spider: :return: 必须返回包含 Request 或 Item 对象的可迭代对象(iterable) """ return result def process_spider_exception(self,response, exception, spider): """ 异常调用 :param response: :param exception: :param spider: :return: None,继续交给后续中间件处理异常；含 Response 或 Item 的可迭代对象(iterable)，交给调度器或pipeline """ return None def process_start_requests(self,start_requests, spider): """ 爬虫启动时调用 :param start_requests: :param spider: :return: 包含 Request 对象的可迭代对象 """ return start_requests 下载器中间件 123456789101112131415161718192021222324252627282930313233343536373839404142class DownMiddleware1(object): def process_request(self, request, spider): """ 请求需要被下载时，经过所有下载器中间件的process_request调用 :param request: :param spider: :return: None,继续后续中间件去下载； Response对象，停止process_request的执行，开始执行process_response Request对象，停止中间件的执行，将Request重新调度器 raise IgnoreRequest异常，停止process_request的执行，开始执行process_exception """ pass def process_response(self, request, response, spider): """ spider处理完成，返回时调用 :param response: :param result: :param spider: :return: Response 对象：转交给其他中间件process_response Request 对象：停止中间件，request会被重新调度下载 raise IgnoreRequest 异常：调用Request.errback """ print('response1') return response def process_exception(self, request, exception, spider): """ 当下载处理器(download handler)或 process_request() (下载中间件)抛出异常 :param response: :param exception: :param spider: :return: None：继续交给后续中间件处理异常； Response对象：停止后续process_exception方法 Request对象：停止中间件，request将会被重新调用下载 """ return None]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis]]></title>
    <url>%2F2019%2F01%2F24%2Fredis%2F</url>
    <content type="text"><![CDATA[简介1，redis是什么 redis是NoSql的一种，NoSql，全名：Not Only Sql，是一种非关系型数据库，它不能替代关系弄数据库，只是关系型数据库的一个补充，是可以解决高并发、高可用、高扩展、大数据存储等一系列问题而产生的数据库解决方案。 redis是一种支持Key-Value等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。该数据库使用ANSI C语言编写，支持网络，redis支持的键值类型有：String字符类型、map散列类型、list列表类型、set集合类型、sortedset有序集合类型。基于内存，可持久化。 2，redis的应用场景有哪些 1，会话缓存（最常用） 2，消息队列，比如支付 3，活动排行榜或计数 4，发布，订阅消息（消息通知） 5，商品列表，评论列表等 安装Redis下载redis：1wget http://download.redis.io/releases/redis-3.0.0.tar.gz 使用ll命令查看当前目录下所有文件 可以看到redis-3.0.0.tar.gz就是刚刚下载的redis压缩包，现在对其解压： 1tar -zxvf redis-3.0.0.tar.gz 再使用ll命令查看当前目录下所有文件 编译安装Redis进入redis源码： 1cd redis-3.0.0 通过ll命令可以看到Redis源码目录下的所有文件，接下来就需要对源码进行编译了： 1make 使用make命令编译Redis需要c语言环境，CentOS自带c语言环境，若是使用其他Linux系统中没有c语言环境，则需要安装，如yum安装： yum install gcc-c++ 编译过后，就是安装了，安装Redis的命令如下： 1make install PREFIX=/usr/local/redis 该命令中，前面的”make install PREFIX=”是固定的，而”/usr/local/redis”是Redis的安装目录，一般就这么写，如若需要安装在其他地方，只需将此路径更换即可。 最后，查看Redis是否安装成功： 1cd /usr/local/redis/ 使用ll命令，可以看到bin文件夹，说明Redis已经安装成功。 Redis启动与停止Redis有两种启动，分别是：前端启动、后端启动。要启动Redis，就需要到Redis的bin目录下执行启动命令，先看看bin目录结构： 启动的配置：第一步，需要把redis源码目录下的redis.conf文件复制到redis安装目录的bin目录下。 第二步，修改redis.conf文件，将daemonize的值改为yes后保存。 启动的命令：1[root@localhost bin]# ./redis-server redis.conf 可以发现后端启动命令就只是比前端启动命令多了” redis.conf”，意思很明确，就是让redis根据这个配置文件的配置运行罢了，同时也可以看到，在启动完redis后台，终端不会进入redis控制台，这就是将redis运行后台了，我们可以查查看系统现在是不是有redis的进程： 1[root@localhost bin]# ps -aux | grep redis 关闭命令：12强制关闭：[root@localhost bin]# kill -9 进程id正常关闭：[root@localhost bin]# ./redis-cli shutdown 因为后端启动redis，没办法像前端启动redis那样直接ctrl+c强制关闭redis，如果需要强制关闭，那只能通过杀死进程的方式停止redis。而正常关闭redis的命令与前端关闭一样，这里就不多说废话。 项目中，建议使用正常关闭。因为redis作为缓存来使用的话，将数据存储到内存中，如果使用正常关闭，则会将内存数据持久化到本地之后，再关闭。如果强制关闭，则不会进行持久化操作，可能会造成部分数据丢失。 Redis开启远程访问redis默认只允许本地访问，要使redis可以远程访问可以修改redis.conf 开启远程访问将第70行的bind注释，第90行将protected-mode改为no 设置密码取消第502行的注释，并修改密码 重启redis：12345#首先查询到redis的pid后，kill掉,然后重启[root@localhost bin]# ps -ef|grep redisroot 20940 1 0 12:12 ? 00:00:18 ./redis-server *:6379 [root@localhost bin]# kill 20940[root@localhost bin]# ./redis-server redis.conf 最后我们使用redis客户端通过密码远程连接： 12#远程连接./redis-cli -h 你服务器的ip -p 6379 -a 你的密码 redis.conf 配置项说明1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381. Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程 daemonize no2. 当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定 pidfile /var/run/redis.pid3. 指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字 port 63794. 绑定的主机地址 bind 127.0.0.15.当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能 timeout 3006. 指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose loglevel verbose7. 日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null logfile stdout8. 设置数据库的数量，默认数据库为0，可以使用SELECT &lt;dbid&gt;命令在连接上指定数据库id databases 169. 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合 save &lt;seconds&gt; &lt;changes&gt; Redis默认配置文件中提供了三个条件： save 900 1 save 300 10 save 60 10000 分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。 10. 指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大 rdbcompression yes11. 指定本地数据库文件名，默认值为dump.rdb dbfilename dump.rdb12. 指定本地数据库存放目录 dir ./13. 设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步 slaveof &lt;masterip&gt; &lt;masterport&gt;14. 当master服务设置了密码保护时，slav服务连接master的密码 masterauth &lt;master-password&gt;15. 设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH &lt;password&gt;命令提供密码，默认关闭 requirepass foobared16. 设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息 maxclients 12817. 指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区 maxmemory &lt;bytes&gt;18. 指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no appendonly no19. 指定更新日志文件名，默认为appendonly.aof appendfilename appendonly.aof20. 指定更新日志条件，共有3个可选值： no：表示等操作系统进行数据缓存同步到磁盘（快） always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全） everysec：表示每秒同步一次（折中，默认值） appendfsync everysec 21. 指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制） vm-enabled no22. 虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享 vm-swap-file /tmp/redis.swap23. 将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0 vm-max-memory 024. Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值 vm-page-size 3225. 设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。 vm-pages 13421772826. 设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4 vm-max-threads 427. 设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启 glueoutputbuf yes28. 指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法 hash-max-zipmap-entries 64 hash-max-zipmap-value 51229. 指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍） activerehashing yes30. 指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件 include /path/to/local.conf python操作redis1、连接方式 redis-py提供两个类Redis和StrictRedis用于实现Redis的命令，StrictRedis用于实现大部分官方的命令，并使用官方的语法和命令，Redis是StrictRedis的子类 12345import redisr = redis.Redis(host='192.168.0.110', port=6379,db=0)r.set('name', 'zhangsan') #添加print (r.get('name')) #获取 2、连接池redis-py使用connection pool来管理对一个redis server的所有连接，避免每次建立、释放连接的开销。默认，每个Redis实例都会维护一个自己的连接池。可以直接建立一个连接池，然后作为参数Redis，这样就可以实现多个Redis实例共享一个连接池。 123456import redispool = redis.ConnectionPool(host='192.168.0.110', port=6379)r = redis.Redis(connection_pool=pool)r.set('name', 'zhangsan') #添加print (r.get('name')) #获取 3、操作1、String 操作redis中的String在在内存中按照一个name对应一个value来存储 set()12345678#在Redis中设置值，默认不存在则创建，存在则修改r.set('name', 'zhangsan')'''参数： set(name, value, ex=None, px=None, nx=False, xx=False) ex，过期时间（秒） px，过期时间（毫秒） nx，如果设置为True，则只有name不存在时，当前set操作才执行,同setnx(name, value) xx，如果设置为True，则只有name存在时，当前set操作才执行''' 12345setex(name, value, time)#设置过期时间（秒）psetex(name, time_ms, value)#设置过期时间（豪秒 mset()1234#批量设置值r.mset(name1='zhangsan', name2='lisi')#或r.mget(&#123;"name1":'zhangsan', "name2":'lisi'&#125;) get(name)获取值 mget(keys, *args)12345#批量获取print(r.mget("name1","name2"))#或li=["name1","name2"]print(r.mget(li)) getset(name, value)123#设置新值，打印原值print(r.getset("name1","wangwu")) #输出:zhangsanprint(r.get("name1")) #输出:wangwu getrange(key, start, end)123#根据字节获取子序列r.set("name","zhangsan")print(r.getrange("name",0,3))#输出:zhan setrange(name, offset, value)123456#修改字符串内容，从指定字符串索引开始向后替换，如果新值太长时，则向后添加r.set("name","zhangsan")r.setrange("name",1,"z")print(r.get("name")) #输出:zzangsanr.setrange("name",6,"zzzzzzz")print(r.get("name")) #输出:zzangszzzzzzz setbit(name, offset, value)1234567891011121314151617#对二进制表示位进行操作''' name:redis的name offset，位的索引（将值对应的ASCII码变换成二进制后再进行索引） value，值只能是 1 或 0 '''str="345"r.set("name",str)for i in str: print(i,ord(i),bin(ord(i)))#输出 值、ASCII码中对应的值、对应值转换的二进制'''输出:51 0b11001152 0b11010053 0b110101'''r.setbit("name",6,0)#把第7位改为0，也就是3对应的变成了0b110001print(r.get("name"))#输出：145 getbit(name, offset)1234#获取name对应值的二进制中某位的值(0或1)r.set("name","3") # 对应的二进制0b110011print(r.getbit("name",5)) #输出:0print(r.getbit("name",6)) #输出:1 bitcount(key, start=None, end=None)123456#获取对应二进制中1的个数r.set("name","345")#0b110011 0b110100 0b110101print(r.bitcount("name",start=0,end=1)) #输出:7''' key:Redis的name start:字节起始位置 end:字节结束位置''' strlen(name)123#返回name对应值的字节长度（一个汉字3个字节）r.set("name","zhangsan")print(r.strlen("name")) #输出:8 incr(self, name, amount=1)123456#自增mount对应的值，当mount不存在时，则创建mount＝amount，否则，则自增,amount为自增数(整数)print(r.incr("mount",amount=2))#输出:2print(r.incr("mount"))#输出:3print(r.incr("mount",amount=3))#输出:6print(r.incr("mount",amount=6))#输出:12print(r.get("mount")) #输出:12 incrbyfloat(self, name, amount=1.0)1#类似 incr() 自增,amount为自增数(浮点数) decr(self, name, amount=1)1#自减name对应的值,当name不存在时,则创建name＝amount，否则，则自减，amount为自增数(整数) append(name, value)12345#在name对应的值后面追加内容r.set("name","zhangsan")print(r.get("name")) #输出:'zhangsanr.append("name","lisi")print(r.get("name")) #输出:zhangsanlisi 2、Hash 操作redis中的Hash 在内存中类似于一个name对应一个dic来存储 hset(name, key, value)12#name对应的hash中设置一个键值对（不存在，则创建，否则，修改）r.hset("dic_name","a1","aa") hget(name,key)123r.hset("dic_name","a1","aa")#在name对应的hash中根据key获取valueprint(r.hget("dic_name","a1"))#输出:aa hgetall(name)12#获取name对应hash的所有键值print(r.hgetall("dic_name")) hmset(name, mapping)1234#在name对应的hash中批量设置键值对,mapping:字典dic=&#123;"a1":"aa","b1":"bb"&#125;r.hmset("dic_name",dic)print(r.hget("dic_name","b1"))#输出:bb hmget(name, keys, *args)1234# 在name对应的hash中获取多个key的值li=["a1","b1"]print(r.hmget("dic_name",li))print(r.hmget("dic_name","a1","b1")) hlen(name)、hkeys(name)、hvals(name)1234567891011dic=&#123;"a1":"aa","b1":"bb"&#125;r.hmset("dic_name",dic)#hlen(name) 获取hash中键值对的个数print(r.hlen("dic_name"))#hkeys(name) 获取hash中所有的key的值print(r.hkeys("dic_name"))#hvals(name) 获取hash中所有的value的值print(r.hvals("dic_name")) hexists(name, key)12#检查name对应的hash是否存在当前传入的keyprint(r.hexists("dic_name","a1"))#输出:True hdel(name,*keys)12#删除指定name对应的key所在的键值对r.hdel("dic_name","a1") hincrby(name, key, amount=1)12#自增hash中key对应的值，不存在则创建key=amount(amount为整数)print(r.hincrby("demo","a",amount=2)) hincrbyfloat(name, key, amount=1.0)1#自增hash中key对应的值，不存在则创建key=amount(amount为浮点数) hscan(name, cursor=0, match=None, count=None)hscan_iter(name, match=None, count=None)3、List 操作redis中的List在在内存中按照一个name对应一个List来存储 lpush(name,values)123# 在name对应的list中添加元素，每个新的元素都添加到列表的最左边r.lpush("list_name",2)r.lpush("list_name",3,4,5)#保存在列表中的顺序为5，4，3，2 rpush(name,values)1#同lpush，但每个新的元素都添加到列表的最右边 lpushx(name,value)1#在name对应的list中添加元素，只有name已经存在时，值添加到列表的最左边 rpushx(name,value)1#在name对应的list中添加元素，只有name已经存在时，值添加到列表的最右边 llen(name)12# name对应的list元素的个数print(r.llen("list_name")) linsert(name, where, refvalue, value))12345678# 在name对应的列表的某一个值前或后插入一个新值r.linsert("list_name","BEFORE","2","SS")#在列表内找到第一个元素2，在它前面插入SS'''参数： name: redis的name where: BEFORE（前）或AFTER（后） refvalue: 列表内的值 value: 要插入的数据''' r.lset(name, index, value)12#对list中的某一个索引位置重新赋值r.lset("list_name",0,"bbb") r.lrem(name, value, num)123456789#删除name对应的list中的指定值r.lrem("list_name","SS",num=0)''' 参数： name: redis的name value: 要删除的值 num: num=0 删除列表中所有的指定值； num=2 从前到后，删除2个； num=-2 从后向前，删除2个''' lpop(name)12#移除列表的左侧第一个元素，返回值则是第一个元素print(r.lpop("list_name")) lindex(name, index)12#根据索引获取列表内元素print(r.lindex("list_name",1)) lrange(name, start, end)12#分片获取元素print(r.lrange("list_name",0,-1)) ltrim(name, start, end)12#移除列表内没有在该索引之内的值r.ltrim("list_name",0,2) rpoplpush(src, dst)123# 从一个列表取出最右边的元素，同时将其添加至另一个列表的最左边#src 要取数据的列表#dst 要添加数据的列表 brpoplpush(src, dst, timeout=0)12#同rpoplpush，多了个timeout, timeout：取数据的列表没元素后的阻塞时间，0为一直阻塞r.brpoplpush("list_name","list_name1",timeout=0) blpop(keys, timeout)12345678910#将多个列表排列,按照从左到右去移除各个列表内的元素r.lpush("list_name",3,4,5)r.lpush("list_name1",3,4,5)while True: print(r.blpop(["list_name","list_name1"],timeout=0)) print(r.lrange("list_name",0,-1),r.lrange("list_name1",0,-1))'''keys: redis的name的集合 timeout: 超时时间，获取完所有列表的元素之后，阻塞等待列表内有数据的时间（秒）, 0 表示永远阻塞''' r.brpop(keys, timeout)1#同blpop，将多个列表排列,按照从右像左去移除各个列表内的元素 4、Set 操作Set集合就是不允许重复的列表 sadd(name,values)123#给name对应的集合中添加元素r.sadd("set_name","aa")r.sadd("set_name","aa","bb") smembers(name)1#获取name对应的集合的所有成员 scard(name)12#获取name对应的集合中的元素个数r.scard("set_name") sdiff(keys, *args)123456#在第一个name对应的集合中且不在其他name对应的集合的元素集合r.sadd("set_name","aa","bb")r.sadd("set_name1","bb","cc")r.sadd("set_name2","bb","cc","dd")print(r.sdiff("set_name","set_name1","set_name2"))#输出:｛aa｝ sdiffstore(dest, keys, *args)1#相当于把sdiff获取的值加入到dest对应的集合中 sinter(keys, *args)123456# 获取多个name对应集合的并集r.sadd("set_name","aa","bb")r.sadd("set_name1","bb","cc")r.sadd("set_name2","bb","cc","dd")print(r.sinter("set_name","set_name1","set_name2"))#输出:｛bb｝ sinterstore(dest, keys, *args)1#获取多个name对应集合的并集，再讲其加入到dest对应的集合中 sismember(name, value)1#检查value是否是name对应的集合内的元素 smove(src, dst, value)1#将某个元素从一个集合中移动到另外一个集合 spop(name)1#从集合的右侧移除一个元素，并将其返回 srandmember(name, numbers)12# 从name对应的集合中随机获取numbers个元素print(r.srandmember("set_name2",2)) srem(name, values)12#删除name对应的集合中的某些值print(r.srem("set_name2","bb","dd")) sunion(keys, *args)12#获取多个name对应的集合的并集r.sunion("set_name","set_name1","set_name2") sunionstore(dest,keys, *args)1#获取多个name对应的集合的并集，并将结果保存到dest对应的集合中 5、有序集合：在集合的基础上，为每元素排序，元素的排序需要根据另外一个值来进行比较，所以，对于有序集合，每一个元素有两个值，即：值和分数，分数专门用来做排序。 zadd(name, *args, **kwargs)1234# 在name对应的有序集合中添加元素r.zadd("zset_name", "a1", 6, "a2", 2,"a3",5)#或r.zadd('zset_name1', b1=10, b2=5) zcard(name)1#获取有序集合内元素的数量 zcount(name, min, max)12#获取有序集合中分数在[min,max]之间的个数print(r.zcount("zset_name",1,5)) zincrby(name, value, amount)12#自增有序集合内value对应的分数r.zincrby("zset_name","a1",amount=2)#自增zset_name对应的有序集合里a1对应的分数 zrange( name, start, end, desc=False, withscores=False, score_cast_func=float)12345678910# 按照索引范围获取name对应的有序集合的元素aa=r.zrange("zset_name",0,1,desc=False,withscores=True,score_cast_func=int)print(aa)'''参数： name redis的name start 有序集合索引起始位置 end 有序集合索引结束位置 desc 排序规则，默认按照分数从小到大排序 withscores 是否获取元素的分数，默认只获取元素的值 score_cast_func 对分数进行数据转换的函数''' zrevrange(name, start, end, withscores=False, score_cast_func=float)1#同zrange，集合是从大到小排序的 zrank(name, value)、zrevrank(name, value)1234#获取value值在name对应的有序集合中的排行位置（从0开始）print(r.zrank("zset_name", "a2"))print(r.zrevrank("zset_name", "a2"))#从大到小排序 zscore(name, value)12#获取name对应有序集合中 value 对应的分数print(r.zscore("zset_name","a1")) zrem(name, values)12#删除name对应的有序集合中值是values的成员r.zrem("zset_name","a1","a2") zremrangebyrank(name, min, max)1#根据排行范围删除 zremrangebyscore(name, min, max)1#根据分数范围删除 zinterstore(dest, keys, aggregate=None)1234567r.zadd("zset_name", "a1", 6, "a2", 2,"a3",5)r.zadd('zset_name1', a1=7,b1=10, b2=5)# 获取两个有序集合的交集并放入dest集合，如果遇到相同值不同分数，则按照aggregate进行操作# aggregate的值为: SUM MIN MAXr.zinterstore("zset_name2",("zset_name1","zset_name"),aggregate="MAX")print(r.zscan("zset_name2")) zunionstore(dest, keys, aggregate=None)1#获取两个有序集合的并集并放入dest集合，其他同zinterstore， 6、其他常用操作delete(*names)1#根据name删除redis中的任意数据类型 exists(name)1#检测redis的name是否存在 keys(pattern=’*’)1#根据* ？等通配符匹配获取redis的name expire(name ,time)1# 为某个name设置超时时间 rename(src, dst)1# 重命名 move(name, db))1# 将redis的某个值移动到指定的db下 randomkey()1#随机获取一个redis的name（不删除） type(name)1# 获取name对应值的类型 4、管道redis-py默认在执行每次请求都会创建（连接池申请连接）和断开（归还连接池）一次连接操作，如果想要在一次请求中指定多个命令，则可以使用pipline实现一次请求指定多个命令，并且默认情况下一次pipline 是原子性操作。 12345678910import redispool = redis.ConnectionPool(host='192.168.0.110', port=6379)r = redis.Redis(connection_pool=pool)pipe = r.pipeline(transaction=True)r.set('name', 'zhangsan')r.set('name', 'lisi')pipe.execute() 5、发布和订阅首先定义一个RedisHelper类，连接Redis，定义频道为monitor，定义发布(publish)及订阅(subscribe)方法。 12345678910111213141516import redisclass RedisHelper(object): def __init__(self): self.__conn = redis.Redis(host='192.168.0.110',port=6379)#连接Redis self.channel = 'monitor' #定义名称 def publish(self,msg):#定义发布方法 self.__conn.publish(self.channel,msg) return True def subscribe(self):#定义订阅方法 pub = self.__conn.pubsub() pub.subscribe(self.channel) pub.parse_response() return pub 发布者 12345#发布from RedisHelper import RedisHelperobj = RedisHelper()obj.publish('hello')#发布 订阅者 123456789#订阅from RedisHelper import RedisHelperobj = RedisHelper()redis_sub = obj.subscribe()#调用订阅方法while True: msg= redis_sub.parse_response() print (msg)]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BeautifulSoup]]></title>
    <url>%2F2019%2F01%2F03%2FBeautifulSoup%2F</url>
    <content type="text"><![CDATA[BeautifulSoupBeautifulSoup是一个模块，该模块用于接收一个HTML或XML字符串，然后将其进行格式化，之后遍可以使用他提供的方法进行快速查找指定元素，从而使得在HTML或XML中查找指定元素变得简单。 12345678910111213141516171819202122232425262728from bs4 import BeautifulSoup html_doc = """&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;asdf &lt;div class="title"&gt; &lt;b&gt;The Dormouse's story总共&lt;/b&gt; &lt;h1&gt;f&lt;/h1&gt; &lt;/div&gt;&lt;div class="story"&gt;Once upon a time there were three little sisters; and their names were &lt;a class="sister0" id="link1"&gt;Els&lt;span&gt;f&lt;/span&gt;ie&lt;/a&gt;, &lt;a href="http://example.com/lacie" class="sister" id="link2"&gt;Lacie&lt;/a&gt; and &lt;a href="http://example.com/tillie" class="sister" id="link3"&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/div&gt;ad&lt;br/&gt;sf&lt;p class="story"&gt;...&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;""" soup = BeautifulSoup(html_doc, features="html.parser")# 找到第一个a标签tag1 = soup.find(name='a')# 找到所有的a标签tag2 = soup.find_all(name='a')# 找到id＝link2的标签tag3 = soup.select('#link2') 安装：1pip3 install beautifulsoup4 使用示例：1234567891011from bs4 import BeautifulSoup html_doc = """&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;body&gt; ...&lt;/body&gt;&lt;/html&gt;""" soup = BeautifulSoup(html_doc, features="html.parser") name 标签名称12345tag = soup.find('a')name = tag.name # 获取print(name)tag.name = 'span' # 设置print(soup) attr 标签属性123456tag = soup.find('a')attrs = tag.attrs # 获取print(attrs)tag.attrs = &#123;'ik':123&#125; # 设置tag.attrs['id'] = 'iiiii' # 设置print(soup) children 所有子标签12body = soup.find('body')v = body.children descendants 所有子子孙孙标签12body = soup.find('body')v = body.descendants clear 将标签的所有子标签全部清空（保留标签名）123tag = soup.find('body')tag.clear()print(soup) decompose 递归的删除所有的标签123body = soup.find('body')body.decompose()print(soup) extract 递归的删除所有的标签，并获取删除的标签123body = soup.find('body')v = body.extract()print(soup) decode 转换为字符串（含当前标签）；decode_contents（不含当前标签）1234body = soup.find('body')v = body.decode()v = body.decode_contents()print(v) encode 转换为字节（含当前标签）；encode_contents（不含当前标签）1234body = soup.find('body')v = body.encode()v = body.encode_contents()print(v) find 获取匹配的第一个标签12345tag = soup.find('a')print(tag)tag = soup.find(name='a', attrs=&#123;'class': 'sister'&#125;, recursive=True, text='Lacie')tag = soup.find(name='a', class_='sister', recursive=True, text='Lacie')print(tag) find_all 获取匹配的所有标签123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354tags = soup.find_all('a')print(tags) tags = soup.find_all('a',limit=1)print(tags) tags = soup.find_all(name='a', attrs=&#123;'class': 'sister'&#125;, recursive=True, text='Lacie')tags = soup.find(name='a', class_='sister', recursive=True, text='Lacie')print(tags) ####### 列表 #######v = soup.find_all(name=['a','div'])print(v) v = soup.find_all(class_=['sister0', 'sister'])print(v) v = soup.find_all(text=['Tillie'])print(v, type(v[0])) v = soup.find_all(id=['link1','link2'])print(v) v = soup.find_all(href=['link1','link2'])print(v) ####### 正则 #######import rerep = re.compile('p')rep = re.compile('^p')v = soup.find_all(name=rep)print(v) rep = re.compile('sister.*')v = soup.find_all(class_=rep)print(v) rep = re.compile('http://www.oldboy.com/static/.*')v = soup.find_all(href=rep)print(v) ####### 方法筛选 #######def func(tag):return tag.has_attr('class') and tag.has_attr('id')v = soup.find_all(name=func)print(v) # get,获取标签属性tag = soup.find('a')v = tag.get('id')print(v) has_attr 检查标签是否具有该属性123tag = soup.find('a')v = tag.has_attr('id')print(v) get_text 获取标签内部文本内容123tag = soup.find('a')v = tag.get_text('id')print(v) index 检查标签在某标签中的索引位置1234567tag = soup.find('body')v = tag.index(tag.find('div'))print(v) tag = soup.find('body')for i,v in enumerate(tag):print(i,v) is_empty_element 是否是空标签(是否可以是空)或者自闭合标签判断是否是如下标签：’br’ , ‘hr’, ‘input’, ‘img’, ‘meta’,’spacer’, ‘link’, ‘frame’, ‘base’ 123tag = soup.find('br')v = tag.is_empty_elementprint(v) 当前的关联标签12345678910111213141516# soup.next# soup.next_element# soup.next_elements# soup.next_sibling# soup.next_siblings ## tag.previous# tag.previous_element# tag.previous_elements# tag.previous_sibling# tag.previous_siblings ## tag.parent# tag.parents 查找某标签的关联标签1234567891011121314# tag.find_next(...)# tag.find_all_next(...)# tag.find_next_sibling(...)# tag.find_next_siblings(...) # tag.find_previous(...)# tag.find_all_previous(...)# tag.find_previous_sibling(...)# tag.find_previous_siblings(...) # tag.find_parent(...)# tag.find_parents(...) # 参数同find_all select,select_one, CSS选择器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667soup.select("title") soup.select("p nth-of-type(3)") soup.select("body a") soup.select("html head title") tag = soup.select("span,a") soup.select("head &gt; title") soup.select("p &gt; a") soup.select("p &gt; a:nth-of-type(2)") soup.select("p &gt; #link1") soup.select("body &gt; a") soup.select("#link1 ~ .sister") soup.select("#link1 + .sister") soup.select(".sister") soup.select("[class~=sister]") soup.select("#link1") soup.select("a#link2") soup.select('a[href]') soup.select('a[href="http://example.com/elsie"]') soup.select('a[href^="http://example.com/"]') soup.select('a[href$="tillie"]') soup.select('a[href*=".com/el"]') from bs4.element import Tag def default_candidate_generator(tag): for child in tag.descendants: if not isinstance(child, Tag): continue if not child.has_attr('href'): continue yield child tags = soup.find('body').select("a", _candidate_generator=default_candidate_generator)print(type(tags), tags) from bs4.element import Tagdef default_candidate_generator(tag): for child in tag.descendants: if not isinstance(child, Tag): continue if not child.has_attr('href'): continue yield child tags = soup.find('body').select("a", _candidate_generator=default_candidate_generator, limit=1)print(type(tags), tags) 标签的内容12345678910111213tag = soup.find('span')print(tag.string) # 获取tag.string = 'new content' # 设置print(soup) tag = soup.find('body')print(tag.string)tag.string = 'xxx'print(soup) tag = soup.find('body')v = tag.stripped_strings # 递归内部获取所有标签的文本print(v) append 在当前标签内部追加一个标签12345678910tag = soup.find('body')tag.append(soup.find('a'))print(soup)from bs4.element import Tagobj = Tag(name='i',attrs=&#123;'id': 'it'&#125;)obj.string = '我是一个新来的'tag = soup.find('body')tag.append(obj)print(soup) insert在当前标签内部指定位置插入一个标签123456from bs4.element import Tagobj = Tag(name='i', attrs=&#123;'id': 'it'&#125;)obj.string = '我是一个新来的'tag = soup.find('body')tag.insert(2, obj)print(soup) insert_after,insert_before 在当前标签后面或前面插入1234567from bs4.element import Tagobj = Tag(name='i', attrs=&#123;'id': 'it'&#125;)obj.string = '我是一个新来的'tag = soup.find('body')#tag.insert_before(obj)#tag.insert_after(obj)print(soup) replace_with 在当前标签替换为指定标签123456from bs4.element import Tagobj = Tag(name='i', attrs=&#123;'id': 'it'&#125;)obj.string = '我是一个新来的'tag = soup.find('div')tag.replace_with(obj)print(soup) 创建标签之间的关系1234tag = soup.find('div')a = soup.find('a')tag.setup(previous_sibling=a)print(tag.previous_sibling) wrap 将指定标签把当前标签包裹起来1234567891011from bs4.element import Tagobj1 = Tag(name='div', attrs=&#123;'id': 'it'&#125;)obj1.string = '我是一个新来的'tag = soup.find('a')v = tag.wrap(obj1)print(soup) tag = soup.find('a')v = tag.wrap(soup.find('p'))print(soup) unwrap 去掉当前标签，将保留其包裹的标签123tag = soup.find('a')v = tag.unwrap()print(soup)]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>BeautifulSoup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[requests]]></title>
    <url>%2F2019%2F01%2F02%2Frequests%2F</url>
    <content type="text"><![CDATA[什么是RequestsRequests是用python语言基于urllib编写的，采用的是Apache2 Licensed开源协议的HTTP库如果你看过上篇文章关于urllib库的使用，你会发现，其实urllib还是非常不方便的，而Requests它会比urllib更加方便，可以节约我们大量的工作。（用了requests之后，你基本都不愿意用urllib了）一句话，requests是python实现的最简单易用的HTTP库，建议爬虫使用requests库。 默认安装好python之后，是没有安装requests模块的，需要单独通过pip安装 requests功能详解总体功能的一个演示12345678910import requestsresponse = requests.get("https://www.baidu.com")print(type(response))print(response.status_code)print(type(response.text))print(response.text)print(response.cookies)print(response.content)print(response.content.decode("utf-8")) 我们可以看出response使用起来确实非常方便，这里有个问题需要注意一下：很多情况下的网站如果直接response.text会出现乱码的问题，所以这个使用response.content这样返回的数据格式其实是二进制格式，然后通过decode()转换为utf-8，这样就解决了通过response.text直接返回显示乱码的问题. 请求发出后，Requests 会基于 HTTP 头部对响应的编码作出有根据的推测。当你访问 response.text 之时，Requests 会使用其推测的文本编码。你可以找出 Requests 使用了什么编码，并且能够使用 response.encoding 属性来改变它.如： 123response =requests.get("http://www.baidu.com")response.encoding="utf-8"print(response.text) 不管是通过response.content.decode(“utf-8)的方式还是通过response.encoding=”utf-8”的方式都可以避免乱码的问题发生 各种请求方式requests里提供个各种请求方式 1234567import requestsrequests.get("http://httpbin.org/post")requests.post("http://httpbin.org/post")requests.put("http://httpbin.org/put")requests.delete("http://httpbin.org/delete")requests.head("http://httpbin.org/get")requests.options("http://httpbin.org/get") 请求 基本GET请求 1234import requestsresponse = requests.get('http://httpbin.org/get')print(response.text) 带参数的GET请求，例子1 1234import requestsresponse = requests.get("http://httpbin.org/get?name=zhaofan&amp;age=23")print(response.text) 如果我们想要在URL查询字符串传递数据，通常我们会通过httpbin.org/get?key=val方式传递。Requests模块允许使用params关键字传递参数，以一个字典来传递这些参数，例子如下： 12345678import requestsdata = &#123; "name":"zhaofan", "age":22&#125;response = requests.get("http://httpbin.org/get",params=data)print(response.url)print(response.text) 上述两种的结果是相同的，通过params参数传递一个字典内容，从而直接构造url注意：第二种方式通过字典的方式的时候，如果字典中的参数为None则不会添加到url上 解析json 12345678import requestsimport jsonresponse = requests.get("http://httpbin.org/get")print(type(response.text))print(response.json())print(json.loads(response.text))print(type(response.json())) 从结果可以看出requests里面集成的json其实就是执行了json.loads()方法，两者的结果是一样的 获取二进制数据 在上面提到了response.content，这样获取的数据是二进制数据，同样的这个方法也可以用于下载图片以及视频资源 添加headers和前面我们将urllib模块的时候一样，我们同样可以定制headers的信息，如当我们直接通过requests请求知乎网站的时候，默认是无法访问的 123import requestsresponse =requests.get("https://www.zhihu.com")print(response.text) 这样会得到如下的错误 因为访问知乎需要头部信息，这个时候我们在谷歌浏览器里输入chrome://version,就可以看到用户代理，将用户代理添加到头部信息 12345678import requestsheaders = &#123; "User-Agent":"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36"&#125;response =requests.get("https://www.zhihu.com",headers=headers)print(response.text) 这样就可以正常的访问知乎了 基本POST请求 通过在发送post请求时添加一个data参数，这个data参数可以通过字典构造成，这样对于发送post请求就非常方便 12345678import requestsdata = &#123; "name":"zhaofan", "age":23&#125;response = requests.post("http://httpbin.org/post",data=data)print(response.text) 同样的在发送post请求的时候也可以和发送get请求一样通过headers参数传递一个字典类型的数据 响应 我们可以通过response获得很多属性，例子如下 12345678import requestsresponse = requests.get("http://www.baidu.com")print(type(response.status_code),response.status_code)print(type(response.headers),response.headers)print(type(response.cookies),response.cookies)print(type(response.url),response.url)print(type(response.history),response.history) 状态码判断Requests还附带了一个内置的状态码查询对象主要有如下内容： 100: (‘continue’,),101: (‘switching_protocols’,),102: (‘processing’,),103: (‘checkpoint’,),122: (‘uri_too_long’, ‘request_uri_too_long’),200: (‘ok’, ‘okay’, ‘all_ok’, ‘all_okay’, ‘all_good’, ‘\o/‘, ‘✓’),201: (‘created’,),202: (‘accepted’,),203: (‘non_authoritative_info’, ‘non_authoritative_information’),204: (‘no_content’,),205: (‘reset_content’, ‘reset’),206: (‘partial_content’, ‘partial’),207: (‘multi_status’, ‘multiple_status’, ‘multi_stati’, ‘multiple_stati’),208: (‘already_reported’,),226: (‘im_used’,), Redirection.300: (‘multiple_choices’,),301: (‘moved_permanently’, ‘moved’, ‘\o-‘),302: (‘found’,),303: (‘see_other’, ‘other’),304: (‘not_modified’,),305: (‘use_proxy’,),306: (‘switch_proxy’,),307: (‘temporary_redirect’, ‘temporary_moved’, ‘temporary’),308: (‘permanent_redirect’,‘resume_incomplete’, ‘resume’,), # These 2 to be removed in 3.0 Client Error.400: (‘bad_request’, ‘bad’),401: (‘unauthorized’,),402: (‘payment_required’, ‘payment’),403: (‘forbidden’,),404: (‘not_found’, ‘-o-‘),405: (‘method_not_allowed’, ‘not_allowed’),406: (‘not_acceptable’,),407: (‘proxy_authentication_required’, ‘proxy_auth’, ‘proxy_authentication’),408: (‘request_timeout’, ‘timeout’),409: (‘conflict’,),410: (‘gone’,),411: (‘length_required’,),412: (‘precondition_failed’, ‘precondition’),413: (‘request_entity_too_large’,),414: (‘request_uri_too_large’,),415: (‘unsupported_media_type’, ‘unsupported_media’, ‘media_type’),416: (‘requested_range_not_satisfiable’, ‘requested_range’, ‘range_not_satisfiable’),417: (‘expectation_failed’,),418: (‘im_a_teapot’, ‘teapot’, ‘i_am_a_teapot’),421: (‘misdirected_request’,),422: (‘unprocessable_entity’, ‘unprocessable’),423: (‘locked’,),424: (‘failed_dependency’, ‘dependency’),425: (‘unordered_collection’, ‘unordered’),426: (‘upgrade_required’, ‘upgrade’),428: (‘precondition_required’, ‘precondition’),429: (‘too_many_requests’, ‘too_many’),431: (‘header_fields_too_large’, ‘fields_too_large’),444: (‘no_response’, ‘none’),449: (‘retry_with’, ‘retry’),450: (‘blocked_by_windows_parental_controls’, ‘parental_controls’),451: (‘unavailable_for_legal_reasons’, ‘legal_reasons’),499: (‘client_closed_request’,), Server Error.500: (‘internal_server_error’, ‘server_error’, ‘/o\’, ‘✗’),501: (‘not_implemented’,),502: (‘bad_gateway’,),503: (‘service_unavailable’, ‘unavailable’),504: (‘gateway_timeout’,),505: (‘http_version_not_supported’, ‘http_version’),506: (‘variant_also_negotiates’,),507: (‘insufficient_storage’,),509: (‘bandwidth_limit_exceeded’, ‘bandwidth’),510: (‘not_extended’,),511: (‘network_authentication_required’, ‘network_auth’, ‘network_authentication’), 通过下面例子测试：（不过通常还是通过状态码判断更方便） 12345import requestsresponse= requests.get("http://www.baidu.com")if response.status_code == requests.codes.ok: print("访问成功") requests高级用法文件上传 实现方法和其他参数类似，也是构造一个字典然后通过files参数传递 1234import requestsfiles= &#123;"files":open("git.jpeg","rb")&#125;response = requests.post("http://httpbin.org/post",files=files)print(response.text) 结果如下： 获取cookie 1234567import requestsresponse = requests.get("http://www.baidu.com")print(response.cookies)for key,value in response.cookies.items(): print(key+"="+value) 会话维持 cookie的一个作用就是可以用于模拟登陆，做会话维持 12345import requestss = requests.Session()s.get("http://httpbin.org/cookies/set/number/123456")response = s.get("http://httpbin.org/cookies")print(response.text) 这是正确的写法，而下面的写法则是错误的 12345import requestsrequests.get("http://httpbin.org/cookies/set/number/123456")response = requests.get("http://httpbin.org/cookies")print(response.text) 因为这种方式是两次requests请求之间是独立的，而第一次则是通过创建一个session对象，两次请求都通过这个对象访问 证书验证 现在的很多网站都是https的方式访问，所以这个时候就涉及到证书的问题 1234import requestsresponse = requests.get("https:/www.12306.cn")print(response.status_code) 默认的12306网站的证书是不合法的，这样就会提示如下错误 为了避免这种情况的发生可以通过verify=False但是这样是可以访问到页面，但是会提示： 1InsecureRequestWarning: Unverified HTTPS request is being made. Adding certificate verification is strongly advised. See: &lt;https://urllib3.readthedocs.io/en/latest/advanced-usage.html#ssl-warnings&gt; InsecureRequestWarning) 解决方法为： 12345import requestsfrom requests.packages import urllib3urllib3.disable_warnings()response = requests.get("https://www.12306.cn",verify=False)print(response.status_code) 这样就不会提示警告信息，当然也可以通过cert参数放入证书路径 代理设置 12345678import requestsproxies= &#123; "http":"http://127.0.0.1:9999", "https":"http://127.0.0.1:8888"&#125;response = requests.get("https://www.baidu.com",proxies=proxies)print(response.text) 如果代理需要设置账户名和密码,只需要将字典更改为如下：proxies = {“http”:”http://user:password@127.0.0.1:9999“}如果你的代理是通过sokces这种方式则需要pip install “requests[socks]”proxies= {“http”:”socks5://127.0.0.1:9999”,“https”:”sockes5://127.0.0.1:8888”} 超时设置 通过timeout参数可以设置超时的时间 认证设置 如果碰到需要认证的网站可以通过requests.auth模块实现 123456import requestsfrom requests.auth import HTTPBasicAuthresponse = requests.get("http://120.27.34.24:9001/",auth=HTTPBasicAuth("user","123"))print(response.status_code) 当然这里还有一种方式 1234import requestsresponse = requests.get("http://120.27.34.24:9001/",auth=("user","123"))print(response.status_code) 异常处理 关于reqeusts的异常在这里可以看到详细内容：http://www.python-requests.org/en/master/api/#exceptions所有的异常都是在requests.excepitons中 从源码我们可以看出RequestException继承IOError,HTTPError，ConnectionError,Timeout继承RequestionExceptionProxyError，SSLError继承ConnectionErrorReadTimeout继承Timeout异常这里列举了一些常用的异常继承关系，详细的可以看：http://cn.python-requests.org/zh_CN/latest/_modules/requests/exceptions.html#RequestException 通过下面的例子进行简单的演示 1234567891011121314import requestsfrom requests.exceptions import ReadTimeout,ConnectionError,RequestExceptiontry: response = requests.get("http://httpbin.org/get",timout=0.1) print(response.status_code)except ReadTimeout: print("timeout")except ConnectionError: print("connection Error")except RequestException: print("error") 其实最后测试可以发现，首先被捕捉的异常是timeout,当把网络断掉的haul就会捕捉到ConnectionError，如果前面异常都没有捕捉到，最后也可以通过RequestExctption捕捉到]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>requests</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git]]></title>
    <url>%2F2019%2F01%2F01%2Fgit%2F</url>
    <content type="text"><![CDATA[相关概念了解Git存储数据的方式：对当时的全部文件制作一个快照并保存这个快照的索引。 为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。Git保证数据完整性：所有数据在存储前都计算校验和，然后以校验和来引用Git 计算校验和的机制：SHA-1 散列，这由 40 个十六进制字符（0-9 和 a-f）组成字符串Git的三种状态：已提交（committed）、已修改（modified）和已暂存（staged）Git的三种工作区域： Git 仓库（.git directory）：Git 用来保存项目的元数据和对象数据库的地方 工作目录(Working Directory)：对项目的某个版本独立提取出来的内容 暂存区域(Stagign Area)：保存了下次将提交的文件列表信息 基本的 Git 工作流程 在工作目录中修改文件。 暂存文件，将文件的快照放入暂存区域。 提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录 安装centos: 1sudo yum install git unbuntu 1sudo apt-get install git windows 1直接在官网下载安装 初次运行前的git配置git config 工具Git 自带一个 git config 的工具来帮助设置控制 Git 外观和行为的配置变量。 /etc/gitconfig文件：包含系统上每一个用户及他们仓库的通用配置。 如果使用带有 –system 选项的 git config时，它会从此文件读写配置变量。 ~/.gitconfig或 ~/.config/git/config文件：只针对当前用户。 可以传递 –global 选项让 Git 读写此文件。 .git/config 文件：针对该仓库。 每一个级别覆盖上一级别的配置，所以 .git/config 的配置变量会覆盖 /etc/gitconfig 中的配置变量。也就是说 .git/config &gt; /etc/gitconfig &gt; /etc/gitconfig 用户信息当安装完 Git 应该做的第一件事就是设置用户名称与邮件地址。每一个 Git 的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改： 123456#针对当前用户的操作git config --global user.name "Fame Lee"git config --global user.email famelee@example.com#如果对特定项目使用不同的用户名称与邮件地址，可以在哪个项目下执行不带--global的操作git config user.name "Fame Lee"git config user.email famelee@example.com 检查用户配置信息如果需要检查配置，则输入 1git config --list 可能会看到重复变量名，因为有3个配置文件。如果想要查看某一个指定的变量，则输入git config &lt; key &gt; 1git config user.name 文本编辑器配置默认编辑器，在 git 输入信息时会掉用。没有配置的话会使用系统默认的文本编辑器（通常是 vim ）,如果想要设置，例如 Emacs 编辑器，则输入以下命令 1git config --global core.editor emacs 获取帮助git 有三种方式获取帮助 1234#git help &lt;verb&gt;#git &lt;verb&gt; --help#man git -&lt;verb&gt;git help config 获取Git仓库一共有两种方法获取git项目的仓库。 在现有项目或目录下导入所有文件到 Git 中； 第二种是从一个服务器克隆一个现有的 Git 仓库 在现有目录中初始化仓库初始化操作 1git init 该命令会创建一个 .git 子目录(存放 git 核心文件)。 克隆现有仓库克隆仓库的命令为 git clone [url] [name] 123456# 克隆仓库到当前目录，仓库名默认git clone https://github.com/demo/demo# 自定义本地仓库名字git clone https://github.com/demo/demo mydemo# 不带工作区git clone --bare 执行完后有当前目录会有两个文件夹 demo文件夹：项目文件都会在这 .git文件夹：存放远程仓库的数据，从中读取最新版本的文件的拷贝 文件更新文件的状态在 git 工作目录下的文件一共有两种状态： 已跟踪：指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于未修改，已修改或已放入暂存区。 未跟踪：除已跟踪文件以外的所有其它文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有放入暂存区 初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态 查看文件状态 1git status 紧凑输出文件状态 123git status -s#或者git status --short 紧凑输出结果如下 12345M README #右M：文件被修改了但是还没放入暂存区MM Rakefile #MM:在工作区被修改并提交到暂存区后又在工作区中被修改A lib/git.rb #A 新添加到缓存区的文件M lib/simplegit.rb #左M：文件被修改了并放入了暂存区?? LICENSE.txt #??：新添加但为加入缓存区的文件 git的生命周期如下图，可以看到 处于 Untrcked(未跟踪) 的文件经过添Add the file(追加文件), 追加的文件状态变为 staged(暂存) 处于 Unmodeifed(未更改) 的文件经过 Edit the file(修改文件) 后，状态变为 Modeified(已修改) 处于Modeified(已修改),经过stage the file(暂存操作)，会存入到暂存区，此时文件状态变为 staged(暂存) 文件经过 commit(提交后)，变为Unmodeifed(未更改) 暂存文件添加内容到下一次提交中 : git add 1234# 参数为filegit add README# 参数为pathgit add /home/git/ 经过该命令后，文件将会被跟踪且放入暂存区。所以该命令使用的效果有 将单个文件变为跟踪状态，并放入暂存区 将路径下所有文件递归设置成跟踪状态，并放入暂存区 对于已经是跟踪状态的已经修改文件，放入暂存区 查看未暂存的文件与暂存区比较 123git diff#只查看某个文件git diff -- 文件1 文件2 暂存区与上一次提交(HEAD指向)比较 123git diff --cached#或者，git16.1版本后适用git diff --staged 注意，git diff比较的是工作目录文件的内容和暂存区文件的内容。 忽略文件如日志文件之类的文件，无需纳入git管理。这种情况下，创建一个名为 .gitignore 的文件,列出要忽略的文件模式. 1234# 忽略以.a或.o为结尾的文件*.[oa]# 忽略以～结尾的文件x~ 文件 .gitignore 的格式规范： 所有空行或者以 # 开头的行都会被 Git 忽略。 可以使用标准的 glob 模式匹配。 匹配模式可以以(/)开头防止递归。 匹配模式可以以(/)结尾指定目录。 要忽略指定模式以外的文件或目录,可以在模式前加上惊叹号(!)取反。 glob模式： 星号(*)匹配零个或多个任意字符; [abc] 匹配任何一个列在方括号中的字符(这个例子要么匹配一个 a,要么匹配一个 b,要么匹配一个 c); 问号(?)只匹配一个任意字符; 如果在方括号中使用短划线分隔两个字符,表示所有在这两个字符范围内的都可以匹配(比如 [0-9] 表示匹配所有 0 到 9 的数字)。 使用两个星号(*) 表示匹配任意中间目录,比如a/**/z 可以匹配 a/z, a/b/z 或 a/b/c/z等。 官方针对各种语言的忽略文件 提交更新所谓的提交，实际上相当于本地的保存记录。在提交更新前，最好先运行一下 git status命令，查看是不是还有没暂存的文件 1git status 提交命令git commit之后，会启动文本编辑器以便输入本次提交的说明。 1git commit 提交命令，显示修改信息git commit之后，会启动文本编辑器以便输入本次提交的说明。 1git commit -v 将提交信息与命令放在同一行 1git commit -m "提交信息" 自动暂存追踪文件并提交有时候使用暂存区域的方式有些繁琐，使用以下命令， Git 就会自动把所有已经跟踪过的文件暂存起来一并提交,从而跳过 git add 步骤 1git commit -a 移除文件删除跟踪状态，且同时删除工作区的的文件（未暂存）。 1git rm &lt; file-name&gt; 强制删除已暂存的文件 1git rm -f file 删除暂存区中的文件，不删除工作区的文件 1git rm --cached file 删除目录，使用blog模式 1234#删除 log/ 目录下扩展名为 .log 的所有文件(注意"/")git rm log/\*.log#删除以 ~ 结尾的所有文件git rm \*~ 移动文件移动文件 1git mv file path 重命名 12#对文件进行重命名git mv README.md README 实际上相当于运行了 123mv README.md READMEgit rm README.mdgit add README 注意：如果出现了not under version control,只是因为你的文件不是追踪文件而已，执行 git add file就能用了 查看提交历史基本信息：每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明查看提交历史适用命令（显示基本信息）,该命令会按提交时间列出所有的更新,最近的更新排在最上面。 1git log git log 的常用选项 选项 说明 -p 按补丁格式显示每个更新之间的差异。 –stat 显示每次更新的文件修改统计信息。 –shortstat 只显示 –stat 中最后的行数修改添加移除统计。 –name-only 仅在提交信息后显示已修改的文件清单。 –name-status 显示新增、修改、删除的文件清单。 –abbrev-commit 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。 –relative-date 使用较短的相对时间显示（比如，“2 weeks ago”）。 –graph 显示 ASCII 图形表示的分支合并历史。 –pretty 使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。 ​ 如，使用 -p 来显示每次提交的内容差异（基本信息+diff）。 12#显示最近的两次提交的内容差异 git log -p 适用 –stat查看每次提交的简略统计信息（基本信息+简略改动,如插入几行，几个文件修改，删除几行） 1git log --stat 不同格式显示历史 使用不同于默认格式的方式展示提交历史 git log –pretty=[ option ] 12345678910 # oneline显示一行，包含SHA-1校验值和提交说明git log --pretty=oneline# short 包含SHA-1校验值、作者名字和邮件、提交说明git log --pretty=short# full 包含SHA-1校验值、作者名字和邮件、提交说明、提交者名字和邮件git log --pretty=full# fuller 包含SHA-1校验值、作者名字和邮件、提交说明、提交者名字和邮件、提交时间git log --pretty=fuller# format 自定义输出格式git log --pretty=format:"%h - %an, %ar : %s" 自定义输出格式|选项|说明||–|–||%H|提交对象（commit）的完整哈希字串||%h|提交对象的简短哈希字串||%T|树对象（tree）的完整哈希字串||%t|树对象的简短哈希字串||%P|父对象（parent）的完整哈希字串||%p|父对象的简短哈希字串||%an|作者（author）的名字||%ae|作者的电子邮件地址||%ad|作者修订日期（可以用 –date= 选项定制格式）||%ar|作者修订日期，按多久以前的方式显示||%cn|提交者（committer）的名字||%ce|交者的电子邮件地址||%cd|提交日期||%cr|提交日期，按多久以前的方式显示||%s|提交说明| 限制输出长度 选项 说明 -(n) 仅显示最近的 n 条提交 –since, –after 仅显示指定时间之后的提交。 –until, –before 仅显示指定时间之前的提交。 –author 仅显示指定作者相关的提交。 –committer 仅显示指定提交者相关的提交。 –grep 仅显示含指定关键字的提交 -S 仅显示添加或移除了某个关键字的提交 如，列出最佳两周提交 1git log --since=2.weeks 图形化方式查看git提交1234#当前分支gitk #所有分支gitk --all 变更操作重新提交实为再次提交暂存区的文件，并重写覆盖上一次的提交信息(commit对象会变) 1git commit --amend 修改老旧commit如果要更改老旧commit的提交信息，请看变基操作 整合多个commit提交也看变基操作 取消暂存的文件 1234# 取消所有暂存区内容git reset HEAD# 取消指定文件git reset HEAD &lt;file-name&gt; 从暂存区恢复文件 1git checkout -- &lt;file-name&gt; 恢复到某个commit恢复后暂存区、工作区都会变化，然后之后的commit全部丢失，very 恐怖 1git reset --hard hashcode 远程仓库的使用远程仓库是指托管在因特网或其他网络中的你的项目的版本库。 查看远程仓库查看已经配置的远程仓库简写对于使用 git clone过来的仓库，默认名为origin 1git remote 查看已经配置的远程仓库简写与其对应的 URL 1git remote -v 列出远程仓库的 URL 与跟踪分支的信息 1git remote show [remote-name] 添加远程仓库添加远程仓库，同时指定简写 1git remote add &lt;remote-name&gt; &lt;url&gt; 现在，可以用 &lt; remote-name &gt; 来代替整个URL. 从远程仓库抓取拉取远程仓库数据拉取远程仓库中有而本地仓库没有的信息.执行完成后，将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。 12#git fetch &lt;remote-name&gt;git fetch pb 抓取之后，，本地不会自动生成一份可编辑的副本，需要进行合并操作克隆远程仓库对于 git clone命令添加的远程仓库会以 orgin 为简写。它自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支 1git clone [url] 自动的抓取然后合并远程分支到当前分支 1git pull &lt;remote-name&gt; 推送到远程仓库推送到远程仓库 1# git push [remote-name] [branch-name] git push命令生效，还需要两个条件 拥有所克隆服务器的写入权限 之前没有人推送过 如果在推送之前，有人已经推送过。那必须先进行抓取操作，合并后才能推送。 远程仓库的移除与重命名重命名远程仓库修改远程仓库的简写名,同时也会改变远程分支名 1# git remote rename &lt;old-remote-name&gt; &lt;new-remote-name&gt; 移除远程仓库 1# git remote rm &lt;remote-name&gt; 标签Git 使用两种主要类型的标签：轻量标签（lightweight）与附注标签（annotated）。 轻量标签：很像一个不会改变的分支 - 它只是一个特定提交的引用 附注标签：存储在 Git 数据库中的一个完整对象。 它们是可以被校验的；其中包含打标签者的名字、电子邮件地址、日期时间；还有一个标签信息；并且可以使用 GNU Privacy Guard （GPG）签名与验证。 查看标签在git中列出已有标签 1git tag 特定模式列出标签 1# git tag -l '关键字' 查看标签信息与对应的提交信息 1# git show &lt;tag-name&gt; 附注标签创建附注标签 1# git tag -a &lt;tag-name&gt; 创建附注标签并指定存储在标签中的信息 1# git tag -a &lt;tag-name&gt; -m '标签中的信息' 轻量标签创建轻量标签创建轻量标签，只需要提供标签名字 1# git tag &lt;tag-name&gt; 后期打标签后期打标签对过去的提交打标签(在命令的末尾指定提交的校验和（或部分校验和）) 12# git tag -a &lt;tag-name&gt; 校验和,校验和可以通过git log 命令查看git tag -a v1.2 9fceb02 共享标签默认情况下，git push 命令并不会传送标签到远程仓库服务器上显示推送标签 1# git push &lt;remote-name&gt; [tagname] 一次性推送很多标签这将会把所有不在远程仓库服务器上的标签全部传送到那里 1git push origin --tags 检出标签标签并不会像分支一样完全移动，但想要工作目录与仓库中特定的标签版本完全一样，可以在特定的标签上创建一个新分支 1#git checkout -b [branchname] [tagname] 不过当该分支提交后，标签和分支又会稍微有些不一样了 Git 别名通过 git config 文件来轻松地为每一个命令设置一个别名 1234# git config --global alias.co checkout# git config --global alias.br branch# git config --global alias.ci commit# git config --global alias.st status 如，想要输入 git commit 时，只需要输入 git ci又如 12# 向 Git 中添加取消暂存别名git config --global alias.unstage 'reset HEAD --' 下面两个命令等价 12git unstage fileAgit reset HEAD -- fileA 想要执行外部命令，而不是一个 Git 子命令。 如果是那样的话，可以在命令前面加入 ! 符号 1git config --global alias.visual '!gitk' Git 分支分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线 Git数据保存的方式在进行提交操作时，Git 会保存一个提交对象（commit object）。且该提交对象会保存 包含一个指向暂存内容快照的指针 包含了作者的姓名和邮箱、提交时输入的信息 指向它的父对象的指针 一个保存校验和的树对象的指针 从下图（3个文件的提交）可以看出，对于一个提交对象，里面保存了一个tree的指针,而tree中有保存了文件的校验和 而对于每一个的提交，除第一次外都有指向父对象的指针 创建分支master分支Git 的默认分支（注意：Git 的 “master” 分支并不是一个特殊分支。 它就跟其它分支完全没有区别，只是默认创建了这个分支而已）创建分支 ： git branch &lt; branch-name &gt; 12#创建了testing分支git branch testing 创建一个分支(实际上只是在当前所在的提交对象上创建一个指针)，相当于如图所示 特殊指针HEAD作用：指向当前所在的本地分支，即Git用它来确定当前所在的分支。 分支切换切换分支其实相当于改变HEAD的指针，同时会改变你工作目录中的文件 切换到分支 1git checkout &lt; branch-name &gt; 新建分支同时切换到该分支： 123git checkout -b testing# 基于远程分支建立新分支git checkout -b &lt;branch-name&gt; &lt;remote-branch-name&gt; 相当于执行了如下两条命令 12git branch testinggit checkout testing 查看分支查看各个分支所指的提交对象提供该功能的选项是 –decorate 1git log --oneline --decorate 查看项目分叉历史 1git log --oneline --decorate --graph --all 查看当前所有分支 12#输出结果前*表示当前所在分支git branch 要查看每一个分支的最后一次提交 1234# 查看当前分支的最后一次提交git branch -v# 查看所有分支的最后一次提交git branch -av 查看哪些分支已经合并/未合并到当前分支 1234#合并的分支git branch --merged#未合并的分支git branch --no-merged 比较两个分支不同 1234# 比较两个不同分支的所有文件git diff &lt; branch1&gt; &lt;branch2&gt;# 比较两个不同分支指定文件git diff &lt; branch1&gt; &lt;branch2&gt; -- &lt; file-name &gt; 合并分支合并分支 : git merge &lt; branch-name &gt; 1git merge hotfix 合并冲突遇到冲突时的分支合并在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，需要手动去处理冲突。 解决内容冲突 12345678# 先将远程分支的拉下来合并,合并过程会告知你那个文件合并必败git pull # 修改该文件,该文件内容可以看到冲突的地方vim README# 修改完后再次提交git commit -am'解决冲突'# 再pushgit push 同时修改文件名和文件内容一方变更了文件名另一方变更了文件内容无需解决，git会自动改文件名和文件内容 解决文件名冲突 拉下来后,工作区改名后的两个文件都存在 解决： 12345678# 先删除暂存区的原文件git rm index.html# 把想要保留的加入到暂存区git add index1.html# 删除另一个git rm index2.html# 提交git commit -am"修改冲突" 使用 git status查看那些因包含合并冲突而处于未合并（unmerged）状态的文件 解决了所有文件里的冲突之后，对每个文件使用 git add 命令来将其标记为冲突已解决 使用图形化工具解决冲突运行图形化工具 1git mergetoo 删除分支删除分支 ： git branch -d &lt; branch-name &gt; 1git branch -d hotfix 该命令无法删除当前分支未合并的分支，如果一定要删除，需要适用强制删除 强制删除 1git branch -D &lt; branch-name &gt; 远程分支远程引用的完整列表 : git ls-remote &lt; remote-name &gt; 1git ls-remote htofix 获得远程分支信息 : git remote show &lt; remote-name &gt; 1git remote show origin 远程跟踪分支 远程分支状态的引用，上次连接到远程仓库时，那些分支所处状态的书签. 以 (remote)/(branch) 形式命名 无法移动的本地引用，当你做任何网络通信操作时，它们会自动移动 其实就相当于一个记录远程仓库分支位置的书签 跟踪分支 从一个远程跟踪分支检出一个本地分支会自动创建一个叫做 “跟踪分支”（有时候也叫做 “上游分支”）。 跟踪分支是与远程分支有直接关系的本地分支。 如果在一个跟踪分支上输入 git pull，Git 能自动地识别去哪个服务器上抓取、合并到哪个分支。 变基1git rebase -i 提交的hashcode 在编辑之后，会弹出一个文本,里面告诉你该如何用命令 123456789101112131415161718pick 5e358bb [添加]添加了MyBaits相关笔记pick 9c77fd9 [.]# Commands:# p, pick &lt;commit&gt; = use commit# r, reword &lt;commit&gt; = use commit, but edit the commit message# e, edit &lt;commit&gt; = use commit, but stop for amending# s, squash &lt;commit&gt; = use commit, but meld into previous commit# f, fixup &lt;commit&gt; = like "squash", but discard this commit's log message# x, exec &lt;command&gt; = run command (the rest of the line) using shell# b, break = stop here (continue rebase later with 'git rebase --continue')# d, drop &lt;commit&gt; = remove commit# l, label &lt;label&gt; = label current HEAD with a name# t, reset &lt;label&gt; = reset HEAD to a label# m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]# . create a merge commit using the original merge commit's# . message (or the oneline, if no original merge commit was# . specified). Use -c &lt;commit&gt; to reword the commit message. 想要修改提交信息，就使用r这个命令 1234pick 5e358bb [添加]添加了MyBaits相关笔记pick 9c77fd9 [.]# 修改5e358bb的提交信息r 5e358bb [添加]添加了MyBaits相关笔记 想要合成多个commit，则要使用s命令 1234567891011pick 5e358bb [添加]添加了MyBaits相关笔记pick 9c77fd9 [.]pick 7gsdh96 [sd]pick asdas323 [sd]pcik asdsad [22]# 合并前4个，则pick 5e358bb [添加]添加了MyBaits相关笔记s 9c77fd9 [.]s 7gsdh96 [sd]s asdas323 [sd]pcik asdsad [22] 所有的变基操作，在变基的位置开始，所有的commit对象都改变了其地址。所以，当项目已经push上了，千万别用，在本地用用就可以了。 服务器上的Git裸仓库（bare repository）即为一个没有当前工作目录的仓库。 因为该仓库仅仅作为合作媒介，不需要从磁碟检查快照；存放的只有 Git 的资料协议Git 可以使用四种主要的协议来传输资料：本地协议（Local），HTTP 协议，SSH（Secure Shell）协议及 Git 协议。 本地协议其中的远程版本库就是硬盘内的另一个目录,常见于团队每一个成员都对一个共享的文件系统（例如一个挂载的 NFS）拥有访问权，或者比较少见的多人共用同一台电脑的情况。克隆一个本地版本库 123git clone /opt/git/project.git# 或者,file://传输效率较低git clone file:///opt/git/project.git 增加一个本地版本库到现有的 Git 项目 1git remote add local_proj /opt/git/project.git HTTP 协议Git 通过 HTTP 通信有两种模式:“智能” HTTP 协议和“哑” HTTP 协议智能（Smart） HTTP 协议运行在标准的 HTTP/S 端口上并且可以使用各种 HTTP 验证机制哑（Dumb） HTTP 协议web 服务器仅把裸版本库当作普通文件来对待，提供文件服务。 哑 HTTP 协议的优美之处在于设置起来简单。 基本上，只需要把一个裸版本库放在 HTTP 根目录，设置一个叫做 post-update 的挂钩就可以了 12345cd /var/www/htdocs/git clone --bare /path/to/git_project gitproject.gitcd gitproject.gitmv hooks/post-update.sample hooks/post-updatechmod a+x hooks/post-update SSH 协议用 SSH 协议作为传输协议通过 SSH 协议克隆版本库，你可以指定一个 ssh:// 的 URL： 1git clone ssh://user@server/project.git 或者使用一个简短的 scp 式的写法： 1git clone user@server:project.git Git 协议包含在 Git 里的一个特殊的守护进程；它监听在一个特定的端口（9418），类似于 SSH 服务，但是访问无需任何授权要让版本库支持 Git 协议，需要先创建一个 git-daemon-export-ok 文件 在服务器上搭建 Git在开始架设 Git 服务器前，需要把现有仓库导出为裸仓库 1$ git clone --bare my_project my_project.git 把裸仓库放到服务器上并设置协议 1scp -r my_project.git user@git.example.com:/opt/git 生成SSH公钥查看是否有密钥执行以下命令查看是否拥有 12cd ~/.sshls 如果没有这个目录,或者有目录，但没有id_dsa和id_rsa文件，说明你没有公钥。 创建 123ssh-keygen# 官方给的设置方式，管理email ssh-keygen -t rsa -b 4096 -C "xx.@xx.com" (创建过程中会让你输入密钥口令，可以直接按空格不输入)现在，在目录下，起码有两个文件存在了 12-rw------- 1 famel famel 1675 12月 17 11:48 id_rsa-rw-r--r-- 1 famel famel 409 12月 17 11:48 id_rsa.pub 以 .pub 为扩展名则为公钥，另一个则为私钥。(github上输入公钥) 紧急任务加塞当在开发过程中，需要处理其他紧急任务，可使用 1git stash 这样将当前状态保存到一个堆栈中,查看堆栈如下 12git stash list# 显示stash@&#123;2&#125;: WIP on master: 0cb0a4b [修改] 任务完成后，可以使用如下命令继续刚才停止的任务 123456# 弹出最顶的stash，但不删除git stash apply# 弹出最顶的stash，但删除git stash pop# 弹出制定的某个栈值，上面两个相当于stash@&#123;0&#125;git stash apply/pop stash@&#123;n&#125; git备份常用协议： 哑协议 /path/to/repo.git(传输进度不可见) 智能协议 file:///psth/to/repo.git（传输可见，速度比哑协议快） http/https协议 ssh协议 如果是本地仓库的备份 12# 使用--bare不备份工作区，更干净git clone --bare 协议(推荐智能协议) 如果是远程仓库备份 1234# 关联原创仓库git remote add &lt;remote-name&gt; 协议# 然后pushgit push [branch-name] git 18R!(禁止命令)禁止一：强制更新 1234# 如果本地使用了,那么之后的commit就会消失git reset --hard &lt;hashcode&gt;# 如果使用了强制更新，那么远程仓库也会小时一大堆commit！！！git push -f 禁止二：不要对集成分支变基 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455对公共commit改变后，之后历史的commit全部改变。对于其他人可能还需要一个个对新的commit进行merge等操作。|方法| 描述|| static int binarySearch(List list, Objectvalue,Comparator c) 按照c的次序在list中搜寻value。如果value在list内，则返回value在list的位置。如果在list中没有发现value，则返回-1| static int binarySearch(List list, Object value) 在list中搜寻value，列表（list）必须被排序。如果value在list内，则返回value的位置。如果在list中没有发现value，则返回-1| static void copy(List list1, List list2) 将list2中的元素复制给list1| static Enumeration enumeration(Collection c) 返回c的一个枚举（参看本章后面的“枚举接口”）。| static void fill(List list, Object obj) 将obj赋给list中的每一个元素| static Object max(Collection c,Comparator comp) 返回由comp确定的c中的最大元素| static Object max(Collection c) 返回按自然顺序确定的c中的最大元素。类集不必被排序| static Object min(Collection c,Comparator comp) 返回由comp确定的c中的最小元素。类集不必被排序| static Object min(Collection c) 返回按自然顺序确定的c中的最小元素| static List nCopies(int num, Object obj) 返回包含在不可改变的列表中的obj的num个拷贝。num必须大于等于0| static void reverse(List list) 将list中的序列逆向| static Comparator reverseOrder( ) 返回一个逆向比较函数（即将两个元素比较的结果进行逆向的比较函数）| static void shuffle(List list, Random r) 用r作为随机数的源，对list中的元素进行混淆（也即随机化）| static void shuffle(List list) 对list中的元素进行混淆（也即随机化）| static Set singleton(Object obj) 返回一个不可改变的集合obj。这是一个实现将单个对象变成集合的简单办法| static List singletonList(Object obj) 返回一个不可改变的列表obj。这是一个实现将单个对象变成列表的简单办法（在Java 2的1.3版中新增加的）| static Map singletonMap(Object k, Object v) 返回一个不可改变的关键字/值对映射k/v。这是一个实现将单个关键字/值对变成映射的简单办法（在Java2的1.3版中新增加的）| static void sort(List list, Comparator comp) 按comp对list中的元素进行排序| static void sort(List list) 按自然顺序对list中的元素进行排序| static CollectionsynchronizedCollection(Collection c)返回一个被c支持的安全线程类集| static List synchronizedList(List list) 返回一个被list支持的安全线程列表| static Map synchronizedMap(Map m) 返回一个被m支持的安全线程映射| static Set synchronizedSet(Set s) 返回一个被s支持的安全线程集合| static SortedMapsynchronizedSortedMap(SortedMap sm)返回一个被sm支持的安全线程排序集合| static SortedSetsynchronizedSortedSet(SortedSet ss)返回一个被ss支持的安全线程集合| static CollectionunmodifiableCollection(Collection c)返回一个被c支持的不可变类集| static List unmodifiableList(List list) 返回一个被list支持的不可变列表| static Map unmodifiableMap(Map m) 返回一个被m支持的不可变映射| static Set unmodifiableSet(Set s) 返回一个被s支持的不可变集合| static SortedMapunmodifiable SortedMap(SortedMap sm)返回一个被sm支持的不可变排序映射| static SortedSetunmodifiableSortedSet(SortedSet ss)]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[geetest]]></title>
    <url>%2F2019%2F01%2F01%2Fgeetest%2F</url>
    <content type="text"><![CDATA[简述在网站开发中使用频率最高的工具之一便是验证码，验证码在此也是多种多样，不过简单的图片验证码已经可以被机器识别，极验验证码提供了一个安全可靠的滑动验证码体系，让网站开发更加安全。 安装下载SDK 使用命令从Github导入完整项目 1git clone https://github.com/GeeTeam/gt3-dotnet-sdk.git 手动下载压缩包文件 从Github: gt3-python-sdk下载.zip文件 引入SDK使用VS打开项目中SDK的.sln文件即可引入SDK。 在您的项目中使用以下代码即可导入SDK 1using GeetestSDK; 配置密钥，修改请求参数 配置密钥 从极验管理后台获取您的公钥（id）和私钥（key）, 并在代码中配置。配置文件路径如下： 1/demo/GeetestConfig.cs 修改请求参数（可选） 名称 说明 user_id 用户标识，若担心用户信息风险，可作预处理(如哈希处理)再提供 client_type 客户端类型，web（pc浏览器），h5（手机浏览器，包括webview），native（原生app），unknown（未知） ip_address 客户端请求您服务器的ip地址，unknow表示未知 接口示例初始化（API1），获取流水标识并设置状态码）123456789101112131415161718192021namespace demo&#123; public partial class GetCaptcha : System.Web.UI.Page &#123; protected void Page_Load(object sender, EventArgs e) &#123; Response.ContentType = "application/json"; Response.Write(getCaptcha()); Response.End(); &#125; private String getCaptcha() &#123; GeetestLib geetest = new GeetestLib(GeetestConfig.publicKey, GeetestConfig.privateKey); String userID = "test"; Byte gtServerStatus = geetest.preProcess(userID,"web","127.0.0.1"); Session[GeetestLib.gtServerStatusSessionKey] = gtServerStatus; Session["userID"] = userID; return geetest.getResponseStr(); &#125; &#125;&#125; 注意：初始化结果标识status（status=1表示初始化成功，status=0表示宕机状态）需要用户保存，在后续二次验证时会取出并进行逻辑判断。本SDK demo中使用session来存取status。 二次验证（API2），包括正常流程和宕机情况12345678910111213141516171819202122232425262728namespace demo&#123; public partial class Validate : System.Web.UI.Page &#123; protected void Page_Load(object sender, EventArgs e) &#123; &#125; protected void submitBtn_Click(object sender, EventArgs e) &#123; GeetestLib geetest = new GeetestLib(GeetestConfig.publicKey, GeetestConfig.privateKey); Byte gt_server_status_code = (Byte) Session[GeetestLib.gtServerStatusSessionKey]; String userID = (String) Session["userID"]; int result = 0; String challenge = Request.Form.Get(GeetestLib.fnGeetestChallenge); String validate = Request.Form.Get(GeetestLib.fnGeetestValidate); String seccode = Request.Form.Get(GeetestLib.fnGeetestSeccode); if (gt_server_status_code == 1) result = geetest.enhencedValidateRequest(challenge, validate, seccode, userID); else result = geetest.failbackValidateRequest(challenge, validate, seccode); if (result == 1) Response.Write("&lt;div id='sb'&gt;success&lt;/div&gt;"); else Response.Write(" "); &#125; &#125;&#125; 注意：当取出status=0时表示极验宕机，此时流程进入failback模式，后续逻辑都是在您的服务器完成，不会再向极验服务器发送网络请求。本SDK demo中，对于failback模式，只对请求参数做了简单的校验，您也可以自行设计。 自己写的例子前端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link rel="stylesheet" href="/static/css/bootstrap.css"&gt; &lt;link rel="stylesheet" href="/static/css/mystyle.css"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="container"&gt; &lt;div class="row"&gt; &lt;form class="form-horizontal col-md-6 col-md-offset-3 login-form"&gt; &#123;% csrf_token %&#125; &lt;div class="form-group"&gt; &lt;label for="username" class="col-sm-2 control-label"&gt;用户名&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;input type="text" class="form-control" id="username" name="username" placeholder="用户名"&gt; &lt;span id="user"&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="password" class="col-sm-2 control-label"&gt;密码&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;input type="password" class="form-control" id="password" name="password" placeholder="密码"&gt; &lt;span id="pwd"&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="password" class="col-sm-2 control-label"&gt;性别&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;select class="form-control" name="sex" id="sex"&gt; &lt;option value="男"&gt;男&lt;/option&gt; &lt;option value="女"&gt;女&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;!-- 放置极验的滑动验证码 --&gt; &lt;div id="popup-captcha"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;div class="col-sm-offset-2 col-sm-10"&gt; &lt;button type="button" class="btn btn-default" id="login-button"&gt;登录&lt;/button&gt; &lt;span class="login-error"&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/div&gt;&lt;script src="/static/js/bootstrap.js" type="text/javascript"&gt;&lt;/script&gt;&lt;script src="/static/js/jquery-3.3.1.min.js"&gt;&lt;/script&gt;#引用人家的js &lt;script src="http://static.geetest.com/static/tools/gt.js"&gt;&lt;/script&gt;&lt;script&gt; // 极验 发送登录数据的 var handlerPopup = function (captchaObj) &#123; // 成功的回调 captchaObj.onSuccess(function () &#123; var validate = captchaObj.getValidate(); // 1. 取到用户填写的用户名和密码 -&gt; 取input框的值 var username = $("#username").val(); var password = $("#password").val(); var sex = $('#sex').val(); $.ajax(&#123; url: "/login/", // 进行二次验证 type: "post", dataType: "json", data: &#123; username: username, password: password, sex: sex, csrfmiddlewaretoken: $("[name='csrfmiddlewaretoken']").val(), geetest_challenge: validate.geetest_challenge, geetest_validate: validate.geetest_validate, geetest_seccode: validate.geetest_seccode &#125;, success: function (data) &#123; console.log(data); if (data.status) &#123; // 有错误，在页面上提示 $(".login-error").text(data.msg); $.each(data.obj,function(index,value)&#123; console.log(index,value); var tag = document.createElement('span'); tag.innerHTML = value[0]; tag.className = 'c1'; tag.style.color = 'red'; $('.row').find('input[name="'+ index +'"]').after(tag); &#125;) &#125; else &#123; // 登陆成功 location.href = data.msg; &#125; &#125; &#125;); &#125;); $("#login-button").click(function () &#123; captchaObj.show(); $('.c1').remove() &#125;); // 将验证码加到id为captcha的元素里 captchaObj.appendTo("#popup-captcha"); // 更多接口参考：http://www.geetest.com/install/sections/idx-client-sdk.html &#125;; // 当input框获取焦点时将之前的错误清空 $("#username,#password").focus(function () &#123; // 将之前的错误清空 $(".login-error").text(""); &#125;); // 验证开始需要向网站主后台获取id，challenge，success（是否启用failback） $.ajax(&#123; url: "/pc-geetest/register?t=" + (new Date()).getTime(), // 加随机数防止缓存 type: "get", dataType: "json", success: function (data) &#123; // 使用initGeetest接口 // 参数1：配置参数 // 参数2：回调，回调的第一个参数验证码对象，之后可以使用它做appendTo之类的事件 initGeetest(&#123; gt: data.gt, challenge: data.challenge, product: "popup", // 产品形式，包括：float，embed，popup。注意只对PC版验证码有效 offline: !data.success // 表示用户后台检测极验服务器是否宕机，一般不需要关注 // 更多配置参数请参见：http://www.geetest.com/install/sections/idx-client-sdk.html#config &#125;, handlerPopup); &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 后端1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071from django.shortcuts import render,HttpResponse,redirectfrom webapp01 import modelsfrom django.forms import Formfrom django.forms import fieldsfrom django.http import JsonResponsefrom geetest import GeetestLibclass MyForm(Form): username = fields.CharField(required=True, error_messages=&#123; 'required': '用户名不能为空' &#125;) password = fields.CharField(required=True, error_messages=&#123; 'required': '密码不能为空' &#125;)def login(request): if request.method == 'POST': ret = &#123;"status": 0, "msg": "", "obj": ""&#125; username = request.POST.get('username') password = request.POST.get('password') sex = request.POST.get('sex') # 获取极验 滑动验证码相关的参数 gt = GeetestLib(pc_geetest_id, pc_geetest_key) challenge = request.POST.get(gt.FN_CHALLENGE, '') validate = request.POST.get(gt.FN_VALIDATE, '') seccode = request.POST.get(gt.FN_SECCODE, '') status = request.session[gt.GT_STATUS_SESSION_KEY] user_id = request.session["user_id"] obj = MyForm(request.POST) if status: result = gt.success_validate(challenge, validate, seccode, user_id) else: result = gt.failback_validate(challenge, validate, seccode) if result: if obj.is_valid(): if sex == '男': obj = models.Man.objects.filter(username=username, password=password).first() else: obj = models.Woman.objects.filter(username=username, password=password).first() if not obj: # 用户名密码错误 ret["status"] = 1 ret["msg"] = "用户名或密码错误！" else: request.session['username'] = obj.username request.session['password'] = obj.password request.session['sex'] = obj.sex ret["msg"] = "/index/" else: ret["status"] = 1 ret["obj"] = obj.errors else: ret["status"] = 1 ret["msg"] = "验证码错误" return JsonResponse(ret) return render(request, 'login.html')pc_geetest_id = "b46d1900d0a894591916ea94ea91bd2c"pc_geetest_key = "36fc3fe98530eea08dfc6ce76e3d24c4"#处理极验 获取验证码的视图def get_geetest(request): user_id = 'test' gt = GeetestLib(pc_geetest_id, pc_geetest_key) status = gt.pre_process(user_id) request.session[gt.GT_STATUS_SESSION_KEY] = status request.session["user_id"] = user_id response_str = gt.get_response_str() return HttpResponse(response_str)]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>geetest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python中的单例模式的几种实现方式的及优化]]></title>
    <url>%2F2018%2F12%2F30%2FPython%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8F%8A%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[单例模式单例模式（Singleton Pattern）是一种常用的软件设计模式，该模式的主要目的是确保某一个类只有一个实例存在。当你希望在整个系统中，某个类只能出现一个实例时，单例对象就能派上用场。 比如，某个服务器程序的配置信息存放在一个文件中，客户端通过一个 AppConfig 的类来读取配置文件的信息。如果在程序运行期间，有很多地方都需要使用配置文件的内容，也就是说，很多地方都需要创建 AppConfig 对象的实例，这就导致系统中存在多个 AppConfig 的实例对象，而这样会严重浪费内存资源，尤其是在配置文件内容很多的情况下。事实上，类似 AppConfig 这样的类，我们希望在程序运行期间只存在一个实例对象。 在 Python 中，我们可以用多种方法来实现单例模式 实现单例模式的几种方式1.使用模块其实，Python 的模块就是天然的单例模式，因为模块在第一次导入时，会生成 .pyc 文件，当第二次导入时，就会直接加载 .pyc 文件，而不会再次执行模块代码。因此，我们只需把相关的函数和数据定义在一个模块中，就可以获得一个单例对象了。如果我们真的想要一个单例类，可以考虑这样做： mysingleton.py 1234class Singleton(object): def foo(self): passsingleton = Singleton() 将上面的代码保存在文件 mysingleton.py 中，要使用时，直接在其他文件中导入此文件中的对象，这个对象即是单例模式的对象 1from a import singleton 2.使用装饰器12345678910111213def singleton(cls): instances = &#123;&#125; def wrapper(*args, **kwargs): if cls not in instances: instances[cls] = cls(*args, **kwargs) return instances[cls] return wrapper@singletonclass Foo(object): passfoo1 = Foo()foo2 = Foo()print foo1 is foo2 #True 3.基于__new__方法实现（推荐使用，方便）通过上面例子，我们可以知道，当我们实现单例时，为了保证线程安全需要在内部加入锁 我们知道，当我们实例化一个对象时，是先执行了类的__new__方法（我们没写时，默认调用object.__new__），实例化对象；然后再执行类的__init__方法，对这个对象进行初始化，所有我们可以基于这个，实现单例模式 12345678910111213class Singleton(object): def __new__(cls,*args,**kwargs): if not hasattr(cls,'_instance'): cls._instance = super(Singleton,cls).__new__(cls,*args,**kwargs) return cls._instance class Foo(Singleton): passfoo1 = Foo()foo2 = Foo()print foo1 is foo2 #True 4.基于metaclass方式实现相关知识1234"""1.类由type创建，创建类时，type的__init__方法自动执行，类() 执行type的 __call__方法(类的__new__方法,类的__init__方法)2.对象由类创建，创建对象时，类的__init__方法自动执行，对象()执行类的 __call__ 方法""" 例子： 1234567891011class Foo: def __init__(self): pass def __call__(self, *args, **kwargs): passobj = Foo()# 执行type的 __call__ 方法，调用 Foo类（是type的对象）的 __new__方法，用于创建对象，然后调用 Foo类（是type的对象）的 __init__方法，用于对对象初始化。obj() # 执行Foo的 __call__ 方法 元类的使用 1234567891011121314151617class SingletonType(type): def __init__(self,*args,**kwargs): super(SingletonType,self).__init__(*args,**kwargs) def __call__(cls, *args, **kwargs): # 这里的cls，即Foo类 print('cls',cls) obj = cls.__new__(cls,*args, **kwargs) cls.__init__(obj,*args, **kwargs) # Foo.__init__(obj) return objclass Foo(metaclass=SingletonType): # 指定创建Foo的type为SingletonType def __init__(self，name): self.name = name def __new__(cls, *args, **kwargs): return object.__new__(cls)obj = Foo('xx') 实现单例模式12345678910111213141516171819import threadingclass SingletonType(type): _instance_lock = threading.Lock() def __call__(cls, *args, **kwargs): if not hasattr(cls, "_instance"): with SingletonType._instance_lock: if not hasattr(cls, "_instance"): cls._instance = super(SingletonType,cls).__call__(*args, **kwargs) return cls._instanceclass Foo(metaclass=SingletonType): def __init__(self,name): self.name = nameobj1 = Foo('name')obj2 = Foo('name')print(obj1,obj2)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AJAX]]></title>
    <url>%2F2018%2F12%2F29%2FAJAX%2F</url>
    <content type="text"><![CDATA[概述对于WEB应用程序：用户浏览器发送请求，服务器接收并处理请求，然后返回结果，往往返回就是字符串（HTML），浏览器将字符串（HTML）渲染并显示浏览器上。 1、传统的Web应用 1一个简单操作需要重新加载全局数据 2、AJAX 1234567891011AJAX，Asynchronous JavaScript and XML (异步的JavaScript和XML)，一种创建交互式网页应用的网页开发技术方案。异步的JavaScript：使用 【JavaScript语言】 以及 相关【浏览器提供类库】 的功能向服务端发送请求，当服务端处理完请求之后，【自动执行某个JavaScript的回调函数】。PS：以上请求和响应的整个过程是【偷偷】进行的，页面上无任何感知。XMLXML是一种标记语言，是Ajax在和后台交互时传输数据的格式之一利用AJAX可以做：1、注册时，输入用户名自动检测用户是否已经存在。2、登陆时，提示用户名密码错误3、删除数据行时，将行ID发送到后台，后台在数据库中删除，数据库删除成功后，在页面DOM中将数据行也删除。（博客园） “伪”AJAX由于HTML标签的iframe标签具有局部加载内容的特性，所以可以使用其来伪造Ajax请求。 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;p&gt;请输入要加载的地址：&lt;span id="currentTime"&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt; &lt;input id="url" type="text" /&gt; &lt;input type="button" value="刷新" onclick="LoadPage();"&gt; &lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;h3&gt;加载页面位置：&lt;/h3&gt; &lt;iframe id="iframePosition" style="width: 100%;height: 500px;"&gt;&lt;/iframe&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; window.onload= function()&#123; var myDate = new Date(); document.getElementById('currentTime').innerText = myDate.getTime(); &#125;; function LoadPage()&#123; var targetUrl = document.getElementById('url').value; document.getElementById("iframePosition").src = targetUrl; &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 原生AJAXAjax主要就是使用 【XmlHttpRequest】对象来完成请求的操作，该对象在主流浏览器中均存在(除早起的IE)，Ajax首次出现IE5.5中存在（ActiveX控件）。 1、XmlHttpRequest对象介绍XmlHttpRequest对象的主要方法： 123456789101112131415161718192021222324252627282930313233343536373839a. void open(String method,String url,Boolen async) 用于创建请求 参数： method： 请求方式（字符串类型），如：POST、GET、DELETE... url： 要请求的地址（字符串类型） async： 是否异步（布尔类型） b. void send(String body) 用于发送请求 参数： body： 要发送的数据（字符串类型） c. void setRequestHeader(String header,String value) 用于设置请求头 参数： header： 请求头的key（字符串类型） vlaue： 请求头的value（字符串类型） d. String getAllResponseHeaders() 获取所有响应头 返回值： 响应头数据（字符串类型） e. String getResponseHeader(String header) 获取响应头中指定header的值 参数： header： 响应头的key（字符串类型） 返回值： 响应头中指定的header对应的值 f. void abort() 终止请求 XmlHttpRequest对象的主要属性： 123456789101112131415161718192021222324a. Number readyState 状态值（整数） 详细： 0-未初始化，尚未调用open()方法； 1-启动，调用了open()方法，未调用send()方法； 2-发送，已经调用了send()方法，未接收到响应； 3-接收，已经接收到部分响应数据； 4-完成，已经接收到全部响应数据； b. Function onreadystatechange 当readyState的值改变时自动触发执行其对应的函数（回调函数） c. String responseText 服务器返回的数据（字符串类型） d. XmlDocument responseXML 服务器返回的数据（Xml对象） e. Number states 状态码（整数），如：200、404... f. String statesText 状态文本（字符串），如：OK、NotFound... 2、跨浏览器支持 XmlHttpRequestIE7+, Firefox, Chrome, Opera, etc. ActiveXObject(“Microsoft.XMLHTTP”)IE6, IE5 基于原生AJAX - Demo 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;XMLHttpRequest - Ajax请求&lt;/h1&gt; &lt;input type="button" onclick="XmlGetRequest();" value="Get发送请求" /&gt; &lt;input type="button" onclick="XmlPostRequest();" value="Post发送请求" /&gt; &lt;script src="/statics/jquery-1.12.4.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; function GetXHR()&#123; var xhr = null; if(XMLHttpRequest)&#123; xhr = new XMLHttpRequest(); &#125;else&#123; xhr = new ActiveXObject("Microsoft.XMLHTTP"); &#125; return xhr; &#125; function XhrPostRequest()&#123; var xhr = GetXHR(); // 定义回调函数 xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4)&#123; // 已经接收到全部响应数据，执行以下操作 var data = xhr.responseText; console.log(data); &#125; &#125;; // 指定连接方式和地址----文件方式 xhr.open('POST', "/test/", true); // 设置请求头 xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded; charset-UTF-8'); // 发送请求 xhr.send('n1=1;n2=2;'); &#125; function XhrGetRequest()&#123; var xhr = GetXHR(); // 定义回调函数 xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4)&#123; // 已经接收到全部响应数据，执行以下操作 var data = xhr.responseText; console.log(data); &#125; &#125;; // 指定连接方式和地址----文件方式 xhr.open('get', "/test/", true); // 发送请求 xhr.send(); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; jQuery AjaxjQuery其实就是一个JavaScript的类库，其将复杂的功能做了上层封装，使得开发者可以在其基础上写更少的代码实现更多的功能。 jQuery 不是生产者，而是大自然搬运工。 jQuery Ajax本质 XMLHttpRequest 或 ActiveXObject 注：2.+版本不再支持IE9以下的浏览器 jQuery Ajax 方法列表 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677jQuery.get(...) 所有参数： url: 待载入页面的URL地址 data: 待发送 Key/value 参数。 success: 载入成功时回调函数。 dataType: 返回内容格式，xml, json, script, text, html jQuery.post(...) 所有参数： url: 待载入页面的URL地址 data: 待发送 Key/value 参数 success: 载入成功时回调函数 dataType: 返回内容格式，xml, json, script, text, html jQuery.getJSON(...) 所有参数： url: 待载入页面的URL地址 data: 待发送 Key/value 参数。 success: 载入成功时回调函数。 jQuery.getScript(...) 所有参数： url: 待载入页面的URL地址 data: 待发送 Key/value 参数。 success: 载入成功时回调函数。 jQuery.ajax(...) 部分参数： url：请求地址 type：请求方式，GET、POST（1.9.0之后用method） headers：请求头 data：要发送的数据 contentType：即将发送信息至服务器的内容编码类型(默认: "application/x-www-form-urlencoded; charset=UTF-8") async：是否异步 timeout：设置请求超时时间（毫秒） beforeSend：发送请求前执行的函数(全局) complete：完成之后执行的回调函数(全局) success：成功之后执行的回调函数(全局) error：失败之后执行的回调函数(全局) accepts：通过请求头发送给服务器，告诉服务器当前客户端课接受的数据类型 dataType：将服务器端返回的数据转换成指定类型 "xml": 将服务器端返回的内容转换成xml格式 "text": 将服务器端返回的内容转换成普通文本格式 "html": 将服务器端返回的内容转换成普通文本格式，在插入DOM中时，如果包含JavaScript标签，则会尝试去执行。 "script": 尝试将返回值当作JavaScript去执行，然后再将服务器端返回的内容转换成普通文本格式 "json": 将服务器端返回的内容转换成相应的JavaScript对象 "jsonp": JSONP 格式 使用 JSONP 形式调用函数时，如 "myurl?callback=?" jQuery 将自动替换 ? 为正确的函数名，以执行回调函数 如果不指定，jQuery 将自动根据HTTP包MIME信息返回相应类型(an XML MIME type will yield XML, in 1.4 JSON will yield a JavaScript object, in 1.4 script will execute the script, and anything else will be returned as a string converters： 转换器，将服务器端的内容根据指定的dataType转换类型，并传值给success回调函数 $.ajax(&#123; accepts: &#123; mycustomtype: 'application/x-some-custom-type' &#125;, // Expect a `mycustomtype` back from server dataType: 'mycustomtype' // Instructions for how to deserialize a `mycustomtype` converters: &#123; 'text mycustomtype': function(result) &#123; // Do Stuff return newresult; &#125; &#125;, &#125;); 基于jQueryAjax - Demo 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt; &lt;input type="button" onclick="XmlSendRequest();" value='Ajax请求' /&gt; &lt;/p&gt; &lt;script type="text/javascript" src="jquery-1.12.4.js"&gt;&lt;/script&gt; &lt;script&gt; function JqSendRequest()&#123; $.ajax(&#123; url: "http://c2.com:8000/test/", type: 'GET', dataType: 'text', success: function(data, statusText, xmlHttpRequest)&#123; console.log(data); &#125; &#125;) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 跨域AJAX由于浏览器存在同源策略机制，同源策略阻止从一个源加载的文档或脚本获取或设置另一个源加载的文档的属性。 特别的：由于同源策略是浏览器的限制，所以请求的发送和响应是可以进行，只不过浏览器不接受罢了。 浏览器同源策略并不是对所有的请求均制约： 制约： XmlHttpRequest 不叼： img、iframe、script等具有src属性的标签 跨域，跨域名访问，如：http://www.c1.com 域名向 http://www.c2.com域名发送请求。 1、JSONP实现跨域请求JSONP（JSONP - JSON with Padding是JSON的一种“使用模式”)，利用script标签的src属性（浏览器允许script标签跨域） 基于JSONP实现跨域Ajax - Demo 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt; &lt;input type="button" onclick="Jsonp1();" value='提交'/&gt; &lt;/p&gt; &lt;p&gt; &lt;input type="button" onclick="Jsonp2();" value='提交'/&gt; &lt;/p&gt; &lt;script type="text/javascript" src="jquery-1.12.4.js"&gt;&lt;/script&gt; &lt;script&gt; function Jsonp1()&#123; var tag = document.createElement('script'); tag.src = "http://c2.com:8000/test/"; document.head.appendChild(tag); document.head.removeChild(tag); &#125; function Jsonp2()&#123; $.ajax(&#123; url: "http://c2.com:8000/test/", type: 'GET', dataType: 'JSONP', success: function(data, statusText, xmlHttpRequest)&#123; console.log(data); &#125; &#125;) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2、CORS随着技术的发展，现在的浏览器可以支持主动设置从而允许跨域请求，即：跨域资源共享（CORS，Cross-Origin Resource Sharing），其本质是设置响应头，使得浏览器允许跨域请求。 简单请求 OR 非简单请求 12345678910111213条件： 1、请求方式：HEAD、GET、POST 2、请求头信息： Accept Accept-Language Content-Language Last-Event-ID Content-Type 对应的值是以下三个中的任意一个 application/x-www-form-urlencoded multipart/form-data text/plain 注意：同时满足以上两个条件时，则是简单请求，否则为复杂请求 简单请求和非简单请求的区别？ 12简单请求：一次请求非简单请求：两次请求，在发送数据之前会先发一次请求用于做“预检”，只有“预检”通过后才再发送一次请求用于数据传输。 关于“预检” 1234567- 请求方式：OPTIONS- “预检”其实做检查，检查如果通过则允许传输数据，检查不通过则不再发送真正想要发送的消息- 如何“预检” =&gt; 如果复杂请求是PUT等请求，则服务端需要设置允许某请求，否则“预检”不通过 Access-Control-Request-Method =&gt; 如果复杂请求设置了请求头，则服务端需要设置允许某请求头，否则“预检”不通过 Access-Control-Request-Headers 基于cors实现AJAX请求: a、支持跨域，简单请求服务器设置响应头：Access-Control-Allow-Origin = ‘域名’ 或 ‘*’ HTML 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt; &lt;input type="submit" onclick="XmlSendRequest();" /&gt; &lt;/p&gt; &lt;p&gt; &lt;input type="submit" onclick="JqSendRequest();" /&gt; &lt;/p&gt; &lt;script type="text/javascript" src="jquery-1.12.4.js"&gt;&lt;/script&gt; &lt;script&gt; function XmlSendRequest()&#123; var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4) &#123; var result = xhr.responseText; console.log(result); &#125; &#125;; xhr.open('GET', "http://c2.com:8000/test/", true); xhr.send(); &#125; function JqSendRequest()&#123; $.ajax(&#123; url: "http://c2.com:8000/test/", type: 'GET', dataType: 'text', success: function(data, statusText, xmlHttpRequest)&#123; console.log(data); &#125; &#125;) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Tornado 1234class MainHandler(tornado.web.RequestHandler): def get(self): self.set_header('Access-Control-Allow-Origin', "http://www.xxx.com") self.write('&#123;"status": true, "data": "seven"&#125;') b、支持跨域，复杂请求由于复杂请求时，首先会发送“预检”请求，如果“预检”成功，则发送真实数据。 “预检”请求时，允许请求方式则需服务器设置响应头：Access-Control-Request-Method “预检”请求时，允许请求头则需服务器设置响应头：Access-Control-Request-Headers “预检”缓存时间，服务器设置响应头：Access-Control-Max-Age HTML 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt; &lt;input type="submit" onclick="XmlSendRequest();" /&gt; &lt;/p&gt; &lt;p&gt; &lt;input type="submit" onclick="JqSendRequest();" /&gt; &lt;/p&gt; &lt;script type="text/javascript" src="jquery-1.12.4.js"&gt;&lt;/script&gt; &lt;script&gt; function XmlSendRequest()&#123; var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4) &#123; var result = xhr.responseText; console.log(result); &#125; &#125;; xhr.open('PUT', "http://c2.com:8000/test/", true); xhr.setRequestHeader('k1', 'v1'); xhr.send(); &#125; function JqSendRequest()&#123; $.ajax(&#123; url: "http://c2.com:8000/test/", type: 'PUT', dataType: 'text', headers: &#123;'k1': 'v1'&#125;, success: function(data, statusText, xmlHttpRequest)&#123; console.log(data); &#125; &#125;) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Tornado 1234567891011class MainHandler(tornado.web.RequestHandler): def put(self): self.set_header('Access-Control-Allow-Origin', "http://www.xxx.com") self.write('&#123;"status": true, "data": "seven"&#125;') def options(self, *args, **kwargs): self.set_header('Access-Control-Allow-Origin', "http://www.xxx.com") self.set_header('Access-Control-Allow-Headers', "k1,k2") self.set_header('Access-Control-Allow-Methods', "PUT,DELETE") self.set_header('Access-Control-Max-Age', 10) c、跨域获取响应头默认获取到的所有响应头只有基本信息，如果想要获取自定义的响应头，则需要再服务器端设置Access-Control-Expose-Headers。 HTML 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt; &lt;input type="submit" onclick="XmlSendRequest();" /&gt; &lt;/p&gt; &lt;p&gt; &lt;input type="submit" onclick="JqSendRequest();" /&gt; &lt;/p&gt; &lt;script type="text/javascript" src="jquery-1.12.4.js"&gt;&lt;/script&gt; &lt;script&gt; function XmlSendRequest()&#123; var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4) &#123; var result = xhr.responseText; console.log(result); // 获取响应头 console.log(xhr.getAllResponseHeaders()); &#125; &#125;; xhr.open('PUT', "http://c2.com:8000/test/", true); xhr.setRequestHeader('k1', 'v1'); xhr.send(); &#125; function JqSendRequest()&#123; $.ajax(&#123; url: "http://c2.com:8000/test/", type: 'PUT', dataType: 'text', headers: &#123;'k1': 'v1'&#125;, success: function(data, statusText, xmlHttpRequest)&#123; console.log(data); // 获取响应头 console.log(xmlHttpRequest.getAllResponseHeaders()); &#125; &#125;) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Tornado 123456789101112131415161718class MainHandler(tornado.web.RequestHandler): def put(self): self.set_header('Access-Control-Allow-Origin', "http://www.xxx.com") self.set_header('xxoo', "seven") self.set_header('bili', "daobidao") self.set_header('Access-Control-Expose-Headers', "xxoo,bili") self.write('&#123;"status": true, "data": "seven"&#125;') def options(self, *args, **kwargs): self.set_header('Access-Control-Allow-Origin', "http://www.xxx.com") self.set_header('Access-Control-Allow-Headers', "k1,k2") self.set_header('Access-Control-Allow-Methods', "PUT,DELETE") self.set_header('Access-Control-Max-Age', 10) d、跨域传输cookie在跨域请求中，默认情况下，HTTP Authentication信息，Cookie头以及用户的SSL证书无论在预检请求中或是在实际请求都是不会被发送。 如果想要发送： 浏览器端：XMLHttpRequest的withCredentials为true 服务器端：Access-Control-Allow-Credentials为true 注意：服务器端响应的 Access-Control-Allow-Origin 不能是通配符 * HTML 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt; &lt;input type="submit" onclick="XmlSendRequest();" /&gt; &lt;/p&gt; &lt;p&gt; &lt;input type="submit" onclick="JqSendRequest();" /&gt; &lt;/p&gt; &lt;script type="text/javascript" src="jquery-1.12.4.js"&gt;&lt;/script&gt; &lt;script&gt; function XmlSendRequest()&#123; var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4) &#123; var result = xhr.responseText; console.log(result); &#125; &#125;; xhr.withCredentials = true; xhr.open('PUT', "http://c2.com:8000/test/", true); xhr.setRequestHeader('k1', 'v1'); xhr.send(); &#125; function JqSendRequest()&#123; $.ajax(&#123; url: "http://c2.com:8000/test/", type: 'PUT', dataType: 'text', headers: &#123;'k1': 'v1'&#125;, xhrFields:&#123;withCredentials: true&#125;, success: function(data, statusText, xmlHttpRequest)&#123; console.log(data); &#125; &#125;) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Tornado 12345678910111213141516171819class MainHandler(tornado.web.RequestHandler): def put(self): self.set_header('Access-Control-Allow-Origin', "http://www.xxx.com") self.set_header('Access-Control-Allow-Credentials', "true") self.set_header('xxoo', "seven") self.set_header('bili', "daobidao") self.set_header('Access-Control-Expose-Headers', "xxoo,bili") self.set_cookie('kkkkk', 'vvvvv'); self.write('&#123;"status": true, "data": "seven"&#125;') def options(self, *args, **kwargs): self.set_header('Access-Control-Allow-Origin', "http://www.xxx.com") self.set_header('Access-Control-Allow-Headers', "k1,k2") self.set_header('Access-Control-Allow-Methods', "PUT,DELETE") self.set_header('Access-Control-Max-Age', 10)]]></content>
      <categories>
        <category>AJAX</category>
      </categories>
      <tags>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python排序算法]]></title>
    <url>%2F2018%2F12%2F29%2Fpython%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[冒泡排序冒泡排序的思想: 每次比较两个相邻的元素, 如果他们的顺序错误就把他们交换位置 比如有五个数: 12, 35, 99, 18, 76, 从大到小排序, 对相邻的两位进行比较 第一趟: 第一次比较: 35, 12, 99, 18, 76 第二次比较: 35, 99, 12, 18, 76 第三次比较: 35, 99, 18, 12, 76 第四次比较: 35, 99, 18, 76, 12 经过第一趟比较后, 五个数中最小的数已经在最后面了, 接下来只比较前四个数, 依次类推 第二趟99, 35, 76, 18, 12 第三趟99, 76, 35, 18, 12 第四趟99, 76, 35, 18, 12比较完成 冒泡排序原理: 每一趟只能将一个数归位, 如果有n个数进行排序,只需将n-1个数归位, 也就是说要进行n-1趟操作(已经归位的数不用再比较) 时间复杂度：O(n²) 123456def my_sort(num): l = len(num) for i in range(l-1): for j in range(l-1-i): if num[j] &lt; num[j+1]: num[j], num[j+1] = num[j+1], num[j] 快速排序快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists），从数列中挑出一个元素，称为 “基准”（pivot）；重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置 时间复杂度O(nlog₂n) 12345678def quicksort(li): if len(li)&lt;=1: return li op = li[0] left = [x for x in li if x &lt; op] mid = [x for x in li if x == op] right = [x for x in li if x &gt; op] return quicksort(left)+mid+quicksort(right) 插入排序插入排序：选定元素，分别与列表中的元素比较，小的在左边，大的在右边 1.从第一个元素开始，该元素可以认为已经被排序；2.取出下一个元素，在已经排序的元素序列中从后向前扫描；3.如果该元素（已排序）大于新元素，将该元素移到下一位置；4.重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；5.将新元素插入到该位置后； 重复步骤2~5。 123456789def insertsort(li): l = len(li) for i in range(1,l): value = li[i] j = i -1 while j&lt;=0 and value&lt;li[j]: li[j+1] = li[j] j = j-1 li[j+1]=value 选择排序选择排序就是要首先选定一个元素认为为最小的，之后比较其他，如果小于之前的，换更换列表所在位置。 时间复杂度：O(n²) 12345678def changesort(li): leng = len(li) for i in range(leng-1): index =i for j in range(i+1,leng): if li[j] &lt; li[index]: index = j li[index], li[i] = li[i], li[index] 归并排序归并排序：采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并时间复杂度：O(nlog₂n) 归并排序也就是将列表中的元素分成两个长度为n/2的子序列，进行比较，之后合在一起 12345678910111213141516171819def merge_sort(list1):#merge_sort是按照len(list1)//2分开，知道分成两两比较大小 if len(list1)&lt;=1: return list1 mid=len(list1)//2 left=merge_sort(list1[:mid]) right=merge_sort(list1[mid:]) return merge(left,right)def merge(left,right):#mere函数主要是左右两边每次取一个数进行比较，小的加入到result中 result=[] while len(left)and len(right): if left[0]&lt;right[0]: result.append(left.pop(0)) else: result.append(right.pop(0)) if len(left)!=0: result+=left elif len(right)!=0: result+=right return result 堆排序堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。 大顶堆：arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2] 父节点i的左子节点在位置(2i+1); 父节点i的右子节点在位置(2i+2) 小顶堆：arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2] 堆排序： 将无序列表构建最大堆，根节点为最大元素 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。 1234567891011121314151617181920def heap_sort(hlist): def heap_adjust(parent): child = 2 * parent + 1 # left child while child &lt; len(heap): if child + 1 &lt; len(heap): if heap[child + 1] &gt; heap[child]: child += 1 # right child,比较左右结点的大小，选出最大的元素 if heap[parent] &gt;= heap[child]: break heap[parent], heap[child] = heap[child], heap[parent]#把最大的结点与父节点交换 parent, child = child, 2 * child + 1#往二叉树下面走，继续去比较，选出最大放到根节点，知道所有元素比较完退出 heap, hlist = copy.copy(hlist), [] for i in range((len(heap)-2)// 2, -1, -1):#(len(heap)-2)// 2为二叉树层数，k=3,i=3,2,1,0 heap_adjust(i) while len(heap) != 0: heap[0], heap[-1] = heap[-1], heap[0] hlist.insert(0, heap.pop())#第一个替换成heap最后一个 heap_adjust(0) return hlist 时间复杂度O(nlog₂n)，不稳定 希尔排序希尔排序将元素先平分，gap=len(list1)//2,按照gap去比较，一次//2,直到gap为1，例如：gap=4,0-4,1-5,2-6，3-7,4-8,5-9去比较大小，若小于前面的,则交换位置。 时间复杂度：O(n) 123456789def Shell_sort(list1): gap=len(list1) while gap&gt;1: gap=gap//2 #若len(list1)=9,gap=4,3,2,1 for i in range(gap,len(list1)): for j in range(i%gap,i,gap): if list1[i]&lt;list1[j]: list1[j],list1[i]=list1[i],list1[j] print(list1)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django的认证系统]]></title>
    <url>%2F2018%2F12%2F26%2FDjango%E7%9A%84%E8%AE%A4%E8%AF%81%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[Django自带的用户认证我们在开发一个网站的时候，无可避免的需要设计实现网站的用户系统。此时我们需要实现包括用户注册、用户登录、用户认证、注销、修改密码等功能，这还真是个麻烦的事情呢。 Django作为一个完美主义者的终极框架，当然也会想到用户的这些痛点。它内置了强大的用户认证系统–auth，它默认使用 auth_user 表来存储用户数据。 auth模块1from django.contrib import auth auth中提供了许多实用方法： authenticate()提供了用户认证功能，即验证用户名以及密码是否正确，一般需要username 、password两个关键字参数。 如果认证成功（用户名和密码正确有效），便会返回一个 User 对象。 authenticate()会在该 User 对象上设置一个属性来标识后端已经认证了该用户，且该信息在后续的登录过程中是需要的。 用法： 1user = authenticate(username='theuser',password='thepassword') login(HttpRequest, user)该函数接受一个HttpRequest对象，以及一个经过认证的User对象。 该函数实现一个用户登录的功能。它本质上会在后端为该用户生成相关session数据。 用法： 12345678910111213from django.contrib.auth import authenticate, login def my_view(request): username = request.POST['username'] password = request.POST['password'] user_obj = authenticate(username=username, password=password) if user_obj: login(request, user_obj) # Redirect to a success page. ... else: # Return an 'invalid login' error message. ... 注意： 只要使用login(request, user_obj)之后，request.user就能拿到当前登录的用户对象。否则request.user得到的是一个匿名用户对象（AnonymousUser Object）。 详细原理请查看 AuthenticationMiddleware 中间件源码。 logout(request)该函数接受一个HttpRequest对象，无返回值。 当调用该函数时，当前请求的session信息会全部清除。该用户即使没有登录，使用该函数也不会报错。 用法： 12345from django.contrib.auth import logout def logout_view(request): logout(request) # Redirect to a success page. is_authenticated()用来判断当前请求是否通过了认证。 用法： 123def my_view(request): if not request.user.is_authenticated(): return redirect('%s?next=%s' % (settings.LOGIN_URL, request.path)) login_requierd()auth 给我们提供的一个装饰器工具，用来快捷的给某个视图添加登录校验。 用法： 12345from django.contrib.auth.decorators import login_required @login_requireddef my_view(request): ... 若用户没有登录，则会跳转到django默认的 登录URL ‘/accounts/login/ ‘ 并传递当前访问url的绝对路径 (登陆成功后，会重定向到该路径)。 如果需要自定义登录的URL，则需要在settings.py文件中通过LOGIN_URL进行修改。 示例： 1LOGIN_URL = '/login/' # 这里配置成你项目登录页面的路由 create_user()auth 提供的一个创建新用户的方法，需要提供必要参数（username、password）等。 用法： 12from django.contrib.auth.models import Useruser = User.objects.create_user（username='用户名',password='密码',email='邮箱',...） create_superuser()auth 提供的一个创建新的超级用户的方法，需要提供必要参数（username、password）等。 用法： 12from django.contrib.auth.models import Useruser_obj = User.objects.create_superuser（username='用户名',password='密码',email='邮箱',...） check_password(raw_password)auth 提供的一个检查密码是否正确的方法，需要提供当前请求用户的密码。 密码正确返回True，否则返回False。 用法： 1ok = user_obj.check_password('密码') 或者直接针对当前请求的user对象校验原密码是否正确： 1ok = request.user.check_password(raw_password='原密码') set_password(raw_password)auth 提供的一个修改密码的方法，接收 要设置的新密码 作为参数。 注意：设置完一定要调用用户对象的save方法！！！ 用法： 12user_obj.set_password('新密码')user_obj.save() 一个修改密码功能的简单示例 123456789101112131415161718192021222324@login_requireddef set_password(request): user = request.user err_msg = '' if request.method == 'POST': old_password = request.POST.get('old_password', '') new_password = request.POST.get('new_password', '') repeat_password = request.POST.get('repeat_password', '') # 检查旧密码是否正确 if user.check_password(old_password): if not new_password: err_msg = '新密码不能为空' elif new_password != repeat_password: err_msg = '两次密码不一致' else: user.set_password(new_password) user.save() return redirect("/login/") else: err_msg = '原密码输入错误' content = &#123; 'err_msg': err_msg, &#125; return render(request, 'set_password.html', content) 用户对象的属性user_obj能够拿到认证所用用户表的数据属性，比如username， password等。 其他常用属性含义如下： is_staff ： 用户是否拥有网站的管理权限. is_active ： 是否允许用户登录, 设置为 False，可以在不删除用户的前提下禁止用户登录。 扩展默认的auth_user表这内置的认证系统这么好用，但是auth_user表字段都是固定的那几个，我在项目中没法拿来直接使用啊！ 比如，我想要加一个存储用户手机号的字段，怎么办？ 聪明的你可能会想到新建另外一张表然后通过一对一和内置的auth_user表关联，这样虽然能满足要求但是有没有更好的实现方式呢？ 答案是当然有了。 我们可以通过继承内置的 AbstractUser 类，来定义一个自己的Model类。 这样既能根据项目需求灵活的设计用户表，又能使用Django强大的认证系统了。 12345678910from django.contrib.auth.models import AbstractUserclass UserInfo(AbstractUser): """ 用户信息表 """ nid = models.AutoField(primary_key=True) phone = models.CharField(max_length=11, null=True, unique=True) def __str__(self): return self.username 注意： 按上面的方式扩展了内置的auth_user表之后，一定要在settings.py中告诉Django，我现在使用我新定义的UserInfo表来做用户认证。写法如下： 12# 引用Django自带的User表，继承使用时需要设置AUTH_USER_MODEL = "app名.UserInfo" 自定义认证系统默认使用的数据表之后，我们就可以像使用默认的auth_user表那样使用我们的UserInfo表了。比如： 创建普通用户： 1UserInfo.objects.create_user(username='用户名', password='密码') 创建超级用户： 1UserInfo.objects.create_superuser(username='用户名', password='密码') 再次注意： 一旦我们指定了新的认证系统所使用的表，我们就需要重新在数据库中创建该表，而不能继续使用原来默认的auth_user表了。]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django之Form组件]]></title>
    <url>%2F2018%2F12%2F25%2FDjango%E4%B9%8BForm%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[FormDjango的Form主要具有一下几大功能： 生成HTML标签 验证用户数据（显示错误信息） HTML Form提交保留上次提交数据 初始化页面显示内容 1、创建Form类1234567891011121314151617181920212223from django.forms import Formfrom django.forms import widgetsfrom django.forms import fields class MyForm(Form): user = fields.CharField( widget=widgets.TextInput(attrs=&#123;'id': 'i1', 'class': 'c1'&#125;) ) gender = fields.ChoiceField( choices=((1, '男'), (2, '女'),), initial=2, widget=widgets.RadioSelect ) city = fields.CharField( initial=2, widget=widgets.Select(choices=((1,'上海'),(2,'北京'),)) ) pwd = fields.CharField( widget=widgets.PasswordInput(attrs=&#123;'class': 'c1'&#125;, render_value=True) ) 2、View函数处理12345678910111213141516171819from django.shortcuts import render, redirectfrom .forms import MyForm def index(request): if request.method == "GET": obj = MyForm() return render(request, 'index.html', &#123;'form': obj&#125;) elif request.method == "POST": obj = MyForm(request.POST, request.FILES) if obj.is_valid(): values = obj.clean() print(values) else: errors = obj.errors print(errors) return render(request, 'index.html', &#123;'form': obj&#125;) else: return redirect('http://www.google.com') 3、生成HTML1234567&lt;form action="/" method="POST" enctype="multipart/form-data"&gt; &lt;p&gt;&#123;&#123; form.user &#125;&#125; &#123;&#123; form.user.errors &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; form.gender &#125;&#125; &#123;&#123; form.gender.errors &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; form.city &#125;&#125; &#123;&#123; form.city.errors &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; form.pwd &#125;&#125; &#123;&#123; form.pwd.errors &#125;&#125;&lt;/p&gt; &lt;input type="submit"/&gt;&lt;/form&gt; 4、其他标签12345678910&lt;form method="POST" enctype="multipart/form-data"&gt; &#123;% csrf_token %&#125; &#123;&#123; form.xxoo.label &#125;&#125; &#123;&#123; form.xxoo.id_for_label &#125;&#125; &#123;&#123; form.xxoo.label_tag &#125;&#125; &#123;&#123; form.xxoo.errors &#125;&#125; &lt;p&gt;&#123;&#123; form.user &#125;&#125; &#123;&#123; form.user.errors &#125;&#125;&lt;/p&gt; &lt;input type="submit" /&gt; &lt;/form&gt; Form类创建Form类时，主要涉及到 【字段】 和 【插件】，字段用于对用户请求数据的验证，插件用于自动生成HTML; 1、Django内置字段如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136Field required=True, 是否允许为空 widget=None, HTML插件 label=None, 用于生成Label标签或显示内容 initial=None, 初始值 help_text='', 帮助信息(在标签旁边显示) error_messages=None, 错误信息 &#123;'required': '不能为空', 'invalid': '格式错误'&#125; show_hidden_initial=False, 是否在当前插件后面再加一个隐藏的且具有默认值的插件（可用于检验两次输入是否一直） validators=[], 自定义验证规则 localize=False, 是否支持本地化 disabled=False, 是否可以编辑 label_suffix=None Label内容后缀 CharField(Field) max_length=None, 最大长度 min_length=None, 最小长度 strip=True 是否移除用户输入空白 IntegerField(Field) max_value=None, 最大值 min_value=None, 最小值 FloatField(IntegerField) ... DecimalField(IntegerField) max_value=None, 最大值 min_value=None, 最小值 max_digits=None, 总长度 decimal_places=None, 小数位长度 BaseTemporalField(Field) input_formats=None 时间格式化 DateField(BaseTemporalField) 格式：2015-09-01TimeField(BaseTemporalField) 格式：11:12DateTimeField(BaseTemporalField)格式：2015-09-01 11:12 DurationField(Field) 时间间隔：%d %H:%M:%S.%f ... RegexField(CharField) regex, 自定制正则表达式 max_length=None, 最大长度 min_length=None, 最小长度 error_message=None, 忽略，错误信息使用 error_messages=&#123;'invalid': '...'&#125; EmailField(CharField) ... FileField(Field) allow_empty_file=False 是否允许空文件 ImageField(FileField) ... 注：需要PIL模块，pip3 install Pillow 以上两个字典使用时，需要注意两点： - form表单中 enctype="multipart/form-data" - view函数中 obj = MyForm(request.POST, request.FILES) URLField(Field) ... BooleanField(Field) ... NullBooleanField(BooleanField) ... ChoiceField(Field) ... choices=(), 选项，如：choices = ((0,'上海'),(1,'北京'),) required=True, 是否必填 widget=None, 插件，默认select插件 label=None, Label内容 initial=None, 初始值 help_text='', 帮助提示 ModelChoiceField(ChoiceField) ... django.forms.models.ModelChoiceField queryset, # 查询数据库中的数据 empty_label="---------", # 默认空显示内容 to_field_name=None, # HTML中value的值对应的字段 limit_choices_to=None # ModelForm中对queryset二次筛选 ModelMultipleChoiceField(ModelChoiceField) ... django.forms.models.ModelMultipleChoiceField TypedChoiceField(ChoiceField) coerce = lambda val: val 对选中的值进行一次转换 empty_value= '' 空值的默认值 MultipleChoiceField(ChoiceField) ... TypedMultipleChoiceField(MultipleChoiceField) coerce = lambda val: val 对选中的每一个值进行一次转换 empty_value= '' 空值的默认值 ComboField(Field) fields=() 使用多个验证，如下：即验证最大长度20，又验证邮箱格式 fields.ComboField(fields=[fields.CharField(max_length=20), fields.EmailField(),]) MultiValueField(Field) PS: 抽象类，子类中可以实现聚合多个字典去匹配一个值，要配合MultiWidget使用 SplitDateTimeField(MultiValueField) input_date_formats=None, 格式列表：['%Y--%m--%d', '%m%d/%Y', '%m/%d/%y'] input_time_formats=None 格式列表：['%H:%M:%S', '%H:%M:%S.%f', '%H:%M'] FilePathField(ChoiceField) 文件选项，目录下文件显示在页面中 path, 文件夹路径 match=None, 正则匹配 recursive=False, 递归下面的文件夹 allow_files=True, 允许文件 allow_folders=False, 允许文件夹 required=True, widget=None, label=None, initial=None, help_text='' GenericIPAddressField protocol='both', both,ipv4,ipv6支持的IP格式 unpack_ipv4=False 解析ipv4地址，如果是::ffff:192.0.2.1时候，可解析为192.0.2.1， PS：protocol必须为both才能启用 SlugField(CharField) 数字，字母，下划线，减号（连字符） ... UUIDField(CharField) uuid类型 ... 注：UUID是根据MAC以及当前时间等创建的不重复的随机字符串 1234567891011121314151617181920212223242526272829303132&gt;&gt;&gt; import uuid # make a UUID based on the host ID and current time &gt;&gt;&gt; uuid.uuid1() # doctest: +SKIP UUID('a8098c1a-f86e-11da-bd1a-00112444be1e') # make a UUID using an MD5 hash of a namespace UUID and a name &gt;&gt;&gt; uuid.uuid3(uuid.NAMESPACE_DNS, 'python.org') UUID('6fa459ea-ee8a-3ca4-894e-db77e160355e') # make a random UUID &gt;&gt;&gt; uuid.uuid4() # doctest: +SKIP UUID('16fd2706-8baf-433b-82eb-8c7fada847da') # make a UUID using a SHA-1 hash of a namespace UUID and a name &gt;&gt;&gt; uuid.uuid5(uuid.NAMESPACE_DNS, 'python.org') UUID('886313e1-3b8a-5372-9b90-0c9aee199e5d') # make a UUID from a string of hex digits (braces and hyphens ignored) &gt;&gt;&gt; x = uuid.UUID('&#123;00010203-0405-0607-0809-0a0b0c0d0e0f&#125;') # convert a UUID to a string of hex digits in standard form &gt;&gt;&gt; str(x) '00010203-0405-0607-0809-0a0b0c0d0e0f' # get the raw 16 bytes of the UUID &gt;&gt;&gt; x.bytes b'\x00\x01\x02\x03\x04\x05\x06\x07\x08\t\n\x0b\x0c\r\x0e\x0f' # make a UUID from a 16-byte string &gt;&gt;&gt; uuid.UUID(bytes=x.bytes) UUID('00010203-0405-0607-0809-0a0b0c0d0e0f') 2、Django内置插件：12345678910111213141516171819202122TextInput(Input)NumberInput(TextInput)EmailInput(TextInput)URLInput(TextInput)PasswordInput(TextInput)HiddenInput(TextInput)Textarea(Widget)DateInput(DateTimeBaseInput)DateTimeInput(DateTimeBaseInput)TimeInput(DateTimeBaseInput)CheckboxInputSelectNullBooleanSelectSelectMultipleRadioSelectCheckboxSelectMultipleFileInputClearableFileInputMultipleHiddenInputSplitDateTimeWidgetSplitHiddenDateTimeWidgetSelectDateWidget 常用选择插件12345678910111213141516171819202122232425262728293031323334353637383940414243444546# 单radio，值为字符串# user = fields.CharField(# initial=2,# widget=widgets.RadioSelect(choices=((1,'上海'),(2,'北京'),))# ) # 单radio，值为字符串# user = fields.ChoiceField(# choices=((1, '上海'), (2, '北京'),),# initial=2,# widget=widgets.RadioSelect# ) # 单select，值为字符串# user = fields.CharField(# initial=2,# widget=widgets.Select(choices=((1,'上海'),(2,'北京'),))# ) # 单select，值为字符串# user = fields.ChoiceField(# choices=((1, '上海'), (2, '北京'),),# initial=2,# widget=widgets.Select# ) # 多选select，值为列表# user = fields.MultipleChoiceField(# choices=((1,'上海'),(2,'北京'),),# initial=[1,],# widget=widgets.SelectMultiple# ) # 单checkbox# user = fields.CharField(# widget=widgets.CheckboxInput()# ) # 多选checkbox,值为列表# user = fields.MultipleChoiceField(# initial=[2, ],# choices=((1, '上海'), (2, '北京'),),# widget=widgets.CheckboxSelectMultiple# ) 在使用选择标签时，需要注意choices的选项可以从数据库中获取，但是由于是静态字段 获取的值无法实时更新，那么需要自定义构造方法从而达到此目的。 方式一：123456789101112131415161718from django.forms import Formfrom django.forms import widgetsfrom django.forms import fieldsfrom django.core.validators import RegexValidator class MyForm(Form): user = fields.ChoiceField( # choices=((1, '上海'), (2, '北京'),), initial=2, widget=widgets.Select ) def __init__(self, *args, **kwargs): super(MyForm,self).__init__(*args, **kwargs) # self.fields['user'].widget.choices = ((1, '上海'), (2, '北京'),) # 或 self.fields['user'].widget.choices = models.Classes.objects.all().value_list('id','caption') 方式二：使用django提供的ModelChoiceField和ModelMultipleChoiceField字段来实现 12345678910from django import formsfrom django.forms import fieldsfrom django.forms import widgetsfrom django.forms import models as form_modelfrom django.core.exceptions import ValidationErrorfrom django.core.validators import RegexValidator class FInfo(forms.Form): authors = form_model.ModelMultipleChoiceField(queryset=models.NNewType.objects.all()) # authors = form_model.ModelChoiceField(queryset=models.NNewType.objects.all()) 自定义验证规则方式一：123456789from django.forms import Formfrom django.forms import widgetsfrom django.forms import fieldsfrom django.core.validators import RegexValidator class MyForm(Form): user = fields.CharField( validators=[RegexValidator(r'^[0-9]+$', '请输入数字'), RegexValidator(r'^159[0-9]+$', '数字必须以159开头')], ) 方式二：1234567891011121314151617181920212223242526272829303132333435import refrom django.forms import Formfrom django.forms import widgetsfrom django.forms import fieldsfrom django.core.exceptions import ValidationError # 自定义验证规则def mobile_validate(value): mobile_re = re.compile(r'^(13[0-9]|15[012356789]|17[678]|18[0-9]|14[57])[0-9]&#123;8&#125;$') if not mobile_re.match(value): raise ValidationError('手机号码格式错误') class PublishForm(Form): title = fields.CharField(max_length=20, min_length=5, error_messages=&#123;'required': '标题不能为空', 'min_length': '标题最少为5个字符', 'max_length': '标题最多为20个字符'&#125;, widget=widgets.TextInput(attrs=&#123;'class': "form-control", 'placeholder': '标题5-20个字符'&#125;)) # 使用自定义验证规则 phone = fields.CharField(validators=[mobile_validate, ], error_messages=&#123;'required': '手机不能为空'&#125;, widget=widgets.TextInput(attrs=&#123;'class': "form-control", 'placeholder': u'手机号码'&#125;)) email = fields.EmailField(required=False, error_messages=&#123;'required': u'邮箱不能为空','invalid': u'邮箱格式错误'&#125;, widget=widgets.TextInput(attrs=&#123;'class': "form-control", 'placeholder': u'邮箱'&#125;)) 方法三：自定义方法1234567891011121314151617181920from django import forms from django.forms import fields from django.forms import widgets from django.core.exceptions import ValidationError from django.core.validators import RegexValidator class FInfo(forms.Form): username = fields.CharField(max_length=5, validators=[RegexValidator(r'^[0-9]+$', 'Enter a valid extension.', 'invalid')], ) email = fields.EmailField() def clean_username(self): """ Form中字段中定义的格式匹配完之后，执行此方法进行验证 :return: """ value = self.cleaned_data['username'] if "666" in value: raise ValidationError('666已经被玩烂了...', 'invalid') return value 方式四：同时生成多个标签进行验证12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061from django.forms import Formfrom django.forms import widgetsfrom django.forms import fields from django.core.validators import RegexValidator ############## 自定义字段 ##############class PhoneField(fields.MultiValueField): def __init__(self, *args, **kwargs): # Define one message for all fields. error_messages = &#123; 'incomplete': 'Enter a country calling code and a phone number.', &#125; # Or define a different message for each field. f = ( fields.CharField( error_messages=&#123;'incomplete': 'Enter a country calling code.'&#125;, validators=[ RegexValidator(r'^[0-9]+$', 'Enter a valid country calling code.'), ], ), fields.CharField( error_messages=&#123;'incomplete': 'Enter a phone number.'&#125;, validators=[RegexValidator(r'^[0-9]+$', 'Enter a valid phone number.')], ), fields.CharField( validators=[RegexValidator(r'^[0-9]+$', 'Enter a valid extension.')], required=False, ), ) super(PhoneField, self).__init__(error_messages=error_messages, fields=f, require_all_fields=False, *args, **kwargs) def compress(self, data_list): """ 当用户验证都通过后，该值返回给用户 :param data_list: :return: """ return data_list ############## 自定义插件 ##############class SplitPhoneWidget(widgets.MultiWidget): def __init__(self): ws = ( widgets.TextInput(), widgets.TextInput(), widgets.TextInput(), ) super(SplitPhoneWidget, self).__init__(ws) def decompress(self, value): """ 处理初始值，当初始值initial不是列表时，调用该方法 :param value: :return: """ if value: return value.split(',') return [None, None, None] 初始化数据在Web应用程序中开发编写功能时，时常用到获取数据库中的数据并将值初始化在HTML中的标签上。 1、Form 12345678910111213from django.forms import Formfrom django.forms import widgetsfrom django.forms import fieldsfrom django.core.validators import RegexValidator class MyForm(Form): user = fields.CharField() city = fields.ChoiceField( choices=((1, '上海'), (2, '北京'),), widget=widgets.Select ) 2、Views 1234567891011121314from django.shortcuts import render, redirectfrom .forms import MyForm def index(request): if request.method == "GET": values = &#123;'user': 'root', 'city': 2&#125; obj = MyForm(values) return render(request, 'index.html', &#123;'form': obj&#125;) elif request.method == "POST": return redirect('http://www.google.com') else: return redirect('http://www.google.com') 3、HTML 1234567&lt;form method="POST" enctype="multipart/form-data"&gt; &#123;% csrf_token %&#125; &lt;p&gt;&#123;&#123; form.user &#125;&#125; &#123;&#123; form.user.errors &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; form.city &#125;&#125; &#123;&#123; form.city.errors &#125;&#125;&lt;/p&gt; &lt;input type="submit"/&gt;&lt;/form&gt;]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Form</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django之session]]></title>
    <url>%2F2018%2F12%2F24%2FDjango%E4%B9%8Bsession%2F</url>
    <content type="text"><![CDATA[sessionsession是什么？ 1234保存在服务端的数据(本质是键值对)应用：依赖cookie作用：保持会话(web网站)好处：敏感信息不会直接给客户端 Django中默认支持Session，其内部提供了5种类型的Session供开发者使用： 数据库（默认） 缓存 文件 缓存+数据库 加密cookie 1、数据库Session1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253Django默认支持Session，并且默认是将Session数据存储在数据库中，即：django_session 表中。 a. 配置 settings.py SESSION_ENGINE = 'django.contrib.sessions.backends.db' # 引擎（默认） SESSION_COOKIE_NAME ＝ "sessionid" # Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串（默认） SESSION_COOKIE_PATH ＝ "/" # Session的cookie保存的路径（默认） SESSION_COOKIE_DOMAIN = None # Session的cookie保存的域名（默认） SESSION_COOKIE_SECURE = False # 是否Https传输cookie（默认） SESSION_COOKIE_HTTPONLY = True # 是否Session的cookie只支持http传输（默认） SESSION_COOKIE_AGE = 1209600 # Session的cookie失效日期（2周）（默认） SESSION_EXPIRE_AT_BROWSER_CLOSE = False # 是否关闭浏览器使得Session过期（默认） SESSION_SAVE_EVERY_REQUEST = False # 是否每次请求都保存Session，默认修改之后才保存（默认） b. 使用 def index(request): # 获取、设置、删除Session中数据 request.session['k1'] request.session.get('k1',None) request.session['k1'] = 123 request.session.setdefault('k1',123) # 存在则不设置 del request.session['k1'] # 所有 键、值、键值对 request.session.keys() request.session.values() request.session.items() request.session.iterkeys() request.session.itervalues() request.session.iteritems() # 用户session的随机字符串 request.session.session_key # 将所有Session失效日期小于当前日期的数据删除 request.session.clear_expired() # 检查 用户session的随机字符串 在数据库中是否 request.session.exists(request.session.session_key) # 删除当前用户的所有Session数据 request.session.delete(request.session.session_key) request.session.set_expiry(value) * 如果value是个整数，session会在些秒数后失效。 * 如果value是个datatime或timedelta，session就会在这个时间后失效。 * 如果value是0,用户关闭浏览器session就会失效。 * 如果value是None,session会依赖全局session失效策略。 2、缓存Session1234567891011121314151617181920a. 配置 settings.py SESSION_ENGINE = 'django.contrib.sessions.backends.cache' # 引擎 SESSION_CACHE_ALIAS = 'default' # 使用的缓存别名（默认内存缓存，也可以是memcache），此处别名依赖缓存的设置 SESSION_COOKIE_NAME ＝ "sessionid" # Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串 SESSION_COOKIE_PATH ＝ "/" # Session的cookie保存的路径 SESSION_COOKIE_DOMAIN = None # Session的cookie保存的域名 SESSION_COOKIE_SECURE = False # 是否Https传输cookie SESSION_COOKIE_HTTPONLY = True # 是否Session的cookie只支持http传输 SESSION_COOKIE_AGE = 1209600 # Session的cookie失效日期（2周） SESSION_EXPIRE_AT_BROWSER_CLOSE = False # 是否关闭浏览器使得Session过期 SESSION_SAVE_EVERY_REQUEST = False # 是否每次请求都保存Session，默认修改之后才保存 b. 使用 同上 3、文件Session123456789101112131415161718a. 配置 settings.py SESSION_ENGINE = 'django.contrib.sessions.backends.file' # 引擎 SESSION_FILE_PATH = None # 缓存文件路径，如果为None，则使用tempfile模块获取一个临时地址tempfile.gettempdir() # 如：/var/folders/d3/j9tj0gz93dg06bmwxmhh6_xm0000gn/T SESSION_COOKIE_NAME ＝ "sessionid" # Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串 SESSION_COOKIE_PATH ＝ "/" # Session的cookie保存的路径 SESSION_COOKIE_DOMAIN = None # Session的cookie保存的域名 SESSION_COOKIE_SECURE = False # 是否Https传输cookie SESSION_COOKIE_HTTPONLY = True # 是否Session的cookie只支持http传输 SESSION_COOKIE_AGE = 1209600 # Session的cookie失效日期（2周） SESSION_EXPIRE_AT_BROWSER_CLOSE = False # 是否关闭浏览器使得Session过期 SESSION_SAVE_EVERY_REQUEST = False # 是否每次请求都保存Session，默认修改之后才保存 b. 使用 同上 4、缓存+数据库Session123456789数据库用于做持久化，缓存用于提高效率 a. 配置 settings.py SESSION_ENGINE = 'django.contrib.sessions.backends.cached_db' # 引擎 b. 使用 同上 5、加密cookie Session1234567a. 配置 settings.py SESSION_ENGINE = 'django.contrib.sessions.backends.signed_cookies' # 引擎 b. 使用 同上 扩展：Session用户验证1234567def login(func): def wrap(request, *args, **kwargs): # 如果未登陆，跳转到指定页面 if request.path == '/test/': return redirect('http://www.baidu.com') return func(request, *args, **kwargs) return wrap]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django之cookie]]></title>
    <url>%2F2018%2F12%2F24%2FDjango%E4%B9%8Bcookie%2F</url>
    <content type="text"><![CDATA[cookiecookie是什么？ 1保存在客户端浏览器上的键值对 1、获取Cookie：123456request.COOKIES['key']request.get_signed_cookie(key, default=RAISE_ERROR, salt='', max_age=None) 参数： default: 默认值 salt: 加密盐 max_age: 后台控制过期时间 2、设置Cookie：12345678910111213rep = HttpResponse(...) 或 rep ＝ render(request, ...) rep.set_cookie(key,value,...)rep.set_signed_cookie(key,value,salt='加密盐',...) 参数： key, 键 value='', 值 max_age=None, 超时时间 expires=None, 超时时间(IE requires expires, so set it if hasn't been already.) path='/', Cookie生效的路径，/ 表示根路径，特殊的：跟路径的cookie可以被任何url的页面访问 domain=None, Cookie生效的域名 secure=False, https传输 httponly=False 只能http协议传输，无法被JavaScript获取（不是绝对，底层抓包可以获取到也可以被覆盖） 由于cookie保存在客户端的电脑上，所以，JavaScript和jquery也可以操作cookie。 12&lt;script src='/static/js/jquery.cookie.js'&gt;&lt;/script&gt;$.cookie("list_pager_num", 30,&#123; path: '/' &#125;);]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django中间件]]></title>
    <url>%2F2018%2F12%2F24%2FDjango%E4%B8%AD%E9%97%B4%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[中间件django 中的中间件（middleware），在django中，中间件其实就是一个类，在请求到来和结束后，django会根据自己的规则在合适的时机执行中间件中相应的方法。 在django项目的settings模块中，有一个 MIDDLEWARE_CLASSES 变量，其中每一个元素就是一个中间件，如下 123456789MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware',] 与mange.py在同一目录下的文件夹 messiless/middleware下的auth.py文件中的Authentication类 中间件中可以定义四个方法，分别是： process_request(self,request) process_view(self, request, callback, callback_args, callback_kwargs) process_template_response(self,request,response) process_exception(self, request, exception) process_response(self, request, response) 以上方法的返回值可以是None和HttpResonse对象，如果是None，则继续按照django定义的规则向下执行，如果是HttpResonse对象，则直接将该对象返回给用户。 应用：对所有请求或者一部分请求做批量处理 自定义中间件1、创建中间件类1234567891011121314class RequestExeute(object): def process_request(self,request): pass def process_view(self, request, callback, callback_args, callback_kwargs): i =1 pass def process_exception(self, request, exception): pass def process_template_response(self,request,response) # 视图函数的返回值中有render方法，才会被调用 pass def process_response(self, request, response): return response 2、注册中间件12345678910MIDDLEWARE_CLASSES = ( 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.auth.middleware.SessionAuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware', 'messiless.middleware.auth.RequestExeute',)]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django之模板]]></title>
    <url>%2F2018%2F12%2F24%2FDjango%E4%B9%8B%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[1、模版的执行模版的创建过程，对于模版，其实就是读取模版（其中嵌套着模版标签），然后将 Model 中获取的数据插入到模版中，最后将信息返回给用户。 1234def current_datetime(request): now = datetime.datetime.now() html = "&lt;html&gt;&lt;body&gt;It is now %s.&lt;/body&gt;&lt;/html&gt;" % now return HttpResponse(html) 1234from django import templatet = template.Template('My name is &#123;&#123; name &#125;&#125;.')c = template.Context(&#123;'name': 'Adrian'&#125;)print t.render(c) 12345678910import datetimefrom django import templateimport DjangoDemo.settings now = datetime.datetime.now()fp = open(settings.BASE_DIR+'/templates/Home/Index.html')t = template.Template(fp.read())fp.close()html = t.render(template.Context(&#123;'current_date': now&#125;))return HttpResponse(html 12345678910from django.template.loader import get_templatefrom django.template import Contextfrom django.http import HttpResponseimport datetime def current_datetime(request): now = datetime.datetime.now() t = get_template('current_datetime.html') html = t.render(Context(&#123;'current_date': now&#125;)) return HttpResponse(html) 1return render_to_response('Account/Login.html',data,context_instance=RequestContext(request)) 2、模版语言模板中也有自己的语言，该语言可以实现数据展示 12345678910111213141516171819&#123;&#123; item &#125;&#125;&#123;% for item in item_list %&#125; &lt;a&gt;&#123;&#123; item &#125;&#125;&lt;/a&gt; &#123;% endfor %&#125; forloop.counter forloop.first forloop.last &#123;% if ordered_warranty %&#125; &#123;% else %&#125; &#123;% endif %&#125;母板：&#123;% block title %&#125;&#123;% endblock %&#125; 子板：&#123;% extends "base.html" %&#125; &#123;% block title %&#125;&#123;% endblock %&#125; 适用于页面继承include 适用于导入小组件&#123;% include 'pub.html' %&#125;帮助方法：&#123;&#123; item.event_start|date:"Y-m-d H:i:s"&#125;&#125;&#123;&#123; bio|truncatewords:"30" &#125;&#125;&#123;&#123; my_list|first|upper &#125;&#125;&#123;&#123; name|lower &#125;&#125; 3、自定义simple_tag1、在app中创建templatetags模块 2、创建任意 .py 文件，如：xx.py 123456789101112131415#!/usr/bin/env python#coding:utf-8from django import templatefrom django.utils.safestring import mark_safe register = template.Library() @register.simple_tagdef my_simple_time(v1,v2,v3): return v1 + v2 + v3 @register.simple_tagdef my_input(id,arg): result = "&lt;input type='text' id='%s' class='%s' /&gt;" %(id,arg,) return mark_safe(result) 3、在settings中配置当前app，不然django无法找到自定义的simple_tag 123456789INSTALLED_APPS = ( 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'app01',) 4、在使用自定义simple_tag的html文件中导入之前创建的 xx.py 文件名 1&#123;% load xx %&#125; 5、使用simple_tag 12&#123;% my_simple_time 1 2 3%&#125;&#123;% my_input 'id_username' 'hide'%&#125;]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django之跨站请求伪造]]></title>
    <url>%2F2018%2F12%2F23%2FDjango%E4%B9%8B%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%2F</url>
    <content type="text"><![CDATA[一、简介jango为用户实现防止跨站请求伪造的功能，通过中间件 django.middleware.csrf.CsrfViewMiddleware 来完成。而对于django中设置防跨站请求伪造功能有分为全局和局部。 全局： 中间件 django.middleware.csrf.CsrfViewMiddleware 局部： @csrf_protect，为当前函数强制设置防跨站请求伪造功能，即便settings中没有设置全局中间件。 @csrf_exempt，取消当前函数防跨站请求伪造功能，即便settings中设置了全局中间件。 注：from django.views.decorators.csrf import csrf_exempt,csrf_protect 二、应用1、普通表单1234567veiw中设置返回值： return render_to_response('Account/Login.html',data,context_instance=RequestContext(request)) 或者 return render(request, 'xxx.html', data) html中设置Token: &#123;% csrf_token %&#125; 2、Ajax对于传统的form，可以通过表单的方式将token再次发送到服务端，而对于ajax的话，使用如下方式。 view.py 12345678910from django.template.context import RequestContext# Create your views here. def test(request): if request.method == 'POST': print request.POST return HttpResponse('ok') return render_to_response('app01/test.html',context_instance=RequestContext(request)) text.html 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &#123;% csrf_token %&#125; &lt;input type="button" onclick="Do();" value="Do it"/&gt; &lt;script src="/static/plugin/jquery/jquery-1.8.0.js"&gt;&lt;/script&gt; &lt;script src="/static/plugin/jquery/jquery.cookie.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; function Do()&#123; var csrftoken = $.cookie('csrftoken'); $.ajax(&#123; url:"/app01/test/", data:&#123;id:1&#125;, headers:&#123;"X-CSRFToken":csrftoken&#125; type:'POST', success:function(data)&#123; console.log(data); &#125; &#125;); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>跨站请求伪造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django分页]]></title>
    <url>%2F2018%2F12%2F23%2FDjango%E5%88%86%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[一、Django内置分页views.py 123456789101112131415161718192021222324252627282930from django.shortcuts import renderfrom django.core.paginator import Paginator, EmptyPage, PageNotAnIntegerL = []for i in range(999): L.append(i)def index(request): current_page = request.GET.get('p') paginator = Paginator(L, 10) # per_page: 每页显示条目数量 # count: 数据总个数 # num_pages:总页数 # page_range:总页数的索引范围，如: (1,10),(1,200) # page: page对象 try: posts = paginator.page(current_page) # has_next 是否有下一页 # next_page_number 下一页页码 # has_previous 是否有上一页 # previous_page_number 上一页页码 # object_list 分页之后的数据列表 # number 当前页 # paginator paginator对象 except PageNotAnInteger: posts = paginator.page(1) except EmptyPage: posts = paginator.page(paginator.num_pages) return render(request, 'index.html', &#123;'posts': posts&#125;) Html 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt; &#123;% for item in posts %&#125; &lt;li&gt;&#123;&#123; item &#125;&#125;&lt;/li&gt; &#123;% endfor %&#125;&lt;/ul&gt;&lt;div class="pagination"&gt; &lt;span class="step-links"&gt; &#123;% if posts.has_previous %&#125; &lt;a href="?p=&#123;&#123; posts.previous_page_number &#125;&#125;"&gt;Previous&lt;/a&gt; &#123;% endif %&#125; &lt;span class="current"&gt; Page &#123;&#123; posts.number &#125;&#125; of &#123;&#123; posts.paginator.num_pages &#125;&#125;. &lt;/span&gt; &#123;% if posts.has_next %&#125; &lt;a href="?p=&#123;&#123; posts.next_page_number &#125;&#125;"&gt;Next&lt;/a&gt; &#123;% endif %&#125; &lt;/span&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 扩展内置分页：views.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465from django.shortcuts import renderfrom django.core.paginator import Paginator, EmptyPage, PageNotAnIntegerclass CustomPaginator(Paginator): def __init__(self, current_page, max_pager_num, *args, **kwargs): """ :param current_page: 当前页 :param max_pager_num:最多显示的页码个数 :param args: :param kwargs: :return: """ self.current_page = int(current_page) self.max_pager_num = max_pager_num super(CustomPaginator, self).__init__(*args, **kwargs) def page_num_range(self): # 当前页面 # self.current_page # 总页数 # self.num_pages # 最多显示的页码个数 # self.max_pager_num print(1) if self.num_pages &lt; self.max_pager_num: return range(1, self.num_pages + 1) print(2) part = int(self.max_pager_num / 2) if self.current_page - part &lt; 1: return range(1, self.max_pager_num + 1) print(3) if self.current_page + part &gt; self.num_pages: return range(self.num_pages + 1 - self.max_pager_num, self.num_pages + 1) print(4) return range(self.current_page - part, self.current_page + part + 1)L = []for i in range(999): L.append(i)def index(request): current_page = request.GET.get('p') paginator = CustomPaginator(current_page, 11, L, 10) # per_page: 每页显示条目数量 # count: 数据总个数 # num_pages:总页数 # page_range:总页数的索引范围，如: (1,10),(1,200) # page: page对象 try: posts = paginator.page(current_page) # has_next 是否有下一页 # next_page_number 下一页页码 # has_previous 是否有上一页 # previous_page_number 上一页页码 # object_list 分页之后的数据列表 # number 当前页 # paginator paginator对象 except PageNotAnInteger: posts = paginator.page(1) except EmptyPage: posts = paginator.page(paginator.num_pages) return render(request, 'index.html', &#123;'posts': posts&#125;) 扩展内置分页：Html 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt; &#123;% for item in posts %&#125; &lt;li&gt;&#123;&#123; item &#125;&#125;&lt;/li&gt; &#123;% endfor %&#125;&lt;/ul&gt;&lt;div class="pagination"&gt;&lt;span class="step-links"&gt;&#123;% if posts.has_previous %&#125; &lt;a href="?p=&#123;&#123; posts.previous_page_number &#125;&#125;"&gt;Previous&lt;/a&gt;&#123;% endif %&#125; &#123;% for i in posts.paginator.page_num_range %&#125; &lt;a href="?p=&#123;&#123; i &#125;&#125;"&gt;&#123;&#123; i &#125;&#125;&lt;/a&gt; &#123;% endfor %&#125; &#123;% if posts.has_next %&#125; &lt;a href="?p=&#123;&#123; posts.next_page_number &#125;&#125;"&gt;Next&lt;/a&gt; &#123;% endif %&#125;&lt;/span&gt;&lt;span class="current"&gt;Page &#123;&#123; posts.number &#125;&#125; of &#123;&#123; posts.paginator.num_pages &#125;&#125;.&lt;/span&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 二、自定义分页分页功能在每个网站都是必要的，对于分页来说，其实就是根据用户的输入计算出应该在数据库表中的起始位置。 1、设定每页显示数据条数 2、用户输入页码（第一页、第二页…） 3、根据设定的每页显示条数和当前页码，计算出需要取数据表的起始位置 4、在数据表中根据起始位置取值，页面上输出数据 需求又来了，需要在页面上显示分页的页面。如：［上一页］［1］［2］［3］［4］［5］［下一页］ 1、设定每页显示数据条数 2、用户输入页码（第一页、第二页…） 3、设定显示多少页号 4、获取当前数据总条数 5、根据设定显示多少页号和数据总条数计算出，总页数 6、根据设定的每页显示条数和当前页码，计算出需要取数据表的起始位置 7、在数据表中根据起始位置取值，页面上输出数据 8、输出分页html，如：［上一页］［1］［2］［3］［4］［5］［下一页］ 分页实例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#!/usr/bin/env python# _*_coding:utf-8_*_from django.utils.safestring import mark_safe class PageInfo(object): def __init__(self,current,totalItem,peritems=5): self.__current=current self.__peritems=peritems self.__totalItem=totalItem def From(self): return (self.__current-1)*self.__peritems def To(self): return self.__current*self.__peritems def TotalPage(self): #总页数 result=divmod(self.__totalItem,self.__peritems) if result[1]==0: return result[0] else: return result[0]+1 def Custompager(baseurl,currentPage,totalpage): #基础页，当前页，总页数 perPager=11 #总页数&lt;11 #0 -- totalpage #总页数&gt;11 #当前页大于5 currentPage-5 -- currentPage+5 #currentPage+5是否超过总页数,超过总页数，end就是总页数 #当前页小于5 0 -- 11 begin=0 end=0 if totalpage &lt;= 11: begin=0 end=totalpage else: if currentPage&gt;5: begin=currentPage-5 end=currentPage+5 if end &gt; totalpage: end=totalpage else: begin=0 end=11 pager_list=[] if currentPage&lt;=1: first="&lt;a href=''&gt;首页&lt;/a&gt;" else: first="&lt;a href='%s%d'&gt;首页&lt;/a&gt;" % (baseurl,1) pager_list.append(first) if currentPage&lt;=1: prev="&lt;a href=''&gt;上一页&lt;/a&gt;" else: prev="&lt;a href='%s%d'&gt;上一页&lt;/a&gt;" % (baseurl,currentPage-1) pager_list.append(prev) for i in range(begin+1,end+1): if i == currentPage: temp="&lt;a href='%s%d' class='selected'&gt;%d&lt;/a&gt;" % (baseurl,i,i) else: temp="&lt;a href='%s%d'&gt;%d&lt;/a&gt;" % (baseurl,i,i) pager_list.append(temp) if currentPage&gt;=totalpage: next="&lt;a href='#'&gt;下一页&lt;/a&gt;" else: next="&lt;a href='%s%d'&gt;下一页&lt;/a&gt;" % (baseurl,currentPage+1) pager_list.append(next) if currentPage&gt;=totalpage: last="&lt;a href=''&gt;末页&lt;/a&gt;" else: last="&lt;a href='%s%d'&gt;末页&lt;/a&gt;" % (baseurl,totalpage) pager_list.append(last) result=''.join(pager_list) return mark_safe(result) #把字符串转成html语言 总结，分页时需要做三件事： 创建处理分页数据的类 根据分页数据获取数据 输出分页HTML，即：［上一页］［1］［2］［3］［4］［5］［下一页］]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>分页</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django中的FBV和CBV]]></title>
    <url>%2F2018%2F12%2F22%2FDjango%E4%B8%AD%E7%9A%84FBV%E5%92%8CCBV%2F</url>
    <content type="text"><![CDATA[FBVFBV（function base views） 就是在视图里使用函数处理请求。 看代码： urls.py 123456from django.urls import path, includefrom mytest import views urlpatterns = [ path('index/', views.index),] views.py 12345678from django.shortcuts import render def index(request): if request.method == 'POST': print('method is :' + request.method) elif request.method == 'GET': print('method is :' + request.method) return render(req, 'index.html') 注意此处定义的是函数【def index(req):】 index.html 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;index&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action="" method="post"&gt; &lt;input type="text" name="A" /&gt; &lt;input type="submit" name="b" value="提交" /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; CBVCBV（class base views） 就是在视图里使用类处理请求。 将上述代码中的urls.py 修改为如下： 123456from django.urls import path, includefrom mytest import views urlpatterns = [ path('index/', views.Index.as_view()),] 注：path(‘index/‘, views.Index.as_view()), 是固定用法。 将上述代码中的views.py 修改为如下： 1234567891011from django.views import View class Index(View): def get(self, request): print('method is :' + request.method) return render(request, 'index.html') def post(self, request): print('method is :' + request.method) return render(request, 'index.html') 注：类要继承 View ，类中函数名必须小写]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>FBV</tag>
        <tag>CBV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ORM操作]]></title>
    <url>%2F2018%2F12%2F22%2FORM%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[ModelDjango框架功能齐全自带数据库操作功能，本文主要介绍Django的ORM框架 到目前为止，当我们的程序涉及到数据库相关操作时，我们一般都会这么搞： 创建数据库，设计表结构和字段 使用 MySQLdb 来连接数据库，并编写数据访问层代码 业务逻辑层去调用数据访问层执行数据库操作 ORM是什么？：(在django中，根据代码中的类自动生成数据库的表也叫–code first) 123456789ORM：Object Relational Mapping(关系对象映射)类名对应------》数据库中的表名类属性对应---------》数据库里的字段类实例对应---------》数据库表里的一行数据obj.id obj.name.....类实例对象的属性 Django orm的优势： Django的orm操作本质上会根据对接的数据库引擎，翻译成对应的sql语句；所有使用Django开发的项目无需关心程序底层使用的是MySQL、Oracle、sqlite….，如果数据库迁移，只需要更换Django的数据库引擎即可； 一、Django连接MySQL1、创建数据库 （注意设置 数据的字符编码） 由于Django自带的orm是data_first类型的ORM，使用前必须先创建数据库 1create database wzc default character set utf8 collate utf8_general_ci; 2、修改project中的settings.py文件中设置 连接 MySQL数据库（Django默认使用的是sqllite数据库） 12345678910DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME':'wzc', 'USER': 'messiless', 'PASSWORD': '123456', 'HOST': '192.168.182.128', 'PORT': '3306', &#125;&#125; 扩展：查看orm操作执行的原生SQL语句 在project中的settings.py文件增加 1234567891011121314151617LOGGING = &#123; 'version': 1, 'disable_existing_loggers': False, 'handlers': &#123; 'console':&#123; 'level':'DEBUG', 'class':'logging.StreamHandler', &#125;, &#125;, 'loggers': &#123; 'django.db.backends': &#123; 'handlers': ['console'], 'propagate': True, 'level':'DEBUG', &#125;, &#125;&#125; 3、修改project 中的initpy 文件设置 Django默认连接MySQL的方式 12import pymysqlpymysql.install_as_MySQLdb() 4、setings文件注册APP 12345678910INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'app01', ] 5、models.py创建表 6、进行数据迁移 6.1、在winds cmd或者Linux shell的项目的manage.py目录下执行 1234python manage.py makemigrations #根据app下的migrations目录中的记录，检测当前model层代码是否发生变化？python manage.py migrate #把orm代码转换成sql语句去数据库执行python manage.py migrate --fake #只记录变化，不提交数据库操作 扩展：修改表结构之后常见报错 这个报错：因为表创建之时，新增字段既没有设置默认值，也没有设置新增字段可为空，去对应原有数据导致； 2中解决方法： 1234567891011121314151617181920211.设置新增字段可以为空 null=True2.给新增字段设置默认值 default=13.更多问题python manage.py makemigrations :把你写在models中的代码翻译成增、删、改的 SQL 语句；python manage.py migrate；讲python manage.py makemigrations翻译的SQL语句去数据库执行； python manage.py migrate --fake；假设 migrate 把所有SQL语句执行成功了；我在使用Django构建表结构的时候很长一段时间都是没有了解以上3条语句的执行意义，所有经常在修改表结构之后出现报错；出现报错的原因：无非就是 makemigrations翻译的 SQL，跟数据库里面真实的表结构 相互冲突,增加、删除不了表、外键关系；所以遇到报错 你应该先把model中的代码注释掉-----》python manage.py migrate --fake------》python manage.py makemigrations去数据库把已经存在的表、外键删掉（确保数据库目前的状态，可以让makemigrations翻译出来的SQL语句在数据库里执行成功；然后migrate）--------》 python manage.py migrate； 7.设置pycharm可视化MySQL 二、modles.py创建表ORM字段介绍Djan提供了很多字段类型，比如URL/Email/IP/ 但是mysql数据没有这些类型，这类型存储到数据库上本质是字符串数据类型,其主要目的是为了封装底层SQL语句； 1、字符串类（以下都是在数据库中本质都是字符串数据类型，此类字段只是在Django自带的admin中生效） 1name=models.CharField(max_length=32) 123456789EmailField(CharField)：IPAddressField(Field)URLField(CharField)SlugField(CharField)UUIDField(Field)FilePathField(Field)FileField(Field)ImageField(FileField)CommaSeparatedIntegerField(CharField) 扩展 models.CharField 对应的是MySQL的varchar数据类型 char 和 varchar的区别 : char和varchar的共同点是存储数据的长度，不能 超过max_length限制， 不同点是varchar根据数据实际长度存储，char按指定max_length（）存储数据；所有前者更节省硬盘空间； 2、时间字段 models.DateTimeField(null=True) date=models.DateField() 3、数字字段 (max_digits=30,decimal_places=10)总长度30小数位 10位） 1234数字：num = models.IntegerField()num = models.FloatField() 浮点price=models.DecimalField(max_digits=8,decimal_places=3) 精确浮点 4、枚举字段 123456 choice=( (1,'男人'), (2,'女人'), (3,'其他') )lover=models.IntegerField(choices=choice) #枚举类型 扩展 在数据库存储枚举类型，比外键有什么优势？ 1、无需连表查询性能低，省硬盘空间(选项不固定时用外键)2、在modle文件里不能动态增加（选项一成不变用Django的choice） 其他字段 1234567891011121314db_index = True 表示设置索引unique(唯一的意思) = True 设置唯一索引联合唯一索引class Meta:unique_together = ( ('email','ctime'),)联合索引（不做限制）index_together = (('email','ctime'),)ManyToManyField(RelatedField) #多对多操作 字段参数介绍1.数据库级别生效 字段 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149AutoField(Field) - int自增列，必须填入参数 primary_key=TrueBigAutoField(AutoField) - bigint自增列，必须填入参数 primary_key=True 注：当model中如果没有自增列，则自动会创建一个列名为id的列 from django.db import models class UserInfo(models.Model): # 自动创建一个列名为id的且为自增的整数列 username = models.CharField(max_length=32) class Group(models.Model): # 自定义自增列 nid = models.AutoField(primary_key=True) name = models.CharField(max_length=32)SmallIntegerField(IntegerField): - 小整数 -32768 ～ 32767PositiveSmallIntegerField(PositiveIntegerRelDbTypeMixin, IntegerField) - 正小整数 0 ～ 32767IntegerField(Field) - 整数列(有符号的) -2147483648 ～ 2147483647PositiveIntegerField(PositiveIntegerRelDbTypeMixin, IntegerField) - 正整数 0 ～ 2147483647BigIntegerField(IntegerField): - 长整型(有符号的) -9223372036854775808 ～ 9223372036854775807自定义无符号整数字段 class UnsignedIntegerField(models.IntegerField): def db_type(self, connection): return 'integer UNSIGNED' PS: 返回值为字段在数据库中的属性，Django字段默认的值为： 'AutoField': 'integer AUTO_INCREMENT', 'BigAutoField': 'bigint AUTO_INCREMENT', 'BinaryField': 'longblob', 'BooleanField': 'bool', 'CharField': 'varchar(%(max_length)s)', 'CommaSeparatedIntegerField': 'varchar(%(max_length)s)', 'DateField': 'date', 'DateTimeField': 'datetime', 'DecimalField': 'numeric(%(max_digits)s, %(decimal_places)s)', 'DurationField': 'bigint', 'FileField': 'varchar(%(max_length)s)', 'FilePathField': 'varchar(%(max_length)s)', 'FloatField': 'double precision', 'IntegerField': 'integer', 'BigIntegerField': 'bigint', 'IPAddressField': 'char(15)', 'GenericIPAddressField': 'char(39)', 'NullBooleanField': 'bool', 'OneToOneField': 'integer', 'PositiveIntegerField': 'integer UNSIGNED', 'PositiveSmallIntegerField': 'smallint UNSIGNED', 'SlugField': 'varchar(%(max_length)s)', 'SmallIntegerField': 'smallint', 'TextField': 'longtext', 'TimeField': 'time', 'UUIDField': 'char(32)',BooleanField(Field) - 布尔值类型NullBooleanField(Field): - 可以为空的布尔值CharField(Field) - 字符类型 - 必须提供max_length参数， max_length表示字符长度TextField(Field) - 文本类型EmailField(CharField)： - 字符串类型，Django Admin以及ModelForm中提供验证机制IPAddressField(Field) - 字符串类型，Django Admin以及ModelForm中提供验证 IPV4 机制GenericIPAddressField(Field) - 字符串类型，Django Admin以及ModelForm中提供验证 Ipv4和Ipv6 - 参数： protocol，用于指定Ipv4或Ipv6， 'both',"ipv4","ipv6" unpack_ipv4， 如果指定为True，则输入::ffff:192.0.2.1时候，可解析为192.0.2.1，开启刺功能，需要protocol="both"URLField(CharField) - 字符串类型，Django Admin以及ModelForm中提供验证 URLSlugField(CharField) - 字符串类型，Django Admin以及ModelForm中提供验证支持 字母、数字、下划线、连接符（减号）CommaSeparatedIntegerField(CharField) - 字符串类型，格式必须为逗号分割的数字UUIDField(Field) - 字符串类型，Django Admin以及ModelForm中提供对UUID格式的验证FilePathField(Field) - 字符串，Django Admin以及ModelForm中提供读取文件夹下文件的功能 - 参数： path, 文件夹路径 match=None, 正则匹配 recursive=False, 递归下面的文件夹 allow_files=True, 允许文件 allow_folders=False, 允许文件夹FileField(Field) - 字符串，路径保存在数据库，文件上传到指定目录 - 参数： upload_to = "" 上传文件的保存路径 storage = None 存储组件，默认django.core.files.storage.FileSystemStorageImageField(FileField) - 字符串，路径保存在数据库，文件上传到指定目录 - 参数： upload_to = "" 上传文件的保存路径 storage = None 存储组件，默认django.core.files.storage.FileSystemStorage width_field=None, 上传图片的高度保存的数据库字段名（字符串） height_field=None 上传图片的宽度保存的数据库字段名（字符串）DateTimeField(DateField) - 日期+时间格式 YYYY-MM-DD HH:MM[:ss[.uuuuuu]][TZ]DateField(DateTimeCheckMixin, Field) - 日期格式 YYYY-MM-DDTimeField(DateTimeCheckMixin, Field) - 时间格式 HH:MM[:ss[.uuuuuu]]DurationField(Field) - 长整数，时间间隔，数据库中按照bigint存储，ORM中获取的值为datetime.timedelta类型FloatField(Field) - 浮点型DecimalField(Field) - 10进制小数 - 参数： max_digits，小数总长度 decimal_places，小数位长度BinaryField(Field) - 二进制类型 参数 123456789101112131415161718192021222324252627282930313233343536373839null 数据库中字段是否可以为空db_column 数据库中字段的列名db_tablespacedefault 数据库中字段的默认值primary_key 数据库中字段是否为主键db_index 数据库中字段是否可以建立索引unique 数据库中字段是否可以建立唯一索引unique_for_date 数据库中字段【日期】部分是否可以建立唯一索引unique_for_month 数据库中字段【月】部分是否可以建立唯一索引unique_for_year 数据库中字段【年】部分是否可以建立唯一索引verbose_name Admin中显示的字段名称blank Admin中是否允许用户输入为空editable Admin中是否可以编辑help_text Admin中该字段的提示信息choices Admin中显示选择框的内容，用不变动的数据放在内存中从而避免跨表操作 如：gf = models.IntegerField(choices=[(0, '何穗'),(1, '大表姐'),],default=1)error_messages 自定义错误信息（字典类型），从而定制想要显示的错误信息； 字典健：null, blank, invalid, invalid_choice, unique, and unique_for_date 如：&#123;'null': "不能为空.", 'invalid': '格式错误'&#125;validators 自定义错误验证（列表类型），从而定制想要的验证规则 from django.core.validators import RegexValidator from django.core.validators import EmailValidator,URLValidator,DecimalValidator,\ MaxLengthValidator,MinLengthValidator,MaxValueValidator,MinValueValidator 如： test = models.CharField( max_length=32, error_messages=&#123; 'c1': '优先错信息1', 'c2': '优先错信息2', 'c3': '优先错信息3', &#125;, validators=[ RegexValidator(regex='root_\d+', message='错误了', code='c1'), RegexValidator(regex='root_112233\d+', message='又错误了', code='c2'), EmailValidator(message='又错误了', code='c3'), ] ) 2、Django admin级别生效 针对 dango_admin生效的参数（正则匹配）（使用Django admin就需要关心以下参数！！） 1234567891011121314151617181920212223blanke (是否为空)editable=False 是否允许编辑help_text="提示信息"提示信息choices=choice 提供下拉框error_messages="错误信息" 错误信息validators 自定义错误验证（列表类型），从而定制想要的验证规则 from django.core.validators import RegexValidator from django.core.validators import EmailValidator,URLValidator,DecimalValidator,\ MaxLengthValidator,MinLengthValidator,MaxValueValidator,MinValueValidator 如： test = models.CharField( max_length=32, error_messages=&#123; 'c1': '优先错信息1', 'c2': '优先错信息2', 'c3': '优先错信息3', &#125;, validators=[ RegexValidator(regex='root_\d+', message='错误了', code='c1'), RegexValidator(regex='root_112233\d+', message='又错误了', code='c2'), EmailValidator(message='又错误了', code='c3'), ] 连表结构 一对多：models.ForeignKey(其他表) 多对多：models.ManyToManyField(其他表) 一对一：models.OneToOneField(其他表) 12345678应用场景：一对多：当一张表中创建一行数据时，有一个单选的下拉框（可以被重复选择）例如：创建用户信息时候，需要选择一个用户类型【普通用户】【金牌用户】【铂金用户】等。多对多：在某表中创建一行数据是，有一个可以多选的下拉框例如：创建用户信息，需要为用户指定多个爱好一对一：在某表中创建一行数据时，有一个单选的下拉框（下拉框中的内容被用过一次就消失了例如：原有含10列数据的一张表保存相关信息，经过一段时间之后，10列无法满足需求，需要为原来的表再添加5列数据 字段以及参数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108ForeignKey(ForeignObject) # ForeignObject(RelatedField) to, # 要进行关联的表名 to_field=None, # 要关联的表中的字段名称 on_delete=None, # 当删除关联表中的数据时，当前表与其关联的行的行为 - models.CASCADE，删除关联数据，与之关联也删除 - models.DO_NOTHING，删除关联数据，引发错误IntegrityError - models.PROTECT，删除关联数据，引发错误ProtectedError - models.SET_NULL，删除关联数据，与之关联的值设置为null（前提FK字段需要设置为可空） - models.SET_DEFAULT，删除关联数据，与之关联的值设置为默认值（前提FK字段需要设置默认值） - models.SET，删除关联数据， a. 与之关联的值设置为指定值，设置：models.SET(值) b. 与之关联的值设置为可执行对象的返回值，设置：models.SET(可执行对象) def func(): return 10 class MyModel(models.Model): user = models.ForeignKey( to="User", to_field="id" on_delete=models.SET(func),) related_name=None, # 反向操作时，使用的字段名，用于代替 【表名_set】 如： obj.表名_set.all() related_query_name=None, # 反向操作时，使用的连接前缀，用于替换【表名】 如： models.UserGroup.objects.filter(表名__字段名=1).values('表名__字段名') limit_choices_to=None, # 在Admin或ModelForm中显示关联数据时，提供的条件： # 如： - limit_choices_to=&#123;'nid__gt': 5&#125; - limit_choices_to=lambda : &#123;'nid__gt': 5&#125; from django.db.models import Q - limit_choices_to=Q(nid__gt=10) - limit_choices_to=Q(nid=8) | Q(nid__gt=10) - limit_choices_to=lambda : Q(Q(nid=8) | Q(nid__gt=10)) &amp; Q(caption='root') db_constraint=True # 是否在数据库中创建外键约束 parent_link=False # 在Admin中是否显示关联数据 OneToOneField(ForeignKey) to, # 要进行关联的表名 to_field=None # 要关联的表中的字段名称 on_delete=None, # 当删除关联表中的数据时，当前表与其关联的行的行为 ###### 对于一对一 ###### # 1. 一对一其实就是 一对多 + 唯一索引 # 2.当两个类之间有继承关系时，默认会创建一个一对一字段 # 如下会在A表中额外增加一个c_ptr_id列且唯一： class C(models.Model): nid = models.AutoField(primary_key=True) part = models.CharField(max_length=12) class A(C): id = models.AutoField(primary_key=True) code = models.CharField(max_length=1)ManyToManyField(RelatedField) to, # 要进行关联的表名 related_name=None, # 反向操作时，使用的字段名，用于代替 【表名_set】 如： obj.表名_set.all() related_query_name=None, # 反向操作时，使用的连接前缀，用于替换【表名】 如： models.UserGroup.objects.filter(表名__字段名=1).values('表名__字段名') limit_choices_to=None, # 在Admin或ModelForm中显示关联数据时，提供的条件： # 如： - limit_choices_to=&#123;'nid__gt': 5&#125; - limit_choices_to=lambda : &#123;'nid__gt': 5&#125; from django.db.models import Q - limit_choices_to=Q(nid__gt=10) - limit_choices_to=Q(nid=8) | Q(nid__gt=10) - limit_choices_to=lambda : Q(Q(nid=8) | Q(nid__gt=10)) &amp; Q(caption='root') symmetrical=None, # 仅用于多对多自关联时，symmetrical用于指定内部是否创建反向操作的字段 # 做如下操作时，不同的symmetrical会有不同的可选字段 models.BB.objects.filter(...) # 可选字段有：code, id, m1 class BB(models.Model): code = models.CharField(max_length=12) m1 = models.ManyToManyField('self',symmetrical=True) # 可选字段有: bb, code, id, m1 class BB(models.Model): code = models.CharField(max_length=12) m1 = models.ManyToManyField('self',symmetrical=False) through=None, # 自定义第三张表时，使用字段用于指定关系表 through_fields=None, # 自定义第三张表时，使用字段用于指定关系表中那些字段做多对多关系表 from django.db import models class Person(models.Model): name = models.CharField(max_length=50) class Group(models.Model): name = models.CharField(max_length=128) members = models.ManyToManyField( Person, through='Membership', through_fields=('group', 'person'), ) class Membership(models.Model): group = models.ForeignKey(Group, on_delete=models.CASCADE) person = models.ForeignKey(Person, on_delete=models.CASCADE) inviter = models.ForeignKey( Person, on_delete=models.CASCADE, related_name="membership_invites", ) invite_reason = models.CharField(max_length=64) db_constraint=True, # 是否在数据库中创建外键约束 db_table=None, # 默认创建第三张表时，数据库中表的名称 三、ORM单表操作1、基本操作12345678910111213141516171819202122# 增# models.Tb1.objects.create(c1='xx', c2='oo') 增加一条数据，可以接受字典类型数据 **kwargs# obj = models.Tb1(c1='xx', c2='oo')# obj.save()# 查# models.Tb1.objects.get(id=123) # 获取单条数据，不存在则报错（不建议）# models.Tb1.objects.all() # 获取全部# models.Tb1.objects.filter(name='seven') # 获取指定条件的数据# 删# models.Tb1.objects.filter(name='seven').delete() # 删除指定条件的数据# 改# models.Tb1.objects.filter(name='seven').update(gender='0') # 将指定条件的数据更新，均支 持 **kwargs# obj = models.Tb1.objects.get(id=1)# obj.c1 = '111'# obj.save() # 修改单条数据 2、进阶操作（了不起的双下划线）利用双下划线将字段和对应的操作连接起来 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778# 获取个数# models.Tb1.objects.filter(name='seven').count()# 大于，小于# models.Tb1.objects.filter(id__gt=1) # 获取id大于1的值# models.Tb1.objects.filter(id__gte=1) # 获取id大于等于1的值# models.Tb1.objects.filter(id__lt=10) # 获取id小于10的值# models.Tb1.objects.filter(id__lte=10) # 获取id小于10的值# models.Tb1.objects.filter(id__lt=10, id__gt=1) # 获取id大于1 且 小于10的值# in# models.Tb1.objects.filter(id__in=[11, 22, 33]) # 获取id等于11、22、33的数据# models.Tb1.objects.exclude(id__in=[11, 22, 33]) # not in# isnull# Entry.objects.filter(pub_date__isnull=True)# contains# models.Tb1.objects.filter(name__contains="ven")# models.Tb1.objects.filter(name__icontains="ven") # icontains大小写不敏感# models.Tb1.objects.exclude(name__icontains="ven")# range# models.Tb1.objects.filter(id__range=[1, 2]) # 范围bettwen and# 其他类似# startswith，istartswith, endswith, iendswith,# order by# models.Tb1.objects.filter(name='seven').order_by('id') # asc# models.Tb1.objects.filter(name='seven').order_by('-id') # desc# group by# from django.db.models import Count, Min, Max, Sum# models.Tb1.objects.filter(c1=1).values('id').annotate(c=Count('num'))# SELECT "app01_tb1"."id", COUNT("app01_tb1"."num") AS "c" FROM "app01_tb1" WHERE "app01_tb1"."c1" = 1 GROUP BY "app01_tb1"."id"# limit 、offset# models.Tb1.objects.all()[10:20]# regex正则匹配，iregex 不区分大小写# Entry.objects.get(title__regex=r'^(An?|The) +')# Entry.objects.get(title__iregex=r'^(an?|the) +')# date# Entry.objects.filter(pub_date__date=datetime.date(2005, 1, 1))# Entry.objects.filter(pub_date__date__gt=datetime.date(2005, 1, 1))# year# Entry.objects.filter(pub_date__year=2005)# Entry.objects.filter(pub_date__year__gte=2005)# month# Entry.objects.filter(pub_date__month=12)# Entry.objects.filter(pub_date__month__gte=6)# day# Entry.objects.filter(pub_date__day=3)# Entry.objects.filter(pub_date__day__gte=3)# week_day# Entry.objects.filter(pub_date__week_day=2)# Entry.objects.filter(pub_date__week_day__gte=2)# hour# Event.objects.filter(timestamp__hour=23)# Event.objects.filter(time__hour=5)# Event.objects.filter(timestamp__hour__gte=12)# minute# Event.objects.filter(timestamp__minute=29)# Event.objects.filter(time__minute=46)# Event.objects.filter(timestamp__minute__gte=29)# second# Event.objects.filter(timestamp__second=31)# Event.objects.filter(time__second=2)# Event.objects.filter(timestamp__second__gte=31) 3、高级操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970 # extra # extra(self, select=None, where=None, params=None, tables=None, order_by=None, select_params=None) # a 映射 # selec=None # select_params=None # select 此处 from 表 # 例： Entry.objects.extra(select=&#123;'new_id': "select col from sometable where othercol &gt; %s"&#125;, select_params=(1,)) # b 条件 # where=None # params=None # select * from 表 where 此处 # 例： Entry.objects.extra(where=['headline=%s'], params=['Lennon']) Entry.objects.extra(where=["foo='a' OR bar = 'a'", "baz = 'a'"]) # c 表 # tables=None # select * from 此处 # 例： Entry.objects.extra(table=[''teacher]) # d 排序 # order_by=None # 例： Entry.objects.extra(select=&#123;'new_id': "select id from tb where id &gt; %s"&#125;, select_params=(1,), order_by=['-nid'])# F # # from django.db.models import F # models.Tb1.objects.update(num=F('num')+1) # Q # # 方式一： # Q(nid__gt=10) # Q(nid=8) | Q(nid__gt=10) # Q(Q(nid=8) | Q(nid__gt=10)) &amp; Q(caption='root') # 方式二： # con = Q() # q1 = Q() # q1.connector = 'OR' # q1.children.append(('id', 1)) # q1.children.append(('id', 10)) # q1.children.append(('id', 9)) # q2 = Q() # q2.connector = 'OR' # q2.children.append(('c1', 1)) # q2.children.append(('c1', 10)) # q2.children.append(('c1', 9)) # con.add(q1, 'AND') # con.add(q2, 'AND') # # models.Tb1.objects.filter(con) # 执行原生SQL # # from django.db import connection, connections # cursor = connection.cursor() # cursor = connections['default'].cursor() # cursor.execute("""SELECT * from auth_user where id = %s""", [1]) # row = cursor.fetchone() 4、其他操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220################################################################### PUBLIC METHODS THAT ALTER ATTRIBUTES AND RETURN A NEW QUERYSET ###################################################################def all(self) # 获取所有的数据对象def filter(self, *args, **kwargs) # 条件查询 # 条件可以是：参数，字典，Qdef exclude(self, *args, **kwargs) # 条件查询 # 条件可以是：参数，字典，Qdef select_related(self, *fields) 性能相关：表之间进行join连表操作，一次性获取关联的数据。 model.tb.objects.all().select_related() model.tb.objects.all().select_related('外键字段') model.tb.objects.all().select_related('外键字段__外键字段')def prefetch_related(self, *lookups) 性能相关：多表连表操作时速度会慢，使用其执行多次SQL查询在Python代码中实现连表操作。 # 获取所有用户表 # 获取用户类型表where id in (用户表中的查到的所有用户ID) models.UserInfo.objects.prefetch_related('外键字段') from django.db.models import Count, Case, When, IntegerField Article.objects.annotate( numviews=Count(Case( When(readership__what_time__lt=treshold, then=1), output_field=CharField(), )) ) students = Student.objects.all().annotate(num_excused_absences=models.Sum( models.Case( models.When(absence__type='Excused', then=1), default=0, output_field=models.IntegerField() )))def annotate(self, *args, **kwargs) # 用于实现聚合group by查询 from django.db.models import Count, Avg, Max, Min, Sum v = models.UserInfo.objects.values('u_id').annotate(uid=Count('u_id')) # SELECT u_id, COUNT(ui) AS `uid` FROM UserInfo GROUP BY u_id v = models.UserInfo.objects.values('u_id').annotate(uid=Count('u_id')).filter(uid__gt=1) # SELECT u_id, COUNT(ui_id) AS `uid` FROM UserInfo GROUP BY u_id having count(u_id) &gt; 1 v = models.UserInfo.objects.values('u_id').annotate(uid=Count('u_id',distinct=True)).filter(uid__gt=1) # SELECT u_id, COUNT( DISTINCT ui_id) AS `uid` FROM UserInfo GROUP BY u_id having count(u_id) &gt; 1def distinct(self, *field_names) # 用于distinct去重 models.UserInfo.objects.values('nid').distinct() # select distinct nid from userinfo 注：只有在PostgreSQL中才能使用distinct进行去重def order_by(self, *field_names) # 用于排序 models.UserInfo.objects.all().order_by('-id','age')def extra(self, select=None, where=None, params=None, tables=None, order_by=None, select_params=None) # 构造额外的查询条件或者映射，如：子查询 Entry.objects.extra(select=&#123;'new_id': "select col from sometable where othercol &gt; %s"&#125;, select_params=(1,)) Entry.objects.extra(where=['headline=%s'], params=['Lennon']) Entry.objects.extra(where=["foo='a' OR bar = 'a'", "baz = 'a'"]) Entry.objects.extra(select=&#123;'new_id': "select id from tb where id &gt; %s"&#125;, select_params=(1,), order_by=['-nid']) def reverse(self): # 倒序 models.UserInfo.objects.all().order_by('-nid').reverse() # 注：如果存在order_by，reverse则是倒序，如果多个排序则一一倒序 def defer(self, *fields): models.UserInfo.objects.defer('username','id') 或 models.UserInfo.objects.filter(...).defer('username','id') #映射中排除某列数据 def only(self, *fields): #仅取某个表中的数据 models.UserInfo.objects.only('username','id') 或 models.UserInfo.objects.filter(...).only('username','id') def using(self, alias): 指定使用的数据库，参数为别名（setting中的设置）################################################### PUBLIC METHODS THAT RETURN A QUERYSET SUBCLASS ###################################################def raw(self, raw_query, params=None, translations=None, using=None): # 执行原生SQL models.UserInfo.objects.raw('select * from userinfo') # 如果SQL是其他表时，必须将名字设置为当前UserInfo对象的主键列名 models.UserInfo.objects.raw('select id as nid from 其他表') # 为原生SQL设置参数 models.UserInfo.objects.raw('select id as nid from userinfo where nid&gt;%s', params=[12,]) # 将获取的到列名转换为指定列名 name_map = &#123;'first': 'first_name', 'last': 'last_name', 'bd': 'birth_date', 'pk': 'id'&#125; Person.objects.raw('SELECT * FROM some_other_table', translations=name_map) # 指定数据库 models.UserInfo.objects.raw('select * from userinfo', using="default") ################### 原生SQL ################### from django.db import connection, connections cursor = connection.cursor() # cursor = connections['default'].cursor() cursor.execute("""SELECT * from auth_user where id = %s""", [1]) row = cursor.fetchone() # fetchall()/fetchmany(..)def values(self, *fields): # 获取每行数据为字典格式def values_list(self, *fields, **kwargs): # 获取每行数据为元祖def dates(self, field_name, kind, order='ASC'): # 根据时间进行某一部分进行去重查找并截取指定内容 # kind只能是："year"（年）, "month"（年-月）, "day"（年-月-日） # order只能是："ASC" "DESC" # 并获取转换后的时间 - year : 年-01-01 - month: 年-月-01 - day : 年-月-日 models.DatePlus.objects.dates('ctime','day','DESC')def datetimes(self, field_name, kind, order='ASC', tzinfo=None): # 根据时间进行某一部分进行去重查找并截取指定内容，将时间转换为指定时区时间 # kind只能是 "year", "month", "day", "hour", "minute", "second" # order只能是："ASC" "DESC" # tzinfo时区对象 models.DDD.objects.datetimes('ctime','hour',tzinfo=pytz.UTC) models.DDD.objects.datetimes('ctime','hour',tzinfo=pytz.timezone('Asia/Shanghai')) """ pip3 install pytz import pytz pytz.all_timezones pytz.timezone(‘Asia/Shanghai’) """def none(self): # 空QuerySet对象##################################### METHODS THAT DO DATABASE QUERIES #####################################def aggregate(self, *args, **kwargs): # 聚合函数，获取字典类型聚合结果 from django.db.models import Count, Avg, Max, Min, Sum result = models.UserInfo.objects.aggregate(k=Count('u_id', distinct=True), n=Count('nid')) ===&gt; &#123;'k': 3, 'n': 4&#125;def count(self): # 获取个数def get(self, *args, **kwargs): # 获取单个对象def create(self, **kwargs): # 创建对象def bulk_create(self, objs, batch_size=None): # 批量插入 # batch_size表示一次插入的个数 objs = [ models.DDD(name='r11'), models.DDD(name='r22') ] models.DDD.objects.bulk_create(objs, 10)def get_or_create(self, defaults=None, **kwargs): # 如果存在，则获取，否则，创建 # defaults 指定创建时，其他字段的值 obj, created = models.UserInfo.objects.get_or_create(username='root1', defaults=&#123;'email': '1111111','u_id': 2, 't_id': 2&#125;)def update_or_create(self, defaults=None, **kwargs): # 如果存在，则更新，否则，创建 # defaults 指定创建时或更新时的其他字段 obj, created = models.UserInfo.objects.update_or_create(username='root1', defaults=&#123;'email': '1111111','u_id': 2, 't_id': 1&#125;)def first(self): # 获取第一个def last(self): # 获取最后一个def in_bulk(self, id_list=None): # 根据主键ID进行查找 id_list = [11,21,31] models.DDD.objects.in_bulk(id_list)def delete(self): # 删除def update(self, **kwargs): # 更新def exists(self): # 是否有结果 4、连表操作（了不起的双下划线）利用双下划线和 _set 将表之间的操作连接起来 表结构实例 12345678910111213141516171819202122232425262728293031323334353637383940class UserProfile(models.Model): user_info = models.OneToOneField('UserInfo') username = models.CharField(max_length=64) password = models.CharField(max_length=64) def __unicode__(self): return self.usernameclass UserInfo(models.Model): user_type_choice = ( (0, u'普通用户'), (1, u'高级用户'), ) user_type = models.IntegerField(choices=user_type_choice) name = models.CharField(max_length=32) email = models.CharField(max_length=32) address = models.CharField(max_length=128) def __unicode__(self): return self.nameclass UserGroup(models.Model): caption = models.CharField(max_length=64) user_info = models.ManyToManyField('UserInfo') def __unicode__(self): return self.captionclass Host(models.Model): hostname = models.CharField(max_length=64) ip = models.GenericIPAddressField() user_group = models.ForeignKey('UserGroup') def __unicode__(self): return self.hostname 一对一操作 12345678user_info_obj = models.UserInfo.objects.filter(id=1).first()print user_info_obj.user_typeprint user_info_obj.get_user_type_display()print user_info_obj.userprofile.password user_info_obj = models.UserInfo.objects.filter(id=1).values('email', 'userprofile__username').first()print user_info_obj.keys()print user_info_obj.values() 一对多 123类似一对一1、搜索条件使用 __ 连接2、获取值时使用 . 连接 多对多操作 123456789101112131415161718192021222324252627282930user_info_obj = models.UserInfo.objects.get(name=u'武沛齐')user_info_objs = models.UserInfo.objects.all() group_obj = models.UserGroup.objects.get(caption='CEO')group_objs = models.UserGroup.objects.all() # 添加数据#group_obj.user_info.add(user_info_obj)#group_obj.user_info.add(*user_info_objs) # 删除数据#group_obj.user_info.remove(user_info_obj)#group_obj.user_info.remove(*user_info_objs) # 添加数据#user_info_obj.usergroup_set.add(group_obj)#user_info_obj.usergroup_set.add(*group_objs) # 删除数据#user_info_obj.usergroup_set.remove(group_obj)#user_info_obj.usergroup_set.remove(*group_objs) # 获取数据#print group_obj.user_info.all()#print group_obj.user_info.all().filter(id=1) # 获取数据#print user_info_obj.usergroup_set.all()#print user_info_obj.usergroup_set.all().filter(caption='CEO')#print user_info_obj.usergroup_set.all().filter(caption='DBA')]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>ORM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django之路由系统]]></title>
    <url>%2F2018%2F12%2F21%2FDjango%E4%B9%8B%E8%B7%AF%E7%94%B1%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[路由系统简而言之，django的路由系统作用就是使views里面处理数据的函数与请求的url建立映射关系。使请求到来之后，根据urls.py里的关系条目，去查找到与请求对应的处理方法，从而返回给客户端http页面数据 Django2.0中，url得匹配规则更新了，在django1.0中，url是用正则表达式书写得，相对来说比较繁琐一些，在django2.0中进行了升级优化，描写url配置的有两个函数path和re_path django 项目中的url规则定义放在project 的urls.py目录下，默认如下： 123456from django.conf.urls import pathfrom django.contrib import adminurlpatterns = [ path('admin/', admin.site.urls)] path()函数 path() 具有四个参数，两个必须参数：route 和 view，两个可选参数：kwargs 和 name。即路由和视图是必填参数。 那么与旧版本的参数主要区别就在于url()是要写正则表达式（regex）的路由，而path()是写的非正则路由（route），接下来主要看一下path()函数的四个参数含义。 1234567891、path()参数：route route 是一个匹配URL的准则（类似正则表达式）。当Django响应一个请求时，它会从urlpatterns的第一项开始，按顺序依次匹配列表中的项，直到找到匹配的项。 这些准则不会匹配GET和POST参数或域名。例如，URLconf在处理请求https://www.example.com/myapp/时，它会尝试匹配myapp/。处理请求https://www.example.com/myapp/?page=3 时，也只会尝试匹配 myapp/。2、path()参数：view 当 Django 找到了一个匹配的准则，就会调用这个特定的视图函数，并传入一个HttpRequest对象作为第一个参数，被“捕获”的参数以关键字参数的形式传入。3、path()参数：kwargs 任意个关键字参数可以作为一个字典传递给目标视图函数。4、path()参数：name 为你的URL取名能使你在 Django 的任意地方唯一地引用它，尤其是在模板中。这个有用的特性允许你只改一个文件就能全局地修改某个URL模式。 上面介绍的path中，第一个参数route使用的是非正则表达式可以表示的普通路由路径。 注意： 要从URL捕获值，请使用尖括号。 捕获的值可以选择包括转换器类型。例如，用于 &lt;int:name&gt;捕获整数参数。如果未包含转换器/，则匹配除字符之外的任何字符串。 没有必要添加前导斜杠，因为每个URL都有。例如，它articles不是/articles。 默认情况下，以下路径转换器可用： str- 匹配除路径分隔符之外的任何非空字符串&#39;/&#39;。如果转换器未包含在表达式中，则这是默认值。 int - 匹配零或任何正整数。返回一个int。 slug - 匹配由ASCII字母或数字组成的任何slug字符串，以及连字符和下划线字符。例如， building-your-1st-django-site。 uuid - 匹配格式化的UUID。要防止多个URL映射到同一页面，必须包含短划线并且字母必须为小写。例如，075194d3-6885-417e-a8a8-6c931e272f00。返回一个 UUID实例。 path- 匹配任何非空字符串，包括路径分隔符 &#39;/&#39;。这使您可以匹配完整的URL路径，而不仅仅是URL路径的一部分str。 比如要匹配一个视图中的函数路由，该函数有两个形参： def peopleList(request,book_id) 第一个request是默认的，那么路径自动匹配该函数的第二个形参，匹配格式：int:book_id，并返回一个正整数或零值。 re_path()而如果遇上路径和转换器语法都不足以定义的URL模式，那么就需要使用正则表达式，这时候就需要使用re_path()，而非path()。 1from django.urls import re_path 在Python正则表达式中，命名正则表达式组的语法是(?P&lt;name&gt;pattern)，组name的名称，并且 pattern是要匹配的模式。 还是以上图圈中的部分为例，也是可以用正则表达式来写的。如下： 1re_path(r'^(\d+)/$',views.peopleList,name='peopleList'), 这样也是可以匹配到views视图中的peopleList函数的形参的。 所以这两种使用方式在使用上根据实际情况自行使用。 按照顺序放置的动态路由可以使用正则来匹配URL，将一组url使用一条映射搞定 1234urlpatterns = [ re_path(r'^host/(\d+)$', views.host), re_path(r'^host_list/(\d+)/(\d+)$', views.host_list), ] \^host_list/(\d+)/(\d+)$ 相对应的url是： ”http://127.0.0.1/host/8/9“，匹配到的数字会以参数的形式按照顺序传递给views里面相对应的函数在views.host_list中需要指定两个形式参数,注意：此参数的顺序严格按照url中匹配的顺序 12def user_list(request,hid,hid2): return HttpResponse(hid+hid2) 传参形势的路由利用正则表达式的分组方法，以参数的形式传递到函数，可以不按顺序排列 123urlpatterns = [ re_path(r'^user_list/(?P&lt;v1&gt;\d+)/(?P&lt;v2&gt;\d+)$',views.user_list), ] 然后将此参数传递到views里对应的函数，可以不按照顺序 12345def user_list(request,v2,v1): return HttpResponse(v1+v2)参数v1 = (?P&lt;v1&gt;\d+)参数v2 = (?P&lt;v2&gt;\d+) 路由分发如果一个项目下有很多的app，那么在urls.py里面就要写巨多的urls映射关系。这样看起来很不灵活，而且杂乱无章。我们可以根据不同的app来分类不同的url请求。首先，在urls.py里写入urls映射条目。注意要导入include方法 123456789from django.conf.urls import include, urlfrom django.contrib import adminurlpatterns = [ path('app01/', include('app01.urls')), path('app02/', include('app02.urls')),] 这条关系的意思是将url为”app01/“的请求都交给app01下的urls去处理 其次，在app01下创建一个urls.py文件，用来处理请求的url，使之与views建立映射 12345678from django.conf.urls import include, urlfrom app01 import viewsurlpatterns = [ path('index/', views.index),] 想对于url请求为： “http://127.0.0.1/app01/index/“ 命名空间a. project.urls.py 123456from django.conf.urls import url,include urlpatterns = [ url(r'^a/', include('app01.urls', namespace='author-polls')), url(r'^b/', include('app01.urls', namespace='publisher-polls')),] b. app01.urls.py 1234567from django.conf.urls import urlfrom app01 import views app_name = 'app01'urlpatterns = [ url(r'^(?P&lt;pk&gt;\d+)/$', views.detail, name='detail')] c. app01.views.py 123def detail(request, pk): print(request.resolver_match) return HttpResponse(pk) 以上定义带命名空间的url之后，使用name生成URL时候，应该如下： 12v = reverse('app01:detail', kwargs=&#123;'pk':11&#125;)&#123;% url 'app01:detail' pk=12 pp=99 %&#125; django中的路由系统和其他语言的框架有所不同，在django中每一个请求的url都要有一条路由映射，这样才能将请求交给对一个的view中的函数去处理。其他大部分的Web框架则是对一类的url请求做一条路由映射，从而是路由系统变得简洁。]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>路由系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django简介]]></title>
    <url>%2F2018%2F12%2F20%2FDjango%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[MVC与MTV模型MVC百度百科：全名Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。 通俗解释：一种文件的组织和管理形式！不要被缩写吓到了，这其实就是把不同类型的文件放到不同的目录下的一种方法，然后取了个高大上的名字。当然，它带来的好处有很多，比如前后端分离，松耦合等等。 MTV: 有些WEB框架觉得MVC的字面意思很别扭，就给它改了一下。view不再是HTML相关，而是主业务逻辑了，相当于控制器。html被放在Templates中，称作模板，于是MVC就变成了MTV。这其实就是一个文字游戏，和MVC本质上是一样的，换了个名字和叫法而已，换汤不换药。 MVCWeb服务器开发领域里著名的MVC模式，将web应用分为以下三层：模型(Model)视图(View)控制器(Controller)以上三层之间以一种插件式的、松耦合的方式连接在一起：模型负责业务对象与数据库的映射(ORM)视图负责与用户的交互(页面)控制器接受用户的输入调用模型和视图完成用户的请求。 其示意图如下所示： MTVDjango的MTV模式本质上和MVC是一样的，也是为了各组件间保持松耦合关系，只是定义上有些许不同，Django的MTV分别是指： 123M 代表模型（Model）： 负责业务对象和数据库的关系映射(ORM)。T 代表模板 (Template)：负责如何把页面展示给用户(html)。V 代表视图（View）： 负责业务逻辑，并在适当时候调用Model和Template。 除了以上三层之外，还需要一个URL分发器，它的作用是将一个个URL的页面请求分发给不同的View处理，View再调用相应的Model和Template，MTV的响应模式如下所示： 用户通过浏览器向我们的服务器发起一个请求(request)，这个请求会去访问视图函数，（如果不涉及到数据调用，那么这个时候视图函数返回一个模板也就是一个网页给用户），视图函数调用模型，模型去数据库查找数据，然后逐级返回，视图函数把返回的数据填充到模板中，最后返回网页给用户。 Django 的MTV模型组织 Django项目实例安装python3.5、pip3及pycharm专业版可自行安装。例：windows cmd命令行自动安装Pypi提供的最新版本。pip3 install django 配置环境变量成功安装Djangio后，如有需要，可以将python的Scripts目录加入到系统环境变量中，以便调用django-admin命令。 配置完成后，可直接在cmd任一路径下运行django-admin help命令测试安装和配置完成： 创建django项目和应用在windows cmd命令行界面下，使用diango提供的命令创建diango项目如下：django-admin startproject mysite其中mysite是项目名称，可自行替换成你想建立的项目名。而在该项目下创建应用的命令是：python manage.py startapp blog其中blog为app，应用名称，可自行替换成你想建立的应用名称。 启动django项目的命令为：python manage.py runserver 8080`runserver 默认为本机（127.0.0.1）,后面跟的8080为端口号，可根据实际环境替换。 这样一个简单的原始的django就启动起来了，我们到浏览器输入127.0.0.1:8080实际上访问的就是django的这个项目，如图： 一般开发使用pycharm（IDE）操作是点击file-new project，选择Django栏目；右侧选择项目所在路径，选择项目使用的python版本环境（可选虚拟环境），注意Location中选择项目路径的同时所选的目录也就是项目的名称，More Settings栏可设置模板文件夹名，web应用名称，勾选自动创建相关web应用文件夹等。 点击右下方的Create按钮创建。 Django自动生成类似下面的目录结构： 和项目同名的文件夹中存放的是 settings.py 配置文件； urls.py url路由文件； wsgi.py 网络通信接口模块； templates模板目录下为空，此目录主要用于存放各个html模板文件。 项目根目录下的manage.py文件为django项目的管理主程序，工具等。 各个应用目录（如我这边的创建的应用名为app01）下存放主要有： views.py 为处理业务逻辑； tests.py 为单元测试； modes.py 为处理数据库； 推荐在项目根目录下自行建立起一个static的静态文件，用于存放css，js，img，html等静态文件。 在每个Django项目中可以包含多个APP，相当于一个大型项目中的分系统、子模块、功能部件等等，相互之间比较独立，但也可以有联系。 所有的APP共享项目资源。 编写路由（url控制器）路由由urls文件进行处理，功能是将浏览器输入的url映射到相应的(views)业务处理逻辑。由于和业务处理逻辑相关，也就是和views相关，所以在文件开头就需要先导入对应app的views.py文件。 例：没做增添之前的urls.py(包括了官方注释） 123456789101112131415161718192021"""tielemao URL ConfigurationThe `urlpatterns` list routes URLs to views. For more information please see: https://docs.djangoproject.com/en/2.0/topics/http/urls/Examples:Function views 1. Add an import: from my_app import views 2. Add a URL to urlpatterns: path('', views.home, name='home')Class-based views 1. Add an import: from other_app.views import Home 2. Add a URL to urlpatterns: path('', Home.as_view(), name='home')Including another URLconf 1. Import the include() function: from django.urls import include, path 2. Add a URL to urlpatterns: path('blog/', include('blog.urls'))"""from django.contrib import adminfrom django.urls import pathurlpatterns = [ path('admin/', admin.site.urls),] 增添路由条目后： 123456789101112from django.contrib import adminfrom django.urls import path# 需先导入对应的app目录中的views文件from app01 import viewsurlpatterns = [ # admin为后台管理的路由，一般不会暴露出来，注释掉居多 # path('admin/', admin.site.urls), # 自己新增的路由条目，前半部分表示路径的为正则表达式，后半部分为对应的业务逻辑函数 path('index/', views.index),] 编写业务处理逻辑（views视图函数）urls.py中增添的路由条目中对应了相应的自己命名的业务逻辑函数，也就是接下来你就需要为此在相应的views.py文件增添上相应的视图函数。 原始的views.py文件： 123from django.shortcuts import render# Create your views here. 增添相应函数后： 1234567891011121314151617from django.shortcuts import render# 导入HttpResponse模块from django.shortcuts import HttpResponse# Create your views here.# request参数按规范必須有，类似self的默认存在，名字可以改，但不建议。# 它里面封装了用户请求的所有内容。def index(request): # 可以print打印request.POST或request.GET来查看到请求 # print(request.POST) # print(request.GET) # 正常是不能直接返回字符串，必須使用Django提供的HttpResponse # 这个类封装起来就可以返回字符串了，这是Django的规则，不是python的。 return HttpResponse("hello world!") 通过上面两个简单的步骤，将index这个url指向了views里的index（）函数，它接收用户请求，并返回一个“hello world”字符串。我们就可以启动web服务演示一下了。 运行web服务 命令行方式：python manage.py runserver 127.0.0.1:8000 pycharm中可以通过在工具栏中找到编辑配置文件的选项，快速进行设置host和port后再点击绿色三角形进行运行： 运行效果： 在浏览器中访问http://127.0.0.1:8000 此时会出现404的错误信息，因为此时我们访问的地址并不是index/,在开发过程中，Django给出的这些错误信息很重要，仔细阅读方便排错，但一旦正式上线生产环境，就一定要关掉如此详细的调错信息功能，常见的错误就自己另写html报错页面。 在地址栏中输入http://127.0.0.1:8000/index/，访问才会出现己设置好的正常显示的hello world！ 返回HTML上面例子返回给用户的是一个字符串，真正的web应用肯定是不会这样做的，通常返回的都应该是一个HTML文件给用户。那么，我们写如下showtime函数和time.html的HTML文件，做为一个用户访问获取当前时间的功能例子： urls.py代码如下： 1234567891011121314from django.contrib import adminfrom django.urls import path# 需先导入对应的app目录中的views文件from app01 import viewsurlpatterns = [ # admin为后台管理的路由，一般不会暴露出来，注释掉居多 path('admin/', admin.site.urls), # 自己新增的路由条目，前半部分表示路径的为正则表达式，后半部分为对应的业务逻辑函数 path('index/', views.index), # 新增用户访问time/路由,获取当前时间函数 path('time/', views.showtime),] views.py代码如下，增加一个showtime函数： 123456789101112131415161718192021from django.shortcuts import render# 导入HttpResponse模块from django.shortcuts import HttpResponse# 导入时间模块import datetime# Create your views here.# request参数按规范必須有，类似self的默认存在，名字可以改，但不建议。# 它里面封装了用户请求的所有内容。def index(request): # 正常是不能直接返回字符串，必須使用Django提供的HttpResponse # 这个类封装起来就可以返回字符串了，这是Django的规则，不是python的。 return HttpResponse("hello world!")def showtime(request): now=datetime.datetime.now() ctime=now.strftime("%Y-%m-%d %X") return render(request, "time.html", &#123;"ctime":ctime&#125;) request,它是一个对象。当中存储了请求信息，比如请求路径，请求方式，GET数据，POST数据…等等。必须要接收一个request参数。当你想返回一个html文件时，不是使用HttpResponse方法，而是使用render方法来渲染（打包）。 不过本质上render最终还是使用了HttpResponse方法发送byte字节给浏览器的。 模板templates目录下，新建一个time.html: 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &#123;# 由两个大括号括起来里面加个变量名，相当于是字典的键名，是django用于占位输出的语法 #&#125; &lt;h3&gt;当前时间：&#123;&#123; ctime &#125;&#125;&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; 访问效果如下： settings.py设置模板文件夹settings.py文件中有TEMPLATES变量，它是一个列表，列表中又存放了一个字典，其中一个键值对&#39;DIRS&#39;:[os.path.join(BASE_DIR, &#39;templates&#39;)] 效果就是默认设置了模板目录是使用默认的项目文件夹下的templates目录。如果有特殊需要修改的就是在此改动。另外django有一个好处，代码更改之后，一般无需重启web服务，它会自动加载最新代码。 12345678910111213141516TEMPLATES = [ &#123; 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [os.path.join(BASE_DIR, 'templates')] , 'APP_DIRS': True, 'OPTIONS': &#123; 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], &#125;, &#125;,] 使用静态文件将html文件返回给用户还不够，前端三大块，HTML、CSS、JS还有各种插件等，完整齐全才是一个好看的页面。在django中，一般将静态文件放在static目录中。接下来，在项目根目录下新建一个static目录。 同时，我还在此目录下建立起js，css，img子目录和相关文件，如图： static这个静态目录名和Django默认设置的静态目录名别名一致，在settings.py中可找到相关设置项，就是在结尾处再添加上新的一行表示告诉Django静态目录的路径： 1234567891011121314# Static files (CSS, JavaScript, Images)# https://docs.djangoproject.com/en/2.0/howto/static-files/STATIC_URL = '/static/'# STATIC_URL表示的是引用别名（指针），不是具体的目录# 可以改成你想指定的名字，但是在相应的引用地方必須和它对应到# 增加以下一段表示设置静态目录的路径STATICFILES_DIRS = ( os.path.join(BASE_DIR, 'static'),)# 真实目录名不要在html中写死，而是写成别名引用，# 如此，目录名就算有改动也只需改动此处即可。# 另外，由于此行是一个元组，别忘了后面还需加个逗号。 同理，在html文件中引用静态文件，例如jquery.js文件如下： 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &#123;# 由两个大括号括起来里面加个变量名，相当于是字典的键名，是django用于占位输出的语法 #&#125; &lt;h3&gt;当前时间：&#123;&#123; ctime &#125;&#125;&lt;/h3&gt; &lt;script src="/static/js/jquery.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;--------------------- 主要看&lt;script src=&quot;/static/js/jquery.js&quot;&gt;&lt;/script&gt;这一行，里面的路径并没有写死，而是使用了static/来代指了真实的静态目录。 接收用户发送的数据（get和post请求）至此，我们做到了将一个要素齐全的HTML文件返还给了用户浏览器。但这还不够，因为web服务器和用户之间还没有动态交互。下面我们来设计一个login页面，上面建立一个表单，让用户输入用户名和密码，提交给login这个url，服务器将接收到这些数据。 login.html 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;登录&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action="" method="post"&gt; &#123;# 注意Django中有一个跨站请求保护机制，所以需要加以下一行 #&#125; &#123;% csrf_token %&#125; 用户名：&lt;input type="text" name="user" /&gt; 密码：&lt;input type="password" name="pwd" /&gt; &lt;input type="submit" value="提交" /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;！ 这其中牵涉到一个csrf的防护机制 CSRF百度百科：CSRF（Cross-site request forgery）跨站请求伪造，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。尽管听起来像跨站脚本（XSS），但它与XSS非常不同，XSS利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求来利用受信任的网站。与XSS攻击相比，CSRF攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比XSS更具危险性。 假如没有加这一行防护，运行时将会报如下图的错误： urls.py中urlpatterns添加路由条目：path(&#39;login/&#39;, views.login), views.py中添加login函数： 123456def login(request): if request.method=="POST": username = request.POST.get("user", None) password = request.POST.get("pwd", None) print("用户名：", username,"密码", password) return render(request, "login.html") 此逻辑处理将会在pycharm中可以看到用户输入的用户名密码。 运行效果如下：html页面效果： pycharm后端效果： pycharm中可以看到提交后的post请求数据后端都获取到了。 返回动态页面我们收到了用户的数据，但返回给用户的依然是个静态页面，通常页面会根据用户的数据，进行处理后在返回给用户。django采用自己的模板语言，类似jinja2，可根据提供的数据，替换掉HTML中的相应部分。 例：views.py文件修改如下： 123456789101112131415# 创建一个用户信息表，预设了两个数据，将返回给浏览器展示给用户user_list = [ &#123;"user":"tielemao", "pwd":"12345"&#125;, &#123;"user":"LiLei", "pwd":"abc123"&#125;,]def login(request): if request.method=="POST": username = request.POST.get("user", None) password = request.POST.get("pwd", None) temp = &#123;"user":username, "pwd":password&#125; user_list.append(temp) return render(request, "login.html", &#123;"data":user_list&#125;)# render接收的第三个参数是后台返回给浏览器的数据，一个字典。# data是字典的键，是你在login.html中自定义的指针名字，对应引用值。 而login.html相应修改： 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;登录&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action="" method="post"&gt; &#123;# 注意Django中有一个跨站请求保护机制，所以需要加以下一行 #&#125; &#123;% csrf_token %&#125; 用户名：&lt;input type="text" name="user" /&gt; 密码：&lt;input type="password" name="pwd" /&gt; &lt;input type="submit" value="提交" /&gt; &lt;/form&gt; &lt;h2&gt;用户列表&lt;/h2&gt; &lt;table border="1"&gt; &lt;thead&gt; &lt;th&gt;用户名&lt;/th&gt; &lt;th&gt;密码&lt;/th&gt; &lt;/thead&gt; &lt;tbody&gt; &#123;% for line in data %&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123; line.user &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; line.pwd &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/tbody&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; login.html中利用for循环将data(引用）迭代填入数据到表格。访问页面并输入一些数据测试效果如下： 效果就是用户列表会随着提交的数据而发生变化，算是一个简单的动态页面， 和用户的交户过程。 使用数据库Django默认使用的是Sqlite，要使用mysql的话需要修改以下配置 修改settings.py文件 12345678910DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME':'dbname', 'USER': 'root', 'PASSWORD': 'xxx', 'HOST': '', 'PORT': '', &#125;&#125; 123456# 由于Django内部连接MySQL时使用的是MySQLdb模块，而python3中还无此模块，所以需要使用pymysql来代替 # 如下设置放置的与project同名的配置的 __init__.py文件中 import pymysqlpymysql.install_as_MySQLdb()]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python操作mysql]]></title>
    <url>%2F2018%2F12%2F16%2Fpython%E6%93%8D%E4%BD%9Cmysql%2F</url>
    <content type="text"><![CDATA[本篇对于Python操作MySQL主要使用两种方式： 原生模块 pymsql ORM框架 SQLAchemy pymsqlpymsql是Python中操作MySQL的模块，其使用方法和MySQLdb几乎相同。 下载安装1pip3 install pymysql 使用操作1、执行SQL 1234567891011121314151617181920212223242526#!/usr/bin/env python# -*- coding:utf-8 -*-import pymysql # 创建连接conn = pymysql.connect(host='127.0.0.1', port=3306, user='root', passwd='123', db='t1')# 创建游标cursor = conn.cursor() # 执行SQL，并返回收影响行数effect_row = cursor.execute("update hosts set host = '1.1.1.2'") # 执行SQL，并返回受影响行数#effect_row = cursor.execute("update hosts set host = '1.1.1.2' where nid &gt; %s", (1,)) # 执行SQL，并返回受影响行数#effect_row = cursor.executemany("insert into hosts(host,color_id)values(%s,%s)", [("1.1.1.11",1),("1.1.1.11",2)]) # 提交，不然无法保存新建或者修改的数据conn.commit() # 关闭游标cursor.close()# 关闭连接conn.close() 2、获取新创建数据自增ID 12345678910111213#!/usr/bin/env python# -*- coding:utf-8 -*-import pymysql conn = pymysql.connect(host='127.0.0.1', port=3306, user='root', passwd='123', db='t1')cursor = conn.cursor()cursor.executemany("insert into hosts(host,color_id)values(%s,%s)", [("1.1.1.11",1),("1.1.1.11",2)])conn.commit()cursor.close()conn.close() # 获取最新自增IDnew_id = cursor.lastrowid 3、获取查询数据 12345678910111213141516171819#!/usr/bin/env python# -*- coding:utf-8 -*-import pymysql conn = pymysql.connect(host='127.0.0.1', port=3306, user='root', passwd='123', db='t1')cursor = conn.cursor()cursor.execute("select * from hosts") # 获取第一行数据row_1 = cursor.fetchone() # 获取前n行数据# row_2 = cursor.fetchmany(3)# 获取所有数据# row_3 = cursor.fetchall() conn.commit()cursor.close()conn.close() 注：在fetch数据时按照顺序进行，可以使用cursor.scroll(num,mode)来移动游标位置，如： cursor.scroll(1,mode=’relative’) # 相对当前位置移动 cursor.scroll(2,mode=’absolute’) # 相对绝对位置移动 4、fetch数据类型 关于默认获取的数据是元祖类型，如果想要或者字典类型的数据，即： 123456789101112131415#!/usr/bin/env python# -*- coding:utf-8 -*-import pymysql conn = pymysql.connect(host='127.0.0.1', port=3306, user='root', passwd='123', db='t1') # 游标设置为字典类型cursor = conn.cursor(cursor=pymysql.cursors.DictCursor)r = cursor.execute("call p1()") result = cursor.fetchone() conn.commit()cursor.close()conn.close() SQLAchemySQLAlchemy是Python编程语言下的一款ORM框架，该框架建立在数据库API之上，使用关系对象映射进行数据库操作，简言之便是：将对象转换成SQL，然后使用数据API执行SQL并获取执行结果。 安装： 1pip3 install SQLAlchemy SQLAlchemy本身无法操作数据库，其必须以来pymsql等第三方插件，Dialect用于和数据API进行交流，根据配置文件的不同调用不同的数据库API，从而实现对数据库的操作，如： 12345678910111213MySQL-Python mysql+mysqldb://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;[:&lt;port&gt;]/&lt;dbname&gt; pymysql mysql+pymysql://&lt;username&gt;:&lt;password&gt;@&lt;host&gt;/&lt;dbname&gt;[?&lt;options&gt;] MySQL-Connector mysql+mysqlconnector://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;[:&lt;port&gt;]/&lt;dbname&gt; cx_Oracle oracle+cx_oracle://user:pass@host:port/dbname[?key=value&amp;key=value...] 更多详见：http://docs.sqlalchemy.org/en/latest/dialects/index.html 一、内部处理使用 Engine/ConnectionPooling/Dialect 进行数据库操作，Engine使用ConnectionPooling连接数据库，然后再通过Dialect执行SQL语句。 1234567891011121314151617181920212223242526272829303132333435#!/usr/bin/env python# -*- coding:utf-8 -*-from sqlalchemy import create_engine engine = create_engine("mysql+pymysql://root:123@127.0.0.1:3306/t1", max_overflow=5) # 执行SQL# cur = engine.execute(# "INSERT INTO hosts (host, color_id) VALUES ('1.1.1.22', 3)"# ) # 新插入行自增ID# cur.lastrowid # 执行SQL# cur = engine.execute(# "INSERT INTO hosts (host, color_id) VALUES(%s, %s)",[('1.1.1.22', 3),('1.1.1.221', 3),]# ) # 执行SQL# cur = engine.execute(# "INSERT INTO hosts (host, color_id) VALUES (%(host)s, %(color_id)s)",# host='1.1.1.99', color_id=3# ) # 执行SQL# cur = engine.execute('select * from hosts')# 获取第一行数据# cur.fetchone()# 获取第n行数据# cur.fetchmany(3)# 获取所有数据# cur.fetchall() 二、ORM功能使用使用 ORM/Schema Type/SQL Expression Language/Engine/ConnectionPooling/Dialect 所有组件对数据进行操作。根据类创建对象，对象转换成SQL，执行SQL。 1、创建表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#!/usr/bin/env python# -*- coding:utf-8 -*-from sqlalchemy.ext.declarative import declarative_basefrom sqlalchemy import Column, Integer, String, ForeignKey, UniqueConstraint, Indexfrom sqlalchemy.orm import sessionmaker, relationshipfrom sqlalchemy import create_engine engine = create_engine("mysql+pymysql://root:123@127.0.0.1:3306/t1", max_overflow=5) Base = declarative_base() # 创建单表class Users(Base): __tablename__ = 'users' id = Column(Integer, primary_key=True) name = Column(String(32)) extra = Column(String(16)) __table_args__ = ( UniqueConstraint('id', 'name', name='uix_id_name'), Index('ix_id_name', 'name', 'extra'), ) # 一对多class Favor(Base): __tablename__ = 'favor' nid = Column(Integer, primary_key=True) caption = Column(String(50), default='red', unique=True) class Person(Base): __tablename__ = 'person' nid = Column(Integer, primary_key=True) name = Column(String(32), index=True, nullable=True) favor_id = Column(Integer, ForeignKey("favor.nid")) # 多对多class Group(Base): __tablename__ = 'group' id = Column(Integer, primary_key=True) name = Column(String(64), unique=True, nullable=False) port = Column(Integer, default=22) class Server(Base): __tablename__ = 'server' id = Column(Integer, primary_key=True, autoincrement=True) hostname = Column(String(64), unique=True, nullable=False) class ServerToGroup(Base): __tablename__ = 'servertogroup' nid = Column(Integer, primary_key=True, autoincrement=True) server_id = Column(Integer, ForeignKey('server.id')) group_id = Column(Integer, ForeignKey('group.id')) def init_db(): Base.metadata.create_all(engine) def drop_db(): Base.metadata.drop_all(engine) 注：设置外检的另一种方式 ForeignKeyConstraint([‘other_id’], [‘othertable.other_id’]) 2、操作表 表结构 + 数据库连接 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#!/usr/bin/env python# -*- coding:utf-8 -*-from sqlalchemy.ext.declarative import declarative_basefrom sqlalchemy import Column, Integer, String, ForeignKey, UniqueConstraint, Indexfrom sqlalchemy.orm import sessionmaker, relationshipfrom sqlalchemy import create_engineengine = create_engine("mysql+pymysql://root:123@127.0.0.1:3306/t1", max_overflow=5)Base = declarative_base()# 创建单表class Users(Base): __tablename__ = 'users' id = Column(Integer, primary_key=True) name = Column(String(32)) extra = Column(String(16)) __table_args__ = ( UniqueConstraint('id', 'name', name='uix_id_name'), Index('ix_id_name', 'name', 'extra'), ) def __repr__(self): return "%s-%s" %(self.id, self.name)# 一对多class Favor(Base): __tablename__ = 'favor' nid = Column(Integer, primary_key=True) caption = Column(String(50), default='red', unique=True) def __repr__(self): return "%s-%s" %(self.nid, self.caption)class Person(Base): __tablename__ = 'person' nid = Column(Integer, primary_key=True) name = Column(String(32), index=True, nullable=True) favor_id = Column(Integer, ForeignKey("favor.nid")) # 与生成表结构无关，仅用于查询方便 favor = relationship("Favor", backref='pers')# 多对多class ServerToGroup(Base): __tablename__ = 'servertogroup' nid = Column(Integer, primary_key=True, autoincrement=True) server_id = Column(Integer, ForeignKey('server.id')) group_id = Column(Integer, ForeignKey('group.id')) group = relationship("Group", backref='s2g') server = relationship("Server", backref='s2g')class Group(Base): __tablename__ = 'group' id = Column(Integer, primary_key=True) name = Column(String(64), unique=True, nullable=False) port = Column(Integer, default=22) # group = relationship('Group',secondary=ServerToGroup,backref='host_list')class Server(Base): __tablename__ = 'server' id = Column(Integer, primary_key=True, autoincrement=True) hostname = Column(String(64), unique=True, nullable=False)def init_db(): Base.metadata.create_all(engine)def drop_db(): Base.metadata.drop_all(engine)Session = sessionmaker(bind=engine)session = Session() 增 1234567obj = Users(name="alex0", extra='sb')session.add(obj)session.add_all([ Users(name="alex1", extra='sb'), Users(name="alex2", extra='sb'),])session.commit() 删 12session.query(Users).filter(Users.id &gt; 2).delete()session.commit() 改 1234session.query(Users).filter(Users.id &gt; 2).update(&#123;"name" : "099"&#125;)session.query(Users).filter(Users.id &gt; 2).update(&#123;Users.name: Users.name + "099"&#125;, synchronize_session=False)session.query(Users).filter(Users.id &gt; 2).update(&#123;"num": Users.num + 1&#125;, synchronize_session="evaluate")session.commit() 查 12345678ret = session.query(Users).all()ret = session.query(Users.name, Users.extra).all()ret = session.query(Users).filter_by(name='alex').all()ret = session.query(Users).filter_by(name='alex').first()ret = session.query(Users).filter(text("id&lt;:value and name=:name")).params(value=224, name='fred').order_by(User.id).all()ret = session.query(Users).from_statement(text("SELECT * FROM users where name=:name")).params(name='ed').all() 其他 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 条件ret = session.query(Users).filter_by(name='alex').all()ret = session.query(Users).filter(Users.id &gt; 1, Users.name == 'eric').all()ret = session.query(Users).filter(Users.id.between(1, 3), Users.name == 'eric').all()ret = session.query(Users).filter(Users.id.in_([1,3,4])).all()ret = session.query(Users).filter(~Users.id.in_([1,3,4])).all()ret = session.query(Users).filter(Users.id.in_(session.query(Users.id).filter_by(name='eric'))).all()from sqlalchemy import and_, or_ret = session.query(Users).filter(and_(Users.id &gt; 3, Users.name == 'eric')).all()ret = session.query(Users).filter(or_(Users.id &lt; 2, Users.name == 'eric')).all()ret = session.query(Users).filter( or_( Users.id &lt; 2, and_(Users.name == 'eric', Users.id &gt; 3), Users.extra != "" )).all()# 通配符ret = session.query(Users).filter(Users.name.like('e%')).all()ret = session.query(Users).filter(~Users.name.like('e%')).all()# 限制ret = session.query(Users)[1:2]# 排序ret = session.query(Users).order_by(Users.name.desc()).all()ret = session.query(Users).order_by(Users.name.desc(), Users.id.asc()).all()# 分组from sqlalchemy.sql import funcret = session.query(Users).group_by(Users.extra).all()ret = session.query( func.max(Users.id), func.sum(Users.id), func.min(Users.id)).group_by(Users.name).all()ret = session.query( func.max(Users.id), func.sum(Users.id), func.min(Users.id)).group_by(Users.name).having(func.min(Users.id) &gt;2).all()# 连表ret = session.query(Users, Favor).filter(Users.id == Favor.nid).all()ret = session.query(Person).join(Favor).all()ret = session.query(Person).join(Favor, isouter=True).all()# 组合q1 = session.query(Users.name).filter(Users.id &gt; 2)q2 = session.query(Favor.caption).filter(Favor.nid &lt; 2)ret = q1.union(q2).all()q1 = session.query(Users.name).filter(Users.id &gt; 2)q2 = session.query(Favor.caption).filter(Favor.nid &lt; 2)ret = q1.union_all(q2).all()]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery]]></title>
    <url>%2F2018%2F12%2F15%2Fjquery%2F</url>
    <content type="text"><![CDATA[jQuery是什么jQuery由美国人John Resig创建，至今已吸引了来自世界各地的众多 javascript高手加入其team。 jQuery是继prototype之后又一个优秀的Javascript框架。其宗旨是——WRITE LESS,DO MORE! 它是轻量级的js库(压缩后只有21k) ，这是其它的js库所不及的，它兼容CSS3，还兼容各种浏览器 jQuery是一个快速的，简洁的javaScript库，使用户能更方便地处理HTMLdocuments、events、实现动画效果，并且方便地为网站提供AJAX交互。 jQuery还有一个比较大的优势是，它的文档说明很全，而且各种应用也说得很详细，同时还有许多成熟的插件可供选择。 什么是jQuery对象jQuery 对象就是通过jQuery包装DOM对象后产生的对象。jQuery 对象是 jQuery 独有的. 如果一个对象是 jQuery 对象, 那么它就可以使用 jQuery 里的方法: $(“#test”).html(); 12345678910111213$("#test").html() //意思是指：获取ID为test的元素内的html代码。其中html()是jQuery里的方法 // 这段代码等同于用DOM实现代码： document.getElementById(" test ").innerHTML; //虽然jQuery对象是包装DOM对象后产生的，但是jQuery无法使用DOM对象的任何方法，同理DOM对象也不能使用jQuery里的方法.乱使用会报错 //约定：如果获取的是 jQuery 对象, 那么要在变量前面加上$. var $variable = jQuery 对象var variable = DOM 对象$variable[0]：jquery对象转为dom对象 $("#msg").html(); $("#msg")[0].innerHTML jQuery的基础语法：$(selector).action() 寻找元素(选择器和筛选器) 1 选择器1.1 基本选择器1$("*") $("#id") $(".class") $("element") $(".class,p,div") 1.2 层级选择器1$(".outer div") $(".outer&gt;div") $(".outer+div") $(".outer~div") 1.3 基本筛选器1$("li:first") $("li:eq(2)") $("li:even") $("li:gt(1)") 1.4 属性选择器1$('[id="div1"]') $('["alex="sb"][id]') 1.5 表单选择器1$("[type='text']")-----&gt;$(":text") 注意只适用于input标签 : $("input:checked") 实例之左侧菜单 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;left_menu&lt;/title&gt; &lt;style&gt; .menu&#123; height: 500px; width: 30%; background-color: gainsboro; float: left; &#125; .content&#123; height: 500px; width: 70%; background-color: rebeccapurple; float: left; &#125; .title&#123; line-height: 50px; background-color: #425a66; color: forestgreen;&#125; .hide&#123; display: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="outer"&gt; &lt;div class="menu"&gt; &lt;div class="item"&gt; &lt;div class="title"&gt;菜单一&lt;/div&gt; &lt;div class="con"&gt; &lt;div&gt;111&lt;/div&gt; &lt;div&gt;111&lt;/div&gt; &lt;div&gt;111&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;div class="title"&gt;菜单二&lt;/div&gt; &lt;div class="con hide"&gt; &lt;div&gt;111&lt;/div&gt; &lt;div&gt;111&lt;/div&gt; &lt;div&gt;111&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;div class="title"&gt;菜单三&lt;/div&gt; &lt;div class="con hide"&gt; &lt;div&gt;111&lt;/div&gt; &lt;div&gt;111&lt;/div&gt; &lt;div&gt;111&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="content"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script src="jquery-3.2.1.js"&gt;&lt;/script&gt;&lt;script&gt; $(".item .title").click(function () &#123; $(this).next().removeClass("hide").parent().siblings().children(".con").addClass("hide");// $(this).next().removeClass("hide");// $(this).parent().siblings().children(".con").addClass("hide"); &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 实例之tab切换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;tab&lt;/title&gt; &lt;script&gt; function tab(self)&#123; var index=$(self).attr("xxx"); $("#"+index).removeClass("hide").siblings().addClass("hide"); $(self).addClass("current").siblings().removeClass("current"); &#125; &lt;/script&gt; &lt;style&gt; *&#123; margin: 0px; padding: 0px; &#125; .tab_outer&#123; margin: 0px auto; width: 60%; &#125; .menu&#123; background-color: #cccccc; /*border: 1px solid red;*/ line-height: 40px; &#125; .menu li&#123; display: inline-block; &#125; .menu a&#123; border-right: 1px solid red; padding: 11px; &#125; .content&#123; background-color: tan; border: 1px solid green; height: 300px; &#125; .hide&#123; display: none; &#125; .current&#123; background-color: darkgray; color: yellow; border-top: solid 2px rebeccapurple; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="tab_outer"&gt; &lt;ul class="menu"&gt; &lt;li xxx="c1" class="current" onclick="tab(this);"&gt;菜单一&lt;/li&gt; &lt;li xxx="c2" onclick="tab(this);"&gt;菜单二&lt;/li&gt; &lt;li xxx="c3" onclick="tab(this);"&gt;菜单三&lt;/li&gt; &lt;/ul&gt; &lt;div class="content"&gt; &lt;div id="c1"&gt;内容一&lt;/div&gt; &lt;div id="c2" class="hide"&gt;内容二&lt;/div&gt; &lt;div id="c3" class="hide"&gt;内容三&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 2 筛选器2.1 过滤筛选器1$("li").eq(2) $("li").first() $("ul li").hasclass("test") 2.2 查找筛选器123456789$("div").children(".test") $("div").find(".test") $(".test").next() $(".test").nextAll() $(".test").nextUntil() $("div").prev() $("div").prevAll() $("div").prevUntil() $(".test").parent() $(".test").parents() $(".test").parentUntil() $("div").siblings() 操作元素(属性，css，文档处理)1 属性操作1234567891011121314--------------------------属性$("").attr();$("").removeAttr();$("").prop();$("").removeProp();--------------------------CSS类$("").addClass(class|fn)$("").removeClass([class|fn])--------------------------HTML代码/文本/值$("").html([val|fn])$("").text([val|fn])$("").val([val|fn|arr])---------------------------$("").css("color","red") 注意： attr和prop 1234567891011121314151617181920212223242526272829&lt;input id="chk1" type="checkbox" /&gt;是否可见&lt;input id="chk2" type="checkbox" checked="checked" /&gt;是否可见&lt;script&gt;//对于HTML元素本身就带有的固有属性，在处理时，使用prop方法。//对于HTML元素我们自己自定义的DOM属性，在处理时，使用attr方法。//像checkbox，radio和select这样的元素，选中属性对应“checked”和“selected”，这些也属于固有属性，因此//需要使用prop方法去操作才能获得正确的结果。// $("#chk1").attr("checked")// undefined// $("#chk1").prop("checked")// false// ---------手动选中的时候attr()获得到没有意义的undefined-----------// $("#chk1").attr("checked")// undefined// $("#chk1").prop("checked")// true console.log($("#chk1").prop("checked"));//false console.log($("#chk2").prop("checked"));//true console.log($("#chk1").attr("checked"));//undefined console.log($("#chk2").attr("checked"));//checked&lt;/script&gt; 实例之全反选 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src="jquery-1.11.3.min.js"&gt;&lt;/script&gt; &lt;script&gt; function selectall()&#123; $("table :checkbox").prop("checked",true) &#125; function cancel()&#123; $("table :checkbox").prop("checked",false) &#125; function reverse()&#123; // var idlist=$("table :checkbox")// for(var i=0;i&lt;idlist.length;i++)&#123;// var element=idlist[i];//// var ischecked=$(element).prop("checked")// if (ischecked)&#123;// $(element).prop("checked",false)// &#125;// else &#123;// $(element).prop("checked",true)// &#125;//// &#125;// jquery循环的两种方式 //方式一// li=[10,20,30,40]// dic=&#123;name:"yuan",sex:"male"&#125;// $.each(li,function(i,x)&#123;// console.log(i,x)// &#125;) //方式二// $("tr").each(function()&#123;// console.log($(this).html())// &#125;) $("table :checkbox").each(function()&#123; $(this).prop("checked",!$(this).prop("checked"));// if ($(this).prop("checked"))&#123;// $(this).prop("checked",false)// &#125;// else &#123;// $(this).prop("checked",true)// &#125; // 思考:如果用attr方法可以实现吗? &#125;); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button onclick="selectall();"&gt;全选&lt;/button&gt; &lt;button onclick="cancel();"&gt;取消&lt;/button&gt; &lt;button onclick="reverse();"&gt;反选&lt;/button&gt; &lt;table border="1"&gt; &lt;tr&gt; &lt;td&gt;&lt;input type="checkbox"&gt;&lt;/td&gt; &lt;td&gt;111&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type="checkbox"&gt;&lt;/td&gt; &lt;td&gt;222&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type="checkbox"&gt;&lt;/td&gt; &lt;td&gt;333&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type="checkbox"&gt;&lt;/td&gt; &lt;td&gt;444&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 实例之模态对话框 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .back&#123; background-color: rebeccapurple; height: 2000px; &#125; .shade&#123; position: fixed; top: 0; bottom: 0; left:0; right: 0; background-color: coral; opacity: 0.4; &#125; .hide&#123; display: none; &#125; .models&#123; position: fixed; top: 50%; left: 50%; margin-left: -100px; margin-top: -100px; height: 200px; width: 200px; background-color: gold; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="back"&gt; &lt;input id="ID1" type="button" value="click" onclick="action1(this)"&gt;&lt;/div&gt;&lt;div class="shade hide"&gt;&lt;/div&gt;&lt;div class="models hide"&gt; &lt;input id="ID2" type="button" value="cancel" onclick="action2(this)"&gt;&lt;/div&gt;&lt;script src="jquery-1.11.3.min.js"&gt;&lt;/script&gt;&lt;script&gt; function action1(self)&#123; $(self).parent().siblings().removeClass("hide"); &#125; function action2(self)&#123; //$(self).parent().parent().children(".models,.shade").addClass("hide") $(self).parent().addClass("hide").prev().addClass("hide") &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2 文档处理1234567891011121314151617181920212223242526272829//创建一个标签对象 $("&lt;p&gt;")//内部插入 $("").append(content|fn) -----&gt;$("p").append("&lt;b&gt;Hello&lt;/b&gt;"); $("").appendTo(content) -----&gt;$("p").appendTo("div"); $("").prepend(content|fn) -----&gt;$("p").prepend("&lt;b&gt;Hello&lt;/b&gt;"); $("").prependTo(content) -----&gt;$("p").prependTo("#foo");//外部插入 $("").after(content|fn) -----&gt;$("p").after("&lt;b&gt;Hello&lt;/b&gt;"); $("").before(content|fn) -----&gt;$("p").before("&lt;b&gt;Hello&lt;/b&gt;"); $("").insertAfter(content) -----&gt;$("p").insertAfter("#foo"); $("").insertBefore(content) -----&gt;$("p").insertBefore("#foo");//替换 $("").replaceWith(content|fn) -----&gt;$("p").replaceWith("&lt;b&gt;Paragraph. &lt;/b&gt;");//删除 $("").empty() $("").remove([expr])//复制 $("").clone([Even[,deepEven]]) 实例之复制样式条 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="outer"&gt; &lt;div class="item"&gt; &lt;input type="button" value="+" onclick="add(this);"&gt; &lt;input type="text"&gt; &lt;/div&gt; &lt;/div&gt;&lt;script src="jquery-1.11.3.min.js"&gt;&lt;/script&gt; &lt;script&gt; //var $clone_obj=$(self).parent().clone(); // $clone_obj放在这个位置可以吗? function add(self)&#123; // 注意:if var $clone_obj=$(".outer .item").clone();会一遍二,二变四的增加 var $clone_obj=$(self).parent().clone(); $clone_obj.children(":button").val("-").attr("onclick","removed(this)"); $(self).parent().parent().append($clone_obj); &#125; function removed(self)&#123; $(self).parent().remove() &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3 css操作1234567891011121314CSS $("").css(name|pro|[,val|fn]) 位置 $("").offset([coordinates]) $("").position() $("").scrollTop([val]) $("").scrollLeft([val]) 尺寸 $("").height([val|fn]) $("").width([val|fn]) $("").innerHeight() $("").innerWidth() $("").outerHeight([soptions]) $("").outerWidth([options]) 实例返回顶部 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src="js/jquery-2.2.3.js"&gt;&lt;/script&gt; &lt;script&gt; window.onscroll=function()&#123; var current=$(window).scrollTop(); console.log(current) if (current&gt;100)&#123; $(".returnTop").removeClass("hide") &#125; else &#123; $(".returnTop").addClass("hide") &#125; &#125; function returnTop()&#123;// $(".div1").scrollTop(0); $(window).scrollTop(0) &#125; &lt;/script&gt; &lt;style&gt; body&#123; margin: 0px; &#125; .returnTop&#123; height: 60px; width: 100px; background-color: darkgray; position: fixed; right: 0; bottom: 0; color: greenyellow; line-height: 60px; text-align: center; &#125; .div1&#123; background-color: orchid; font-size: 5px; overflow: auto; width: 500px; &#125; .div2&#123; background-color: darkcyan; &#125; .div3&#123; background-color: aqua; &#125; .div&#123; height: 300px; &#125; .hide&#123; display: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="div1 div"&gt; &lt;p&gt;hello&lt;/p&gt; &lt;p&gt;hello&lt;/p&gt; &lt;p&gt;hello&lt;/p&gt; &lt;p&gt;hello&lt;/p&gt; &lt;p&gt;hello&lt;/p&gt; &lt;p&gt;hello&lt;/p&gt; &lt;p&gt;hello&lt;/p&gt; &lt;p&gt;hello&lt;/p&gt; &lt;p&gt;hello&lt;/p&gt; &lt;p&gt;hello&lt;/p&gt; &lt;p&gt;hello&lt;/p&gt; &lt;p&gt;hello&lt;/p&gt; &lt;p&gt;hello&lt;/p&gt; &lt;p&gt;hello&lt;/p&gt; &lt;p&gt;hello&lt;/p&gt; &lt;p&gt;hello&lt;/p&gt; &lt;p&gt;hello&lt;/p&gt; &lt;p&gt;hello&lt;/p&gt; &lt;/div&gt; &lt;div class="div2 div"&gt;&lt;/div&gt; &lt;div class="div3 div"&gt;&lt;/div&gt; &lt;div class="returnTop hide" onclick="returnTop();"&gt;返回顶部&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 事件1234567891011121314151617181920212223242526页面载入 ready(fn) //当DOM载入就绪可以查询及操纵时绑定一个要执行的函数。 $(document).ready(function()&#123;&#125;) -----------&gt; $(function()&#123;&#125;)事件处理 $("").on(eve,[selector],[data],fn) // 在选择元素上绑定一个或多个事件的事件处理函数。 // .on的selector参数是筛选出调用.on方法的dom元素的指定子元素，如： // $('ul').on('click', 'li', function()&#123;console.log('click');&#125;)就是筛选出ul下的li给其绑定 // click事件； [selector]参数的好处: 好处在于.on方法为动态添加的元素也能绑上指定事件；如： //$('ul li').on('click', function()&#123;console.log('click');&#125;)的绑定方式和 //$('ul li').bind('click', function()&#123;console.log('click');&#125;)一样；我通过js给ul添加了一个 //li：$('ul').append('&lt;li&gt;js new li&lt;li&gt;')；这个新加的li是不会被绑上click事件的 //但是用$('ul').on('click', 'li', function()&#123;console.log('click');&#125;方式绑定，然后动态添加 //li:$('ul').append('&lt;li&gt;js new li&lt;li&gt;');这个新生成的li被绑上了click事件 [data]参数的调用: function myHandler(event) &#123; alert(event.data.foo); &#125; $("li").on("click", &#123;foo: "bar"&#125;, myHandler) 实例之面板拖动 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div style="border: 1px solid #ddd;width: 600px;position: absolute;"&gt; &lt;div id="title" style="background-color: black;height: 40px;color: white;"&gt; 标题 &lt;/div&gt; &lt;div style="height: 300px;"&gt; 内容 &lt;/div&gt; &lt;/div&gt;&lt;script type="text/javascript" src="jquery-2.2.3.js"&gt;&lt;/script&gt;&lt;script&gt; $(function()&#123; // 页面加载完成之后自动执行 $('#title').mouseover(function()&#123; $(this).css('cursor','move'); &#125;).mousedown(function(e)&#123; //console.log($(this).offset()); var _event = e || window.event; // 原始鼠标横纵坐标位置 var ord_x = _event.clientX; var ord_y = _event.clientY; var parent_left = $(this).parent().offset().left; var parent_top = $(this).parent().offset().top; $(this).bind('mousemove', function(e)&#123; var _new_event = e || window.event; var new_x = _new_event.clientX; var new_y = _new_event.clientY; var x = parent_left + (new_x - ord_x); var y = parent_top + (new_y - ord_y); $(this).parent().css('left',x+'px'); $(this).parent().css('top',y+'px'); &#125;) &#125;).mouseup(function()&#123; $(this).unbind('mousemove'); &#125;); &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 实例之放大镜 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;bigger&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding:0; &#125; .outer&#123; height: 350px; width: 350px; border: dashed 5px cornflowerblue; &#125; .outer .small_box&#123; position: relative; &#125; .outer .small_box .float&#123; height: 175px; width: 175px; background-color: darkgray; opacity: 0.4; fill-opacity: 0.4; position: absolute; display: none; &#125; .outer .big_box&#123; height: 400px; width: 400px; overflow: hidden; position:absolute; left: 360px; top: 0px; z-index: 1; border: 5px solid rebeccapurple; display: none; &#125; .outer .big_box img&#123; position: absolute; z-index: 5; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="outer"&gt; &lt;div class="small_box"&gt; &lt;div class="float"&gt;&lt;/div&gt; &lt;img src="small.jpg"&gt; &lt;/div&gt; &lt;div class="big_box"&gt; &lt;img src="big.jpg"&gt; &lt;/div&gt; &lt;/div&gt;&lt;script src="jquery-2.1.4.min.js"&gt;&lt;/script&gt;&lt;script&gt; $(function()&#123; $(".small_box").mouseover(function()&#123; $(".float").css("display","block"); $(".big_box").css("display","block") &#125;); $(".small_box").mouseout(function()&#123; $(".float").css("display","none"); $(".big_box").css("display","none") &#125;); $(".small_box").mousemove(function(e)&#123; var _event=e || window.event; var float_width=$(".float").width(); var float_height=$(".float").height(); console.log(float_height,float_width); var float_height_half=float_height/2; var float_width_half=float_width/2; console.log(float_height_half,float_width_half); var small_box_width=$(".small_box").height(); var small_box_height=$(".small_box").width();// 鼠标点距离左边界的长度与float应该与左边界的距离差半个float的width,height同理 var mouse_left=_event.clientX-float_width_half; var mouse_top=_event.clientY-float_height_half; if(mouse_left&lt;0)&#123; mouse_left=0 &#125;else if (mouse_left&gt;small_box_width-float_width)&#123; mouse_left=small_box_width-float_width &#125; if(mouse_top&lt;0)&#123; mouse_top=0 &#125;else if (mouse_top&gt;small_box_height-float_height)&#123; mouse_top=small_box_height-float_height &#125; $(".float").css("left",mouse_left+"px"); $(".float").css("top",mouse_top+"px") var percentX=($(".big_box img").width()-$(".big_box").width())/ (small_box_width-float_width); var percentY=($(".big_box img").height()-$(".big_box").height())/(small_box_height-float_height); console.log(percentX,percentY) $(".big_box img").css("left", -percentX*mouse_left+"px") $(".big_box img").css("top", -percentY*mouse_top+"px") &#125;) &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 动画效果显示隐藏1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src="jquery-2.1.4.min.js"&gt;&lt;/script&gt; &lt;script&gt;$(document).ready(function() &#123; $("#hide").click(function () &#123; $("p").hide(1000); &#125;); $("#show").click(function () &#123; $("p").show(1000); &#125;);//用于切换被选元素的 hide() 与 show() 方法。 $("#toggle").click(function () &#123; $("p").toggle(); &#125;);&#125;) &lt;/script&gt; &lt;link type="text/css" rel="stylesheet" href="style.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;hello&lt;/p&gt; &lt;button id="hide"&gt;隐藏&lt;/button&gt; &lt;button id="show"&gt;显示&lt;/button&gt; &lt;button id="toggle"&gt;切换&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 滑动12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src="jquery-2.1.4.min.js"&gt;&lt;/script&gt; &lt;script&gt; $(document).ready(function()&#123; $("#slideDown").click(function()&#123; $("#content").slideDown(1000); &#125;); $("#slideUp").click(function()&#123; $("#content").slideUp(1000); &#125;); $("#slideToggle").click(function()&#123; $("#content").slideToggle(1000); &#125;) &#125;); &lt;/script&gt; &lt;style&gt; #content&#123; text-align: center; background-color: lightblue; border:solid 1px red; display: none; padding: 50px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="slideDown"&gt;出现&lt;/div&gt; &lt;div id="slideUp"&gt;隐藏&lt;/div&gt; &lt;div id="slideToggle"&gt;toggle&lt;/div&gt; &lt;div id="content"&gt;helloworld&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 淡入淡出12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src="jquery-2.1.4.min.js"&gt;&lt;/script&gt; &lt;script&gt; $(document).ready(function()&#123; $("#in").click(function()&#123; $("#id1").fadeIn(1000); &#125;); $("#out").click(function()&#123; $("#id1").fadeOut(1000); &#125;); $("#toggle").click(function()&#123; $("#id1").fadeToggle(1000); &#125;); $("#fadeto").click(function()&#123; $("#id1").fadeTo(1000,0.4); &#125;);&#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button id="in"&gt;fadein&lt;/button&gt; &lt;button id="out"&gt;fadeout&lt;/button&gt; &lt;button id="toggle"&gt;fadetoggle&lt;/button&gt; &lt;button id="fadeto"&gt;fadeto&lt;/button&gt; &lt;div id="id1" style="display:none; width: 80px;height: 80px;background-color: blueviolet"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 回调函数123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src="jquery-2.1.4.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button&gt;hide&lt;/button&gt; &lt;p&gt;helloworld helloworld helloworld&lt;/p&gt; &lt;script&gt; $("button").click(function()&#123; $("p").hide(1000,function()&#123; alert($(this).html()) &#125;) &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 扩展方法 (插件机制)一 用JQuery写插件时，最核心的方两个方法12345678910111213141516171819202122232425&lt;script&gt; $.extend(object) //为JQuery 添加一个静态方法。$.fn.extend(object) //为JQuery实例添加一个方法。 jQuery.extend(&#123; min: function(a, b) &#123; return a &lt; b ? a : b; &#125;, max: function(a, b) &#123; return a &gt; b ? a : b; &#125; &#125;); console.log($.min(3,4));//-----------------------------------------------------------------------$.fn.extend(&#123; "print":function()&#123; for (var i=0;i&lt;this.length;i++)&#123; console.log($(this)[i].innerHTML) &#125; &#125;&#125;);$("p").print();&lt;/script&gt; 二 定义作用域​ 定义一个JQuery插件，首先要把这个插件的代码放在一个不受外界干扰的地方。如果用专业些的话来说就是要为这个插件定义私有作用域。外部的代码不能直接访问插件内部的代码。插件内部的代码不污染全局变量。在一定的作用上解耦了插件与运行环境的依赖。 123456(function(a,b)&#123;return a+b&#125;)(3,5) (function ($) &#123; &#125;)(jQuery);//相当于 var fn = function ($) &#123; &#125;; fn(jQuery); 三 默认参数定义了jQuery插件之后，如果希望某些参数具有默认值，那么可以以这种方式来指定。 123456789101112131415161718192021222324252627/step01 定义JQuery的作用域(function ($) &#123; //step03-a 插件的默认值属性 var defaults = &#123; prevId: 'prevBtn', prevText: 'Previous', nextId: 'nextBtn', nextText: 'Next' //…… &#125;; //step06-a 在插件里定义方法 var showLink = function (obj) &#123; $(obj).append(function () &#123; return "(" + $(obj).attr("href") + ")" &#125;); &#125; //step02 插件的扩展方法名称 $.fn.easySlider = function (options) &#123; //step03-b 合并用户自定义属性，默认属性 var options = $.extend(defaults, options); //step4 支持JQuery选择器 //step5 支持链式调用 return this.each(function () &#123; //step06-b 在插件里定义方法 showLink(this); &#125;); &#125;&#125;)(jQuery); 经典实例练习实例之注册验证123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111&lt;form class="Form"&gt; &lt;p&gt;&lt;input class="v1" type="text" name="username" mark="用户名"&gt;&lt;/p&gt; &lt;p&gt;&lt;input class="v1" type="text" name="email" mark="邮箱"&gt;&lt;/p&gt; &lt;p&gt;&lt;input class="v1" type="submit" value="submit" onclick="return validate()"&gt;&lt;/p&gt;&lt;/form&gt;&lt;script src="jquery-3.1.1.js"&gt;&lt;/script&gt;&lt;script&gt; // 注意: // DOM对象---&gt;jquery对象 $(DOM) // jquery对象---&gt;DOM对象 $("")[0] //--------------------------------------------------------- // DOM绑定版本 function validate()&#123; flag=true; $("Form .v1").each(function()&#123; $(this).next("span").remove();// 防止对此点击按钮产生多个span标签 var value=$(this).val(); if (value.trim().length==0)&#123; var mark=$(this).attr("mark"); var ele=document.createElement("span"); ele.innerHTML=mark+"不能为空!"; $(this).after(ele); $(ele).prop("class","error");// DOM对象转换为jquery对象 flag=false; // return false--------&gt;引出$.each的return false注意点 &#125; &#125;); return flag &#125; //---------------------------------------------------------//--------------------------------------------------------- //--------------------------------------------------------- function f()&#123; for(var i=0;i&lt;4;i++)&#123; if (i==2)&#123; return &#125; console.log(i) &#125; &#125; f(); // 这个例子大家应该不会有问题吧!!!//------------------------------------------ li=[11,22,33,44]; $.each(li,function(i,v)&#123; if (v==33)&#123; return ; // ===试一试 return false会怎样? &#125; console.log(v) &#125;);//------------------------------------------ // $.MyEach(obj,function(i,v)&#123;&#125;): for(var i in obj)&#123; func(i,obj[i]) ; // i就是索引,v就是对应值 // &#123;&#125;:我们写的大括号的内容就是func的执行语句; &#125; // 大家再考虑: function里的return只是结束了当前的函数,并不会影响后面函数的执行 //本来这样没问题,但因为我们的需求里有很多这样的情况:我们不管循环到第几个函数时,一旦return了, //希望后面的函数也不再执行了!基于此,jquery在$.each里又加了一步: for(var i in obj)&#123; ret=func(i,obj[i]) ; if(ret==false)&#123; return ; &#125; &#125; // 这样就很灵活了: // &lt;1&gt;如果你想return后下面循环函数继续执行,那么就直接写return或return true // &lt;2&gt;如果你不想return后下面循环函数继续执行,那么就直接写return false// --------------------------------------------------------------------- // 说了这么多,请问大家如果我们的需求是:判断出一个输入有问题后面就不判断了(当然也就不显示了), // 怎么办呢? // 对了 if (value.trim().length==0)&#123; //... //... //flag=false; // flag=false不要去,它的功能是最后如果有问题,不提交数据! return false &#125;//最后,大家尝试着用jquery的绑定来完成这个功能! $(".Form :submit").click(function()&#123;&#125;); &lt;/script&gt;]]></content>
      <categories>
        <category>jquery</category>
      </categories>
      <tags>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js基础(一)]]></title>
    <url>%2F2018%2F12%2F10%2Fjs%E5%9F%BA%E7%A1%80-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[JavaScript概述 JavaScript的历史 1992年Nombas开发出C-minus-minus(C–)的嵌入式脚本语言(最初绑定在CEnvi软件中).后将其改名ScriptEase.(客户端执行的语言) Netscape(网景)接收Nombas的理念,(Brendan Eich)在其Netscape Navigator 2.0产品中开发出一套livescript的脚本语言.Sun和Netscape共同完成.后改名叫Javascript 微软随后模仿在其IE3.0的产品中搭载了一个JavaScript的克隆版叫Jscript. 为了统一三家,ECMA(欧洲计算机制造协会)定义了ECMA-262规范.国际标准化组织及国际电工委员会（ISO/IEC）也采纳 ECMAScript 作为标准（ISO/IEC-16262）。从此，Web 浏览器就开始努力（虽然有着不同的程度的成功和失败）将 ECMAScript 作为 JavaScript 实现的基础。EcmaScript是规范. ECMAScript尽管 ECMAScript 是一个重要的标准，但它并不是 JavaScript 唯一的部分，当然，也不是唯一被标准化的部分。实际上，一个完整的 JavaScript 实现是由以下 3 个不同部分组成的： 核心（ECMAScript） 文档对象模型（DOM） Document object model (整合js，css，html) 浏览器对象模型（BOM） Broswer object model（整合js和浏览器） Javascript 在开发中绝大多数情况是基于对象的.也是面向对象的. 简单地说，ECMAScript 描述了以下内容： 语法 类型 语句 关键字 保留字 运算符 对象 (封装 继承 多态) 基于对象的语言.使用对象. JavaScript的引入方式1 直接编写 123&lt;script&gt; alert('hello yuan')&lt;/script&gt; 2 导入文件 1&lt;script src="hello.js"&gt;&lt;/script&gt; JavaScript的基础1 变量123x=5y=6z=x+y 在代数中，我们使用字母（比如 x）来保存值（比如 5）。 通过上面的表达式 z=x+y，我们能够计算出 z 的值为 11。 在 JavaScript 中，这些字母被称为变量。 0 变量是弱类型的(很随便)； 1 声明变量时不用声明变量类型. 全都使用var关键字; 1var a; 2 一行可以声明多个变量.并且可以是不同类型. 1var name="yuan", age=20, job="lecturer"; 3 (了解) 声明变量时 可以不用var. 如果不用var 那么它是全局变量. 4 变量命名,首字符只能是字母,下划线,$美元符 三选一，且区分大小写，x与X是两个变量 5 变量还应遵守以下某条著名的命名规则： 123456789Camel 标记法首字母是小写的，接下来的字母都以大写字符开头。例如：var myTestValue = 0, mySecondValue = "hi";Pascal 标记法首字母是大写的，接下来的字母都以大写字符开头。例如：Var MyTestValue = 0, MySecondValue = "hi";匈牙利类型标记法在以 Pascal 标记法命名的变量前附加一个小写字母（或小写字母序列），说明该变量的类型。例如，i 表示整数，s 表示字符串，如下所示“Var iMyTestValue = 0, sMySecondValue = "hi"; 注意： 12345678910function func1()&#123; var a = 123; b=456 &#125; func1(); // alert(a);// alert(b);// 不推荐 2 基础规范1 每行结束可以不加分号. 没有分号会以换行符作为每行的结束 1234567891011121314151617a=1;b=2;a=1 b=2;------错误a=1b=2//推荐a=1;b=2;&#123; a=1; b=2; //推荐加tab a=1; b=2;&#125; 2 注释 支持多行注释和单行注释. / / // 3 使用{}来封装代码块 3 常量和标识符常量 ：直接在程序中出现的数据值 标识符： 由不以数字开头的字母、数字、下划线(_)、美元符号($)组成 常用于表示函数、变量等的名称 例如：_abc,$abc,abc,abc123是标识符，而1abc不是 JavaScript语言中代表特定含义的词称为保留字，不允许程序再定义为标识符 4 数据类型 数字类型(Number)123456简介最基本的数据类型不区分整型数值和浮点型数值所有数字都采用64位浮点格式存储，相当于Java和C语言中的double格式能表示的最大值是±1.7976931348623157 x 10308 能表示的最小值是±5 x 10 -324 整数： 在JavaScript中10进制的整数由数字的序列组成 精确表达的范围是 -9007199254740992 (-253) 到 9007199254740992 (253) 超出范围的整数，精确度将受影响浮点数： 使用小数点记录数据 例如：3.4，5.6 使用指数记录数据 例如：4.3e23 = 4.3 x 1023 16进制和8进制数的表达 16进制数据前面加上0x，八进制前面加0 16进制数是由0-9,A-F等16个字符组成 8进制数由0-7等8个数字组成 16进制和8进制与2进制的换算 12# 2进制: 1111 0011 1101 0100 &lt;-----&gt; 16进制:0xF3D4 &lt;-----&gt; 10进制:62420# 2进制: 1 111 001 111 010 100 &lt;-----&gt; 8进制:0171724 字符串(String)1234567简介是由Unicode字符、数字、标点符号组成的序列字符串常量首尾由单引号或双引号括起JavaScript中没有字符类型常用特殊字符在字符串中的表达字符串中部分特殊字符必须加上右划线\常用的转义字符 \n:换行 \':单引号 \":双引号 \\:右划线 String数据类型的使用 特殊字符的使用方法和效果 Unicode的插入方法 1234&lt;script&gt; var str="\u4f60\u597d\n欢迎来到\"JavaScript世界\""; alert(str);&lt;/script&gt; 布尔型(Boolean)123456789简介Boolean类型仅有两个值：true和false，也代表1和0，实际运算中true=1,false=0布尔值也可以看作on/off、yes/no、1/0对应true/falseBoolean值主要用于JavaScript的控制语句，例如 if (x==1)&#123; y=y+1; &#125;else &#123; y=y-1; &#125; Null &amp; Undefined12345678Undefined 类型Undefined 类型只有一个值，即 undefined。当声明的变量未初始化时，该变量的默认值是 undefined。当函数无明确返回值时，返回的也是值 "undefined";Null 类型另一种只有一个值的类型是 Null，它只有一个专用值 null，即它的字面量。值 undefined 实际上是从值 null 派生来的，因此 ECMAScript 把它们定义为相等的。尽管这两个值相等，但它们的含义不同。undefined 是声明了变量但未对其初始化时赋予该变量的值，null 则用于表示尚未存在的对象（在讨论 typeof 运算符时，简单地介绍过这一点）。如果函数或方法要返回的是对象，那么找不到该对象时，返回的通常是 null。var person=new Person()var person=null 数据类型转换12345678JavaScript属于松散类型的程序语言变量在声明的时候并不需要指定数据类型变量只有在赋值的时候才会确定数据类型表达式中包含不同类型数据则在计算过程中会强制进行类别转换数字 + 字符串：数字转换为字符串数字 + 布尔值：true转换为1，false转换为0字符串 + 布尔值：布尔值转换为字符串true或false 强制类型转换函数12345函数parseInt： 强制转换成整数 例如parseInt("6.12")=6 ; parseInt(“12a")=12 ; parseInt(“a12")=NaN ;parseInt(“1a2")=1函数parseFloat： 强制转换成浮点数 parseFloat("6.12")=6.12函数eval： 将字符串强制转换为表达式并返回结果 eval("1+1")=2 ; eval("1&lt;2")=true 类型查询函数(typeof)ECMAScript 提供了 typeof 运算符来判断一个值是否在某种类型的范围内。可以用这种运算符判断一个值是否表示一种原始类型：如果它是原始类型，还可以判断它表示哪种原始类型。 123456函数typeof ：查询数值当前类型 (string / number / boolean / object )例如typeof("test"+3) "string"例如typeof(null) "object "例如typeof(true+1) "number"例如typeof(true-false) "number" ECMAScript 算数运算符ECMAScript 算数运算符12345加(＋)、 减(－)、 乘(*) 、除(/) 、余数(% ) 加、减、乘、除、余数和数学中的运算方法一样 例如：9/2=4.5，4*5=20，9%2=1-除了可以表示减号还可以表示负号 例如：x=-y+除了可以表示加法运算还可以用于字符串的连接 例如："abc"+"def"="abcdef" 递增(＋＋) 、递减(－－) 123456789假如x=2，那么x++表达式执行后的值为3，x--表达式执行后的值为1i++相当于i=i+1，i--相当于i=i-1递增和递减运算符可以放在变量前也可以放在变量后：--i var i=1;console.log(i++);console.log(++i);console.log(i--);console.log(--i); 一元加减法： 123456789101112131415161718192021222324var a=1; var b=1; a=-a; //a=-1 var c="10"; alert(typeof (c)); c=+c; //类型转换 alert(typeof (c));// ------------------- var d="yuan"; d=+d; alert(d);//NaN:属于Number类型的一个特殊值,当遇到将字符串转成数字无效时,就会得到一个NaN数据 alert(typeof(d));//Number //NaN特点: var n=NaN; alert(n&gt;3); alert(n&lt;3); alert(n==3); alert(n==NaN); alert(n!=NaN);//NaN参与的所有的运算都是false,除了!= ECMAScript 逻辑运算符12345678等于 ( == ) 、不等于( != ) 、 大于( &gt; ) 、 小于( &lt; ) 大于等于(&gt;=) 、小于等于(&lt;=)与 (&amp;&amp;) 、或(||) 、非(!)&amp;&amp; 1 = 1 1 || 1 = 1&amp;&amp; 0 = 0 1 || 0 = 1&amp;&amp; 0 = 0 0 || 0 = 0!0=1!1=0 逻辑 AND 运算符(&amp;&amp;)逻辑 AND 运算的运算数可以是任何类型的，不止是 Boolean 值。 如果某个运算数不是原始的 Boolean 型值，逻辑 AND 运算并不一定返回 Boolean 值： 如果某个运算数是 null，返回 null。 如果某个运算数是 NaN，返回 NaN。 如果某个运算数是 undefined，返回undefined。 逻辑 OR 运算符(||)与逻辑 AND 运算符相似，如果某个运算数不是 Boolean 值，逻辑 OR 运算并不一定返回 Boolean 值 ECMAScript 赋值运算符1234567赋值 = JavaScript中=代表赋值，两个等号==表示判断是否相等例如，x=1表示给x赋值为1if (x==1)&#123;...&#125;程序表示当x与1相等时if(x==“on”)&#123;…&#125;程序表示当x与“on”相等时 配合其他运算符形成的简化表达式例如i+=1相当于i=i+1，x&amp;=y相当于x=x&amp;y 实例： 12345678910== “2” === “2” != “4” !== “4” var a = 2; var b = 4;var c = a&lt;b | --b&gt;--a;var c = a&lt;b || --b&gt;--a; var c = a&lt;b &amp;&amp;--b&gt;--a;var c = a&lt;b &amp; --b&gt;--a; ECMAScript等性运算符执行类型转换的规则如下： 如果一个运算数是 Boolean 值，在检查相等性之前，把它转换成数字值。false 转换成 0，true 为 1。 如果一个运算数是字符串，另一个是数字，在检查相等性之前，要尝试把字符串转换成数字。 如果一个运算数是对象，另一个是字符串，在检查相等性之前，要尝试把对象转换成字符串。 如果一个运算数是对象，另一个是数字，在检查相等性之前，要尝试把对象转换成数字。 在比较时，该运算符还遵守下列规则： 值 null 和 undefined 相等。 在检查相等性时，不能把 null 和 undefined 转换成其他值。 如果某个运算数是 NaN，等号将返回 false，非等号将返回 true。 如果两个运算数都是对象，那么比较的是它们的引用值。如果两个运算数指向同一对象，那么等号返回 true，否则两个运算数不等。 ECMAScript 关系运算符**(重要)**12var bResult = "Blue" &lt; "alpha";alert(bResult); //输出 true 在上面的例子中，字符串 “Blue” 小于 “alpha”，因为字母 B 的字符代码是 66，字母 a 的字符代码是 97。 比较数字和字符串 另一种棘手的状况发生在比较两个字符串形式的数字时，比如： 12var bResult = "25" &lt; "3";alert(bResult); //输出 "true" 上面这段代码比较的是字符串 “25” 和 “3”。两个运算数都是字符串，所以比较的是它们的字符代码（”2” 的字符代码是 50，”3” 的字符代码是 51）。 不过，如果把某个运算数该为数字，那么结果就有趣了： 12var bResult = "25" &lt; 3;alert(bResult); //输出 "false" 这里，字符串 “25” 将被转换成数字 25，然后与数字 3 进行比较，结果不出所料。 总结： 12比较运算符两侧如果一个是数字类型,一个是其他类型,会将其类型转换成数字类型.比较运算符两侧如果都是字符串类型,比较的是最高位的asc码,如果最高位相等,继续取第二位比较. Boolean运算符(重要)1234567var temp=new Object();// false;[];0; null; undefined;object(new Object();) if(temp)&#123; console.log("yuan") &#125;else &#123; console.log("alex") &#125; 全等号和非全等号等号和非等号的同类运算符是全等号和非全等号。这两个运算符所做的与等号和非等号相同，只是它们在检查相等性前，不执行类型转换。 控制语句if 控制语句1234567891011if-else基本格式if (表达式)&#123;语句１;......&#125;else&#123;语句２;.....&#125;功能说明如果表达式的值为true则执行语句1,否则执行语句2 123456789101112131415161718var x= (new Date()).getDay();//获取今天的星期值，0为星期天var y;if ( (x==6) || (x==0) ) &#123;y="周末";&#125;else&#123;y="工作日";&#125;alert(y);//等价于y="工作日";if ( (x==6) || (x==0) ) &#123;y="周末";&#125; if 可以单独使用 12345678910if语句嵌套格式if (表达式1) &#123; 语句1;&#125;else if (表达式2)&#123; 语句2;&#125;else if (表达式3)&#123; 语句3;&#125; else&#123; 语句4;&#125; 1234567891011if (x==1)&#123; y="星期一";&#125;else if (x==2)&#123; y="星期二";...&#125;else if (x==6)&#123; y="星期六";&#125;else if (x==0)&#123; y="星期日";&#125;else&#123; y="未定义"; switch 选择控制语句1234567switch基本格式switch (表达式) &#123; case 值1:语句1;break; case 值2:语句2;break; case 值3:语句3;break; default:语句4;&#125; 12345678910switch(x)&#123;case 1:y="星期一"; break;case 2:y="星期二"; break;case 3:y="星期三"; break;case 4:y="星期四"; break;case 5:y="星期五"; break;case 6:y="星期六"; break;case 7:y="星期日"; break;default: y="未定义";&#125; switch比else if结构更加简洁清晰，使程序可读性更强,效率更高。 switch为什么效率高？ 123456789101112131415161718192021首先要看一个问题，if 语句适用范围比较广，只要是 boolean 表达式都可以用 if 判断；而 switch 只能对基本类型进行数值比较。两者的可比性就仅限在两个基本类型比较的范围内。说到基本类型的数值比较，那当然要有两个数。然后重点来了——if 语句每一句都是独立的，看下面的语句：if (a == 1) ...else if (a == 2) ...这样 a 要被读入寄存器两次，1 和 2 分别被读入寄存器一次。于是你是否发现其实 a 读两次是有点多余的，在你全部比较完之前只需要一次读入寄存器就行了，其余都是额外开销。但是 if 语句必须每次都把里面的两个数从内存拿出来读到寄存器，它不知道你其实比较的是同一个 a。于是 switch case 就出来了，把上面的改成 switch case 版本：switch (a) &#123; case 0: break; case 1:&#125; 总结:1.switch用来根据一个整型值进行多路分支，并且编译器可以对多路分支进行优化2.switch-case只将表达式计算一次,然后将表达式的值与每个case的值比较,进而选 择执行哪一个case的语句块3.if..else 的判断条件范围较广，每条语句基本上独立的，每次判断时都要条件加载 一次。所以在多路分支时用switch比if..else if .. else结构要效率高。 for 循环控制语句1234567for循环基本格式for (初始化;条件;增量)&#123; 语句1; ...&#125;功能说明实现条件循环，当条件成立时，执行语句1，否则跳出循环体 12345678910for (var i=1;i&lt;=7;i++)&#123; document.write("&lt;H"+i+"&gt;hello&lt;/H "+i+"&gt; "); document.write("&lt;br&gt;");&#125;---------------------------------------------- var arr=[1,"hello",true]//var dic=&#123;"1":"111"&#125; for (var i in arr)&#123; console.log(i) console.log(arr[i]) &#125; 注意： 1234567891011121314doms=document.getElementsByTagName("p"); for (var i in doms)&#123; console.log(i); // 0 1 2 length item namedItem //console.log(doms[i]) &#125;//循环的是你获取的th一个DOM元素集，for in用来循环对象的所有属性，dom元素集包含了你上面输出的属性。//如果你只要循环dom对象的话，可以用for循环: for (var i=0;i&lt;doms.length;i++)&#123; console.log(i) ; // 0 1 2 //console.log(doms[i]) &#125; 结论：for i in 不推荐使用. while 循环控制语句1234567while循环基本格式while (条件)&#123;语句1；...&#125;功能说明运行功能和for类似，当条件成立循环执行语句花括号&#123;&#125;内的语句，否则跳出循环 1234567var i=1;while (i&lt;=7) &#123; document.write("&lt;H"+i+"&gt;hello&lt;/H "+i+"&gt; "); document.write("&lt;br&gt;"); i++;&#125;//循环输出H1到H7的字体大小 123456789101112&lt;script language="JavaScript"&gt;/* sayhello是定义的函数名，前面必须加上function和空格*/function sayHello()&#123; var hellostr; var myname=prompt("请问您贵姓？","苑"); hellostr="您好，"+myname+'先生，欢迎进入"探索之旅"！'; alert(hellostr); document.write(hellostr);&#125; //这里是对前面定义的函数进行调用sayHello();&lt;/script&gt; 异常处理12345678910try &#123; //这段代码从上往下运行，其中任何一个语句抛出异常该代码块就结束运行&#125;catch (e) &#123; // 如果try代码块中抛出了异常，catch代码块中的代码就会被执行。 //e是一个局部变量，用来指向Error对象或者其他抛出的对象&#125;finally &#123; //无论try中代码是否有异常抛出（甚至是try代码块中有return语句），finally代码块中始终会被执行。&#125; 注：主动抛出异常 throw Error(‘xxxx’) ECMA对象从传统意义上来说，ECMAScript 并不真正具有类。事实上，除了说明不存在类，在 ECMA-262 中根本没有出现“类”这个词。ECMAScript 定义了“对象定义”，逻辑上等价于其他程序设计语言中的类。 var o = new Object(); 对象的概念与分类： 由ECMAScript定义的本地对象.独立于宿主环境的 ECMAScript 实现提供的对象.(native object) ECMAScript 实现提供的、独立于宿主环境的所有对象，在 ECMAScript 程序开始执行时出现.这意味着开发者不必明确实例化内置对象，它已被实例化了。ECMA-262 只定义了两个内置对象，即 Global 和 Math （它们也是本地对象，根据定义，每个内置对象都是本地对象）。（built-in object） 所有非本地对象都是宿主对象（host object），即由 ECMAScript 实现的宿主环境提供的对象。所有 BOM 和 DOM 对象都是宿主对象。 object对象：ECMAScript 中的所有对象都由这个对象继承而来；Object 对象中的所有属性和方法都会出现在其他对象中 12ToString() : 返回对象的原始字符串表示。ValueOf() : 返回最适合该对象的原始值。对于许多对象，该方法返回的值都与 ToString() 的返回值相同。 11种内置对象包括： Array ,String , Date, Math, Boolean, Number Function, Global, Error, RegExp , Object 简介： 在JavaScript中除了null和undefined以外其他的数据类型都被定义成了对象，也可以用创建对象的方法定义变量，String、Math、Array、Date、RegExp都是JavaScript中重要的内置对象，在JavaScript程序大多数功能都是通过对象实现的 12345678910&lt;script language="javascript"&gt;var aa=Number.MAX_VALUE; //利用数字对象获取可表示最大数var bb=new String("hello JavaScript"); //创建字符串对象var cc=new Date();//创建日期对象var dd=new Array("星期一","星期二","星期三","星期四"); //数组对象&lt;/script&gt; string对象自动创建字符串对象： 123var str1="hello world";alert(str1.length);alert(str1.substr(1,5)); 调用字符串的对象属性或方法时自动创建对象，用完就丢弃 手工创建字符串对象 123var str1= new String("hello word");alert(str1.length);alert(str1.substr(1,3)); 采用new创建字符串对象str1，全局有效 String对象的属性12获取字符串长度length var str1=”String对象”; var str2=””; alert(“str1长度 “+str1.length); alert(“str2长度 “+str2.length); String对象的方法(1) —— 格式编排方法 格式编排方法返回值列表 123456789书写格式:String对象提供了一组针对HTML格式的方法，如x.anchor()返回锚定义字符串&lt;a&gt;x&lt;/a&gt;，x.bold()返回粗体表示字符串&lt;b&gt;x&lt;/b&gt;，x.sup()返回上标格式字符串&lt;sup&gt;x&lt;/sup&gt;。-----------------------------------------var x="yuan";var y="x.italics():"+x.italics();document.write(y.fontsize(10));//&lt;font size="10"&gt;x.italics():&lt;i&gt;yuan&lt;/i&gt;&lt;/font&gt; String对象的方法(2)—— 大小写转换 12345678var str1="AbcdEfgh"; var str2=str1.toLowerCase();var str3=str1.toUpperCase();alert(str2);//结果为"abcdefgh"alert(str3);//结果为"ABCDEFGH" String对象的方法(3) —— 获取指定字符 12345678910111213141516171819202122书写格式x.charAt(index)x.charCodeAt(index)使用注解x代表字符串对象index代表字符位置index从0开始编号charAt返回index位置的字符charCodeAt返回index位置的Unicode编码----------------------var str1="welcome to the world of JS! 苑昊";var str2=str1.charAt(28);var str3=str1.charCodeAt(28);alert(str2);//结果为"苑"alert(str3);//结果为33489 String对象的方法(4)—— 查询字符串 12345678910111213141516171819202122232425262728293031323334353637383940//书写格式////x.indexOf(findstr,index)//x.lastIndexOf(findstr)//-------------------------------------var str1="welcome to the world of JS!";var str2=str1.indexOf("l");var str3=str1.lastIndexOf("l");alert(str2);//结果为2alert(str3);//结果为18//-------*********************************************************-------//书写格式////x.match(regexp)////x.search(regexp)////使用注解////x代表字符串对象////regexp代表正则表达式或字符串////match返回匹配字符串的数组，如果没有匹配则返回null////search返回匹配字符串的首字符位置索引//-------------------------------------var str1="welcome to the world of JS!";var str2=str1.match("world");var str3=str1.search("world");alert(str2[0]);//结果为"world"alert(str3);//结果为15 String对象的方法(5) ——子字符串处理 截取子字符串 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//截取子字符串////书写格式////x.substr(start, length)////x.substring(start, end)////使用注解////x代表字符串对象////start表示开始位置////length表示截取长度////end是结束位置加1////第一个字符位置为0var str1="abcdefgh";var str2=str1.substr(2,4);var str3=str1.substring(2,4);alert(str2);//结果为"cdef"alert(str3);//结果为"cd"//-------*********************************************************-------//x.slice(start, end)var str1="abcdefgh";var str2=str1.slice(2,4);var str3=str1.slice(4);var str4=str1.slice(2,-1);var str5=str1.slice(-3,-1);alert(str2);//结果为"cd"alert(str3);//结果为"efgh"alert(str4);//结果为"cdefg"alert(str5);//结果为"fg" 替换子字符串 123456//x.replace(findstr,tostr)var str1="abcdefgh";var str2=str1.replace("cd","aaa");alert(str2);//结果为"abaaaefgh" 分割字符串 123456var str1="一,二,三,四,五,六,日"; var strArray=str1.split(",");alert(strArray[1]);//结果为"二" 连接字符串 12345678910111213//y=x.concat(addstr)////使用注解////x代表字符串对象//addstr为添加字符串//返回x+addstr字符串 var str1="abcd"; var str2=str1.concat("efgh");alert(str2);//结果为"abcdefgh" Array对象创建数组对象12345678910111213141516171819Array 对象用于在单个的变量中存储多个值。语法:创建方式1:var a=[1,2,3];创建方式2:new Array(); // 创建数组时允许指定元素个数也可以不指定元素个数。new Array(size);//if 1个参数且为数字,即代表size,not content 初始化数组对象: var cnweek=new Array(7); cnweek[0]="星期日"; cnweek[1]="星期一"; ... cnweek[6]="星期六";new Array(element0, element1, ..., elementn)//也可以直接在建立对象时初始化数组元素，元素类型允许不同var test=new Array(100,"a",true); 创建二维数组1234567891011var cnweek=new Array(7);for (var i=0;i&lt;=6;i++)&#123; cnweek[i]=new Array(2);&#125;cnweek[0][0]="星期日";cnweek[0][1]="Sunday";cnweek[1][0]="星期一";cnweek[1][1]="Monday";...cnweek[6][0]="星期六";cnweek[6][1]="Saturday"; Array对象的属性获取数组元素的个数：length 1234567891011var cnweek=new Array(7);cnweek[0]="星期日";cnweek[1]="星期一";cnweek[2]="星期二";cnweek[3]="星期三";cnweek[4]="星期四";cnweek[5]="星期五";cnweek[6]="星期六";for (var i=0;i&lt;cnweek.length;i++)&#123; document.write(cnweek[i]+" | ");&#125; Array对象的方法 连接数组-join方法 123456789101112131415//书写格式//x.join(bystr)//使用注解////x代表数组对象//bystr作为连接数组中元素的字符串//返回连接后的字符串//与字符串的split功能刚好相反 var arr1=[1, 2, 3, 4, 5, 6, 7];var str1=arr1.join("-");alert(str1);//结果为"1-2-3-4-5-6-7" 连接数组-concat方法 1234567891011121314//连接数组-concat方法////x.concat(value,...)var a = [1,2,3];var a = new Array(1,2,3);var b=a.concat(4,5) ;alert(a.toString());//返回结果为1,2,3alert(b.toString());//返回结果为1,2,3,4,5 数组排序-reverse sort 12345678910111213141516171819202122232425262728293031323334353637383940//x.reverse()//x.sort()var arr1=[32, 12, 111, 444];//var arr1=["a","d","f","c"];arr1.reverse(); //颠倒数组元素alert(arr1.toString());//结果为444,111,12,32arr1.sort(); //排序数组元素alert(arr1.toString());//结果为111,12,32,444//------------------------------arr=[1,5,2,100];//arr.sort();//alert(arr);//如果就想按着数字比较呢?function intSort(a,b)&#123; if (a&gt;b)&#123; return 1;//-1 &#125; else if(a&lt;b)&#123; return -1;//1 &#125; else &#123; return 0 &#125;&#125;arr.sort(intSort);alert(arr);function IntSort(a,b)&#123; return a-b;&#125; 数组切片-slice 12345678910111213141516171819202122//x.slice(start, end)////使用注解////x代表数组对象//start表示开始位置索引//end是结束位置下一数组元素索引编号//第一个数组元素索引为0//start、end可为负数，-1代表最后一个数组元素//end省略则相当于从start位置截取以后所有数组元素var arr1=['a','b','c','d','e','f','g','h'];var arr2=arr1.slice(2,4);var arr3=arr1.slice(4);var arr4=arr1.slice(2,-1);alert(arr2.toString());//结果为"c,d" alert(arr3.toString());//结果为"e,f,g,h"alert(arr4.toString());//结果为"c,d,e,f,g" 删除子数组 12345678910111213141516171819202122//x. splice(start, deleteCount, value, ...)////使用注解////x代表数组对象//splice的主要用途是对数组指定位置进行删除和插入//start表示开始位置索引//deleteCount删除数组元素的个数//value表示在删除位置插入的数组元素//value参数可以省略var a = [1,2,3,4,5,6,7,8];a.splice(1,2);//a变为 [1,4,5,6,7,8]alert(a.toString());a.splice(1,1); //a变为[1,5,6,7,8]alert(a.toString());a.splice(1,0,2,3); //a变为[1,2,3,5,6,7,8]alert(a.toString()); 数组的进出栈操作(1) 12345678910111213141516171819202122//push pop这两个方法模拟的是一个栈操作//x.push(value, ...) 压栈//x.pop() 弹栈 //使用注解////x代表数组对象//value可以为字符串、数字、数组等任何值//push是将value值添加到数组x的结尾//pop是将数组x的最后一个元素删除var arr1=[1,2,3];arr1.push(4,5);alert(arr1);//结果为"1,2,3,4,5"arr1.push([6,7]);alert(arr1)//结果为"1,2,3,4,5,6,7"arr1.pop();alert(arr1);//结果为"1,2,3,4,5" 数组的进出栈操作(2) 1234567891011121314151617181920// unshift shift //x.unshift(value,...)//x.shift()//使用注解////x代表数组对象//value可以为字符串、数字、数组等任何值//unshift是将value值插入到数组x的开始//shift是将数组x的第一个元素删除var arr1=[1,2,3];arr1.unshift(4,5);alert(arr1);//结果为"4,5,1,2,3"arr1. unshift([6,7]);alert(arr1);//结果为"6,7,4,5,1,2,3"arr1.shift();alert(arr1);//结果为"4,5,1,2,3" 总结js的数组特性： 123456789// js中数组的特性 //java中数组的特性, 规定是什么类型的数组,就只能装什么类型.只有一种类型. //js中的数组特性1: js中的数组可以装任意类型,没有任何限制. //js中的数组特性2: js中的数组,长度是随着下标变化的.用到多长就有多长. var arr5 = ['abc',123,1.14,true,null,undefined,new String('1213'),new Function('a','b','alert(a+b)')]; /* alert(arr5.length);//8 arr5[10] = "hahaha"; alert(arr5.length); //11 alert(arr5[9]);// undefined */ Date对象创建Date对象1234567891011121314151617//方法1：不指定参数var nowd1=new Date();alert(nowd1.toLocaleString( ));//方法2：参数为日期字符串var nowd2=new Date("2004/3/20 11:12");alert(nowd2.toLocaleString( ));var nowd3=new Date("04/03/20 11:12");alert(nowd3.toLocaleString( ));//方法3：参数为毫秒数var nowd3=new Date(5000);alert(nowd3.toLocaleString( ));alert(nowd3.toUTCString());//方法4：参数为年月日小时分钟秒毫秒var nowd4=new Date(2004,2,20,11,12,0,300);alert(nowd4.toLocaleString( ));//毫秒并不直接显示 Date对象的方法—获取日期和时间1234567891011获取日期和时间getDate() 获取日getDay () 获取星期getMonth () 获取月（0-11）getFullYear () 获取完整年份getYear () 获取年getHours () 获取小时getMinutes () 获取分钟getSeconds () 获取秒getMilliseconds () 获取毫秒getTime () 返回累计毫秒数(从1970/1/1午夜) 练习实例： 1234567891011121314151617181920212223242526272829303132333435363738function getCurrentDate()&#123; //1. 创建Date对象 var date = new Date(); //没有填入任何参数那么就是当前时间 //2. 获得当前年份 var year = date.getFullYear(); //3. 获得当前月份 js中月份是从0到11. var month = date.getMonth()+1; //4. 获得当前日 var day = date.getDate(); //5. 获得当前小时 var hour = date.getHours(); //6. 获得当前分钟 var min = date.getMinutes(); //7. 获得当前秒 var sec = date.getSeconds(); //8. 获得当前星期 var week = date.getDay(); //没有getWeek // 2014年06月18日 15:40:30 星期三 return year+"年"+changeNum(month)+"月"+day+"日 "+hour+":"+min+":"+sec+" "+parseWeek(week); &#125;alert(getCurrentDate());//解决 自动补齐成两位数字的方法 function changeNum(num)&#123; if(num &lt; 10)&#123; return "0"+num; &#125;else&#123; return num; &#125;&#125;//将数字 0~6 转换成 星期日到星期六 function parseWeek(week)&#123; var arr = ["星期日","星期一","星期二","星期三","星期四","星期五","星期六"]; // 0 1 2 3 ............. return arr[week];&#125; Date对象的方法—设置日期和时间123456789101112131415161718192021222324//设置日期和时间//setDate(day_of_month) 设置日//setMonth (month) 设置月//setFullYear (year) 设置年//setHours (hour) 设置小时//setMinutes (minute) 设置分钟//setSeconds (second) 设置秒//setMillliseconds (ms) 设置毫秒(0-999)//setTime (allms) 设置累计毫秒(从1970/1/1午夜) var x=new Date();x.setFullYear (1997); //设置年1997x.setMonth(7); //设置月7x.setDate(1); //设置日1x.setHours(5); //设置小时5x.setMinutes(12); //设置分钟12x.setSeconds(54); //设置秒54x.setMilliseconds(230); //设置毫秒230document.write(x.toLocaleString( )+"&lt;br&gt;");//返回1997年8月1日5点12分54秒x.setTime(870409430000); //设置累计毫秒数document.write(x.toLocaleString( )+"&lt;br&gt;");//返回1997年8月1日12点23分50秒 Date对象的方法—日期和时间的转换123456789101112日期和时间的转换:getTimezoneOffset():8个时区×15度×4分/度=480;返回本地时间与GMT的时间差，以分钟为单位toUTCString()返回国际标准时间字符串toLocalString()返回本地格式时间字符串Date.parse(x)返回累计毫秒数(从1970/1/1午夜到本地时间)Date.UTC(x)返回累计毫秒数(从1970/1/1午夜到国际时间) RegExp对象123456789101112131415161718192021222324252627//RegExp对象 // 在表单验证时使用该对象验证用户填入的字符串是否符合规则. //创建正则对象方式1 参数1 正则表达式 参数2 验证模式 g global / i 忽略大小写. //参数2一般填写g就可以，也有“gi”. // 用户名 首字母必须是英文, 除了第一位其他只能是英文数字和_ . 长度最短不能少于6位 最长不能超过12位 //----------------------------创建方式1 /* var reg1 = new RegExp("^[a-zA-Z][a-zA-Z0-9_]&#123;5,11&#125;$","g"); // //验证字符串 var str = "bc123"; alert(reg1.test(str));// true //----------------------------创建方式2 /填写正则表达式/匹配模式; var reg2 = /^[a-zA-Z][a-zA-Z0-9_]&#123;5,11&#125;$/g; alert(reg2.test(str));// true */ //-------------------------------正则对象的方法------------------- //test方法 ==&gt; 测试一个字符串是否复合 正则规则. 返回值是true 和false. //-------------------------String 中与正则结合的4个方法------------------. // macth search split replace var str = "hello world"; //alert(str.match(/o/g)); //查找字符串中 复合正则的 内容. //alert(str.search(/h/g));// 0 查找字符串中符合正则表达式的内容位置 //alert(str.split(/o/g)); // 按照正则表达式对字符串进行切割. 返回数组; alert(str.replace(/o/g, "s")); // hells wsrld 对字符串按照正则进行替换. Math对象12345678910111213141516171819202122232425262728293031323334//Math对象 //该对象中的属性方法 和数学有关. //Math是内置对象 , 与Global的不同之处是, 在调用时 需要打出 "Math."前缀. //属性学习: //alert(Math.PI); //方法学习: //alert(Math.random()); // 获得随机数 0~1 不包括1. //alert(Math.round(1.5)); // 四舍五入 //练习：获取1-100的随机整数，包括1和100 //var num=Math.random(); //num=num*10; //num=Math.round(num); // alert(num) //============max min========================= /* alert(Math.max(1,2));// 2 alert(Math.min(1,2));// 1 */ //-------------pow-------------------------------- alert(Math.pow(2,4));// pow 计算参数1 的参数2 次方. abs(x) 返回数的绝对值。exp(x) 返回 e 的指数。floor(x)对数进行下舍入。log(x) 返回数的自然对数（底为e）。max(x,y) 返回 x 和 y 中的最高值。min(x,y) 返回 x 和 y 中的最低值。pow(x,y) 返回 x 的 y 次幂。random() 返回 0 ~ 1 之间的随机数。round(x) 把数四舍五入为最接近的整数。sin(x) 返回数的正弦。sqrt(x) 返回数的平方根。tan(x) 返回角的正切。 Function 对象(重点)函数的定义：123function 函数名 (参数)&#123; 函数体; return 返回值;&#125; 功能说明： 可以使用变量、常量或表达式作为函数调用的参数 函数由关键字function定义 函数名的定义规则与标识符一致，大小写是敏感的 返回值必须使用return Function 类可以表示开发者定义的任何函数。 用 Function 类直接创建函数的语法如下： 123456function 函数名 (参数)&#123; 函数体; return 返回值;&#125;//another way:var 函数名 = new Function("参数1","参数n","function_body"); 虽然由于字符串的关系，第二种形式写起来有些困难，但有助于理解函数只不过是一种引用类型，它们的行为与用 Function 类明确创建的函数行为是相同的。 实例： 123456789101112alert(1);function func1()&#123; alert('hello yuan!'); return 8&#125; ret=func1(); alert(ret)－－－－－－－－－－－－－－－－ var func1=new Function("name","alert(\"hello\"+name);")func1("yuan") 注意：js的函数加载执行与python不同，它是整体加载完才会执行，所以执行函数放在函数声明上面或下面都可以： 123456789&lt;script&gt; //f(); ---&gt;OK function f()&#123; console.log("hello") &#125; f() //-----&gt;OK&lt;/script&gt; Function 对象的 length 属性 如前所述，函数属于引用类型，所以它们也有属性和方法。 比如，ECMAScript 定义的属性 length 声明了函数期望的参数个数。 1alert(func1.length) Function 对象的方法 Function 对象也有与所有对象共享的 valueOf() 方法和 toString() 方法。这两个方法返回的都是函数的源代码，在调试时尤其有用。 1alert(void(fun1(1,2))) 运算符void()作用：拦截方法的返回值 函数的调用1234567891011121314151617181920function func1(a,b)&#123; alert(a+b);&#125; func1(1,2); //3 func1(1,2,3);//3 func1(1); //NaN func1(); //NaN //只要函数名写对即可,参数怎么填都不报错.-------------------面试题----------- function a(a,b)&#123; alert(a+b);&#125; var a=1; var b=2; a(a,b) 函数的内置对象arguments123456789101112131415161718192021222324252627282930313233function add(a,b)&#123; console.log(a+b);//3 console.log(arguments.length);//2 console.log(arguments);//[1,2] &#125; add(1,2) ------------------arguments的用处1 ------------------ function nxAdd()&#123; var result=0; for (var num in arguments)&#123; result+=arguments[num] &#125; alert(result) &#125; nxAdd(1,2,3,4,5)// ------------------arguments的用处2 ------------------ function f(a,b,c)&#123; if (arguments.length!=3)&#123; throw new Error("function f called with "+arguments.length+" arguments,but it just need 3 arguments") &#125; else &#123; alert("success!") &#125; &#125; f(1,2,3,4,5) 匿名函数12345678910111213// 匿名函数 var func = function(arg)&#123; return "tony"; &#125;// 匿名函数的应用 (function()&#123; alert("tony"); &#125; )() (function(arg)&#123; console.log(arg); &#125;)('123') 函数的作用域链和闭包作用域js的作用域和py相似，if while等控制语句并没有自己作用域；而函数是有自己的作用域的； 123456789101112if(1==1)&#123; var s=12; &#125; console.log(s);//12 // ---------------------- function f()&#123; var temp=666; &#125; f(); console.log(temp);//Uncaught ReferenceError: temp is not defined 嵌套函数的作用域： 例1: 1234567891011var city = 'beijing'; function func()&#123; var city = 'shanghai'; function inner()&#123; var city = 'shenzhen'; console.log(city); &#125; inner(); &#125; func(); 例2: 1234567891011var city = 'beijing';function Bar()&#123; console.log(city);&#125;function func()&#123; var city = 'shanghai'; return Bar;&#125;var ret = func();ret(); //beijing 闭包：123456789101112var city = 'beijing';function func()&#123; var city = "shanghai"; function inner()&#123; // var city = "langfang"; console.log(city); &#125; return inner;&#125;var ret = func();ret(); 作用域链(Scope Chain)：​ 在JavaScript中，函数也是对象，实际上，JavaScript里一切都是对象。函数对象和其它对象一样，拥有可以通过代码访问的属性和一系列仅供JavaScript引擎访问的内部属性。其中一个内部属性是[[Scope]]，由ECMA-262标准第三版定义，该内部属性包含了函数被创建的作用域中对象的集合，这个集合被称为函数的作用域链，它决定了哪些数据能被函数访问。 123456789101112var x=1;function foo() &#123; var y = 2; function bar() &#123; var z = 3; &#125;&#125;#bar的作用域链： barScopeChain=[bar.AO, foo.AO, global.VO];#foo的作用域链： fooScopeChain=[foo.Ao, global.VO]; 1234567891011121314什么是AO,VO? 在函数创建时，每个函数都会创建一个活动对象Active Object(AO)，全局对象为Global Object(VO)，创建函数的过程也就是为这个对象添加属性的过程，作用域链就是由这些绑定了属性的活动对象构成的。 例如：找x变量；bar函数在搜寻变量x的过程中，先从自身AO对象上找，如果bar.AO存在这个属性，那么会直接使用这个属性的值，如果不存在，则会转到父级函数的AO对象，也就是foo.AO 如果找到x属性则使用，找不到继续 在global.VO对象查找，找到x的属性，返回属性值。如果在global.VO中没有找到，则会抛出异常ReferenceError执行上下文。 函数在执行时会创建一个称为“执行上下文（execution context）”的内部对象，执行上下文定义了函数 执行时的环境。每个执行上下文都有自己的作用域链，用于标识符解析，当执行上下文被创建时，而它的作用 域链初始化为当前运行函数的[[Scope]]所包含的对象。函数执行 在函数执行过程中，每遇到一个变量，都会检索从哪里获取和存储数据，该过程从作用域链头部，也就是从活 动对象开始搜索，查找同名的标识符，如果找到了就使用这个标识符对应的变量，如果没有则继续搜索作用域 链中的下一个对象，如果搜索完所有对象都未找到，则认为该标识符未定义，函数执行过程中，每个标识符都 要经历这样的搜索过程。 创建作用域链的过程 123456789101112函数进入全局，创建VO对象，绑定x属性&lt;入栈&gt; global.VO=&#123;x=underfind; foo:reference of function&#125;(这里只是预解析，为AO对象绑定声明的属性，函数执行时才会执行赋值语句，所以值是underfind) 遇到foo函数，创建foo.AO，绑定y属性&lt;入栈&gt; foo.AO=&#123;y=underfind, bar:reference of function&#125; 遇到bar函数，创建bar.AO，绑定z属性&lt;入栈&gt; bar.AO=&#123;z:underfind&#125; 作用域链和执行上下文都会保存在堆栈中，所以： bar函数的scope chain为：[0]bar.AO--&gt;[1]foo.AO--&gt;[2]global.VO foo函数的scope chain为：[0]foo.AO--&gt;[1]global.Vo //建议：少定义全局变量 //理由：因为作用域链是栈的结构，全局变量在栈底，每次访问全局变量都会遍历一次栈，//这样会影响效率 函数的scope等于自身的AO对象加上父级的scope，也可以理解为一个函数的作用域等于自身活动对象加上父级作用域. 函数执行前后的作用域链： 注意：作用域链的非自己部分在函数对象被建立（函数声明、函数表达式）的时候建立，而不需要等到执行 BOM对象BOM（浏览器对象模型），可以对浏览器窗口进行访问和操作。使用 BOM，开发者可以移动窗口、改变状态栏中的文本以及执行其他与页面内容不直接相关的动作。 使 JavaScript 有能力与浏览器“对话”。 Window对象12345window对象 所有浏览器都支持 window 对象。 概念上讲.一个html文档对应一个window对象. 功能上讲: 控制浏览器窗口的. 使用上讲: window对象不需要创建对象,直接使用即可. window 对象方法1234567891011alert() 显示带有一段消息和一个确认按钮的警告框。confirm() 显示带有一段消息以及确认按钮和取消按钮的对话框。prompt() 显示可提示用户输入的对话框。open() 打开一个新的浏览器窗口或查找一个已命名的窗口。close() 关闭浏览器窗口。setInterval() 按照指定的周期（以毫秒计）来调用函数或计算表达式。clearInterval() 取消由 setInterval() 设置的 timeout。setTimeout() 在指定的毫秒数后调用函数或计算表达式。clearTimeout() 取消由 setTimeout() 方法设置的 timeout。scrollTo() 把内容滚动到指定的坐标。 交互方法： 1234567891011121314151617181920212223方法讲解: //----------alert confirm prompt---------------------------- //alert('aaa'); /* var result = confirm("您确定要删除吗?"); alert(result); */ //prompt 参数1 : 提示信息. 参数2:输入框的默认值. 返回值是用户输入的内容. // var result = prompt("请输入一个数字!","haha"); // alert(result); 方法讲解: //open方法 打开和一个新的窗口 并 进入指定网址.参数1 : 网址. //调用方式1 //open("http://www.baidu.com"); //参数1 什么都不填 就是打开一个新窗口. 参数2.填入新窗口的名字(一般可以不填). 参数3: 新打开窗口的参数. open('','','width=200,resizable=no,height=100'); // 新打开一个宽为200 高为100的窗口 //close方法 将当前文档窗口关闭. //close(); 练习： 123456789101112131415161718192021222324252627282930var num = Math.round(Math.random()*100);function acceptInput()&#123;//2.让用户输入(prompt) 并接受 用户输入结果var userNum = prompt("请输入一个0~100之间的数字!","0");//3.将用户输入的值与 随机数进行比较 if(isNaN(+userNum))&#123; //用户输入的无效(重复2,3步骤) alert("请输入有效数字!"); acceptInput(); &#125; else if(userNum &gt; num)&#123; //大了==&gt; 提示用户大了,让用户重新输入(重复2,3步骤) alert("您输入的大了!"); acceptInput(); &#125;else if(userNum &lt; num)&#123; //小了==&gt; 提示用户小了,让用户重新输入(重复2,3步骤) alert("您输入的小了!"); acceptInput(); &#125;else&#123; //答对了==&gt;提示用户答对了 , 询问用户是否继续游戏(confirm). var result = confirm("恭喜您!答对了,是否继续游戏?"); if(result)&#123; //是 ==&gt; 重复123步骤. num = Math.round(Math.random()*100); acceptInput(); &#125;else&#123; //否==&gt; 关闭窗口(close方法). close(); &#125; &#125; setInterval clearInterval 1234567891011121314151617181920212223242526272829303132&lt;input id="ID1" type="text" onclick="begin()"&gt;&lt;button onclick="end()"&gt;停止&lt;/button&gt;&lt;script&gt; function showTime()&#123; var nowd2=new Date().toLocaleString(); var temp=document.getElementById("ID1"); temp.value=nowd2; &#125; var clock; function begin()&#123; if (clock==undefined)&#123; showTime(); clock=setInterval(showTime,1000); &#125; &#125; function end()&#123; clearInterval(clock); &#125;&lt;/script&gt; setTimeout clearTimeout 12345var ID = setTimeout(abc,2000); // 只调用一次对应函数. clearTimeout(ID); function abc()&#123; alert('aaa'); &#125; History 对象History 对象属性History 对象包含用户（在浏览器窗口中）访问过的 URL。 History 对象是 window 对象的一部分，可通过 window.history 属性对其进行访问。 1length 返回浏览器历史列表中的 URL 数量。 History 对象方法123back() 加载 history 列表中的前一个 URL。forward() 加载 history 列表中的下一个 URL。go() 加载 history 列表中的某个具体页面。 1234&lt;a href="rrr.html"&gt;click&lt;/a&gt;&lt;button onclick=" history.forward()"&gt;&gt;&gt;&gt;&lt;/button&gt;&lt;button onclick="history.back()"&gt;back&lt;/button&gt;&lt;button onclick="history.go()"&gt;back&lt;/button&gt; Location 对象Location 对象包含有关当前 URL 的信息。 Location 对象是 Window 对象的一个部分，可通过 window.location 属性来访问。 Location 对象方法123location.assign(URL)location.reload()location.replace(newURL)//注意与assign的区别 DOM对象 1 什么是 DOM？DOM 是 W3C（万维网联盟）的标准。DOM 定义了访问 HTML 和 XML 文档的标准： “W3C 文档对象模型（DOM）是中立于平台和语言的接口，它允许程序和脚本动态地访问和更新文档的内容、结构和样式。” W3C DOM 标准被分为 3 个不同的部分： 核心 DOM - 针对任何结构化文档的标准模型 XML DOM - 针对 XML 文档的标准模型 HTML DOM - 针对 HTML 文档的标准模型 什么是 XML DOM？ －－－－&gt;XML DOM 定义了所有 XML 元素的对象和属性，以及访问它们的方法。 什么是 HTML DOM？－－－－&gt;HTML DOM 定义了所有 HTML 元素的对象和属性，以及访问它们的方法。 2 DOM 节点根据 W3C 的 HTML DOM 标准，HTML 文档中的所有内容都是节点(NODE)： 整个文档是一个文档节点(document对象) 每个 HTML 元素是元素节点(element 对象) HTML 元素内的文本是文本节点(text对象) 每个 HTML 属性是属性节点(attribute对象) 注释是注释节点(comment对象) 画dom树是为了展示文档中各个对象之间的关系，用于对象的导航。 节点(自身)属性: attributes - 节点（元素）的属性节点 nodeType – 节点类型 nodeValue – 节点值 nodeName – 节点名称 innerHTML - 节点（元素）的文本值 导航属性: parentNode - 节点（元素）的父节点 (推荐) firstChild – 节点下第一个子元素 lastChild – 节点下最后一个子元素 childNodes - 节点（元素）的子节点 注意： 12345678910&lt;div id="div1"&gt; &lt;div id="div2"&gt;&lt;/div&gt; &lt;p&gt;hello yuan&lt;/p&gt;&lt;/div&gt;&lt;script&gt; var div=document.getElementById("div2"); console.log(div.nextSibling.nodeName); //思考:为什么不是P?&lt;/script&gt; 推荐导航属性： 1234567891011parentElement // 父节点标签元素children // 所有子标签 firstElementChild // 第一个子标签元素lastElementChild // 最后一个子标签元素nextElementtSibling // 下一个兄弟标签元素previousElementSibling // 上一个兄弟标签元素 节点树中的节点彼此拥有层级关系。 父(parent),子(child)和同胞(sibling)等术语用于描述这些关系。父节点拥有子节点。同级的子节点被称为同胞（兄弟或姐妹）。 在节点树中，顶端节点被称为根（root） 每个节点都有父节点、除了根（它没有父节点） 一个节点可拥有任意数量的子 同胞是拥有相同父节点的节点 下面的图片展示了节点树的一部分，以及节点之间的关系： 访问 HTML 元素（节点）,访问 HTML 元素等同于访问节点,我们能够以不同的方式来访问 HTML 元素： 页面查找： 通过使用 getElementById() 方法 通过使用 getElementsByTagName() 方法 通过使用 getElementsByClassName() 方法 通过使用 getElementsByName() 方法 局部查找： 1234567891011121314151617181920212223242526&lt;div id="div1"&gt; &lt;div class="div2"&gt;i am div2&lt;/div&gt; &lt;div name="yuan"&gt;i am div2&lt;/div&gt; &lt;div id="div3"&gt;i am div2&lt;/div&gt; &lt;p&gt;hello p&lt;/p&gt;&lt;/div&gt;&lt;script&gt; var div1=document.getElementById("div1");////支持;// var ele= div1.getElementsByTagName("p");// alert(ele.length);////支持// var ele2=div1.getElementsByClassName("div2");// alert(ele2.length);////不支持// var ele3=div1.getElementById("div3");// alert(ele3.length);////不支持// var ele4=div1.getElementsByName("yuan");// alert(ele4.length)&lt;/script&gt; 3 HTML DOM Event(事件)HTML 4.0 的新特性之一是有能力使 HTML 事件触发浏览器中的动作（action），比如当用户点击某个 HTML 元素时启动一段 JavaScript。下面是一个属性列表，这些属性可插入 HTML 标签来定义事件动作。 12345678910111213141516171819onclick 当用户点击某个对象时调用的事件句柄。ondblclick 当用户双击某个对象时调用的事件句柄。onfocus 元素获得焦点。 //练习：输入框onblur 元素失去焦点。 应用场景：用于表单验证,用户离开某个输入框时,代表已经输入完了,我们可以对它进行验证.onchange 域的内容被改变。 应用场景：通常用于表单元素,当元素内容被改变时触发.（三级联动）onkeydown 某个键盘按键被按下。 应用场景: 当用户在最后一个输入框按下回车按键时,表单提交.onkeypress 某个键盘按键被按下并松开。onkeyup 某个键盘按键被松开。onload 一张页面或一幅图像完成加载。onmousedown 鼠标按钮被按下。onmousemove 鼠标被移动。onmouseout 鼠标从某元素移开。onmouseover 鼠标移到某元素之上。onmouseleave 鼠标从元素离开onselect 文本被选中。onsubmit 确认按钮被点击。 两种为元素附加事件属性的方式 123456789101112&lt;div onclick="alert(123)"&gt;点我呀&lt;/div&gt;&lt;p id="abc"&gt;试一试!&lt;/p&gt;&lt;script&gt; var ele=document.getElementById("abc"); ele.onclick=function()&#123; alert("hi"); &#125;;&lt;/script&gt; 注意： 12345678910111213141516&lt;div id="abc" onclick="func1(this)"&gt;事件绑定方式1&lt;/div&gt;&lt;div id="id123"&gt;事件绑定方式2&lt;/div&gt;&lt;script&gt; function func1(self)&#123; console.log(self.id) &#125; //jquery下是$(self), 这种方式this参数必须填写;//------------------------------------------ var ele=document.getElementById("id123").onclick=function()&#123; console.log(this.id); //jquery下是$(this), 这种方式不需要this参数; &#125; &lt;/script&gt; onload： onload 属性开发中 只给 body元素加.这个属性的触发 标志着 页面内容被加载完成.应用场景: 当有些事情我们希望页面加载完立刻执行,那么可以使用该事件属性. 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script&gt;// window.onload=function()&#123;// var ele=document.getElementById("ppp");// ele.onclick=function()&#123;// alert(123)// &#125;;// &#125;; function fun1() &#123; var ele=document.getElementById("ppp"); ele.onclick=function()&#123; alert(123) &#125;; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body onload="fun1()"&gt;&lt;p id="ppp"&gt;hello p&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; onsubmit: 是当表单在提交时触发. 该属性也只能给form元素使用.应用场景: 在表单提交前验证用户输入是否正确.如果验证失败.在该方法中我们应该阻止表单的提交. 12345678910111213141516171819&lt;form id="form"&gt; &lt;input type="text"/&gt; &lt;input type="submit" value="点我!" /&gt;&lt;/form&gt;&lt;script type="text/javascript"&gt; //阻止表单提交方式1(). //onsubmit 命名的事件函数,可以接受返回值. 其中返回false表示拦截表单提交.其他为放行. var ele=document.getElementById("form"); ele.onsubmit=function(event) &#123;// alert("验证失败 表单不会提交!");// return false; // 阻止表单提交方式2 event.preventDefault(); ==&gt;通知浏览器不要执行与事件关联的默认动作。 alert("验证失败 表单不会提交!"); event.preventDefault(); &#125; Event 对象 Event 对象代表事件的状态，比如事件在其中发生的元素、键盘按键的状态、鼠标的位置、鼠标按钮的状态。 事件通常与函数结合使用，函数不会在事件发生前被执行！event对象在事件发生时系统已经创建好了,并且会在事件函数被调用时传给事件函数.我们获得仅仅需要接收一下即可. 比如onkeydown,我们想知道哪个键被按下了，需要问下event对象的属性，这里就时KeyCode； 事件传播： 123456789101112131415&lt;div id="abc_1" style="border:1px solid red;width:300px;height:300px;"&gt; &lt;div id="abc_2" style="border:1px solid red;width:200px;height:200px;"&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; document.getElementById("abc_1").onclick=function()&#123; alert('111'); &#125; document.getElementById("abc_2").onclick=function(event)&#123; alert('222'); event.stopPropagation(); //阻止事件向外层div传播. &#125; &lt;/script&gt; 4 增删改查演示4.1 node的CURD：增: 12createElement(name)创建元素appendChild();将元素添加 删: 123获得要删除的元素获得它的父元素使用removeChild()方法删除 改: 第一种方式: ​ 使用上面增和删结合完成修改 第二中方式: 使用setAttribute();方法修改属性 使用innerHTML属性修改元素的内容 查: 使用之前介绍的方法. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;script type="text/javascript"&gt;//在第一个div中动态增加一个a标签. 该a标签点击之后跳转到百度首页. function addNode()&#123; //1.获得 第一个div var div = document.getElementById("div_1"); //2.创建a标签 createElement==&gt;创建一个a标签 &lt;a&gt;&lt;/a&gt; var eleA = document.createElement("a"); //3.为a标签添加属性 &lt;a href="http://www.baidu.com"&gt;&lt;/a&gt; eleA.setAttribute("href", "http://www.baidu.com"); //4.为a标签添加内容 &lt;a href="http://www.baidu.com"&gt;百度&lt;/a&gt; eleA.innerHTML = "百度"; //5.将a标签添加到div中 div.appendChild(eleA); &#125; //点击后 删除div区域2 function deleteNode()&#123; //1 获得要删除的div区域 var div = document.getElementById("div_2"); //2.获得父亲 var parent = div.parentNode; //3 由父亲操刀 parent.removeChild(div); &#125; //点击后 替换div区域3 为一个美女 function updateNode()&#123; //1 获得要替换的div区域3 var div = document.getElementById("div_3"); //2创建img标签对象 &lt;img /&gt; var img = document.createElement("img"); //3添加属性 &lt;img src="001.jpg" /&gt; img.setAttribute("src", "001.JPG"); //4.获得父节点 var parent = div.parentNode; //5.替换 parent.replaceChild(img, div); &#125; //点击后 将div区域4 克隆一份 添加到页面底部 function copyNode()&#123; //1.获取要克隆的div var div = document.getElementById("div_4"); //2.克隆 参数为true 那么克隆时克隆所有子元素. false 只克隆自己 var div_copy = div.cloneNode(true); //3.获得父亲 var parent = div.parentNode; //4.添加 parent.appendChild(div_copy); &#125; &lt;/script&gt; 4.2 修改 HTML DOM 改变 HTML 内容 ​ 改变元素内容的最简答的方法是使用 innerHTML ，innerText。 改变 CSS 样式 12&lt;p id="p2"&gt;Hello world!&lt;/p&gt;document.getElementById("p2").style.color="blue";&lt;br&gt; .style.fontSize=48px 改变 HTML 属性 ​ elementNode.setAttribute(name,value) ​ elementNode.getAttribute(name)elementNode.value(DHTML) 创建新的 HTML 元素 ​ createElement(name) 删除已有的 HTML 元素 ​ elementNode.removeChild(node) 关于class的操作 ​ elementNode.className ​ elementNode.classList.add ​ elementNode.classList.remove]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css基础]]></title>
    <url>%2F2018%2F12%2F09%2Fcss%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[CSS 语法CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明。 123456selector &#123; property: value; property: value; ... property: value &#125; 例如： 1h1 &#123;color:red; font-size:14px;&#125; css的四种引入方式1.行内式行内式是在标记的style属性中设定CSS样式。这种方式没有体现出CSS的优势，不推荐使用。 1&lt;p style="background-color: rebeccapurple"&gt;hello yuan&lt;/p&gt; 2.嵌入式嵌入式是将CSS样式集中写在网页的标签对的标签对中。格式如下： 123456789&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; p&#123; background-color: #2b99ff; &#125; &lt;/style&gt;&lt;/head&gt; 3 链接式将一个.css文件引入到HTML文件中 1&lt;link href="mystyle.css" rel="stylesheet" type="text/css"/&gt; 4.导入式将一个独立的.css文件引入HTML文件中，导入式使用CSS规则引入外部CSS文件，&lt;style&gt;标记也是写在&lt;head&gt;标记中，使用的语法如下： 12345&lt;style type="text/css"&gt; @import"mystyle.css"; 此处要注意.css文件的路径&lt;/style&gt; 注意： ​ 导入式会在整个网页装载完后再装载CSS文件，因此这就导致了一个问题，如果网页比较大则会儿出现先显示无样式的页面，闪烁一下之后，再出现网页的样式。这是导入式固有的一个缺陷。使用链接式时与导入式不同的是它会以网页文件主体装载前装载CSS文件，因此显示出来的网页从一开始就是带样式的效果的，它不会象导入式那样先显示无样式的网页，然后再显示有样式的网页，这是链接式的优点。 css选择器基本选择器 组合选择器123456789E,F 多元素选择器，同时匹配所有E元素或F元素，E和F之间用逗号分隔 :div,p &#123; color:#f00; &#125; E F 后代元素选择器，匹配所有属于E元素后代的F元素，E和F之间用空格分隔 :li a &#123; font-weight:bold;｝ E &gt; F 子元素选择器，匹配所有E元素的子元素F :div &gt; p &#123; color:#f00; &#125; E + F 毗邻元素选择器，匹配所有紧随E元素之后的同级元素F :div + p &#123; color:#f00; &#125; E ~ F 普通兄弟选择器（以破折号分隔） :.div1 ~ p&#123;font-size: 30px; &#125; 属性选择器12345678910111213141516E[att] 匹配所有具有att属性的E元素，不考虑它的值。（注意：E在此处可以省略。 比如“[cheacked]”。以下同。） p[title] &#123; color:#f00; &#125; E[att=val] 匹配所有att属性等于“val”的E元素 div[class=”error”] &#123; color:#f00; &#125; E[att~=val] 匹配所有att属性具有多个空格分隔的值、其中一个值等于“val”的E元素 td[class~=”name”] &#123; color:#f00; &#125; E[attr^=val] 匹配属性值以指定值开头的每个元素 div[class^="test"]&#123;background:#ffff00;&#125; E[attr$=val] 匹配属性值以指定值结尾的每个元素 div[class$="test"]&#123;background:#ffff00;&#125; E[attr*=val] 匹配属性值中包含指定值的每个元素 div[class*="test"]&#123;background:#ffff00;&#125; 伪类anchor伪类：专用于控制链接的显示效果12345678910111213141516171819202122''' a:link（没有接触过的链接）,用于定义了链接的常规状态。 a:hover（鼠标放在链接上的状态）,用于产生视觉效果。 a:visited（访问过的链接）,用于阅读文章，能清楚的判断已经访问过的链接。 a:active（在链接上按下鼠标时的状态）,用于表现鼠标按下时的链接状态。 伪类选择器 : 伪类指的是标签的不同状态: a ==&gt; 点过状态 没有点过的状态 鼠标悬浮状态 激活状态 a:link &#123;color: #FF0000&#125; /* 未访问的链接 */ a:visited &#123;color: #00FF00&#125; /* 已访问的链接 */ a:hover &#123;color: #FF00FF&#125; /* 鼠标移动到链接上 */ a:active &#123;color: #0000FF&#125; /* 选定的链接 */ 格式: 标签:伪类名称&#123; css代码; &#125;''' 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .top&#123; background-color: rebeccapurple; width: 100px; height: 100px; &#125; .bottom&#123; background-color: green; width: 100px; height: 100px; &#125; .outer:hover .bottom&#123; background-color: yellow; &#125; 注意:一定是outer:hover 控制outer里某一个标签,否则无效 .top:hover .bottom&#123; background-color: yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="outer"&gt; &lt;div class="top"&gt;top&lt;/div&gt; &lt;div class="bottom"&gt;bottom&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; before after伪类1234 :before p:before 在每个&lt;p&gt;元素之前插入内容 :after p:after 在每个&lt;p&gt;元素之后插入内容 例：p:before&#123;content:"hello";color:red;display: block;&#125; 选择器的优先级 css的继承继承是CSS的一个主要特征，它是依赖于祖先-后代的关系的。继承是一种机制，它允许样式不仅可以应用于某个特定的元素，还可以应用于它的后代。例如一个BODY定义了的颜色值也会应用到段落的文本中。 1body&#123;color:red;&#125; &lt;p&gt;helloyuan&lt;/p&gt; 这段文字都继承了由body {color:red;}样式定义的颜色。然而CSS继承性的权重是非常低的，是比普通元素的权重还要低的0。 1p&#123;color:green&#125; 发现只需要给加个颜色值就能覆盖掉它继承的样式颜色。由此可见：任何显示申明的规则都可以覆盖其继承样式。 ​ 此外，继承是CSS重要的一部分，我们甚至不用去考虑它为什么能够这样，但CSS继承也是有限制的。有一些属性不能被继承，如：border, margin, padding, background等。 12345div&#123; border:1px solid #222&#125;&lt;div&gt;hello &lt;p&gt;yuan&lt;/p&gt; &lt;/div&gt; css的优先级所谓CSS优先级，即是指CSS样式在浏览器中被解析的先后顺序。 样式表中的特殊性描述了不同规则的相对权重，它的基本规则是： 1 内联样式表的权值最高 style=””－－－－－－－－－－－－1000； 2 统计选择符中的ID属性个数。 #id －－－－－－－－－－－－－－100 3 统计选择符中的CLASS属性个数。 .class －－－－－－－－－－－－－10 4 统计选择符中的HTML标签名个数。 p －－－－－－－－－－－－－-－1 按这些规则将数字符串逐位相加，就得到最终的权重，然后在比较取舍时按照从左到右的顺序逐位比较。 1234567891、文内的样式优先级为1,0,0,0，所以始终高于外部定义。 2、有!important声明的规则高于一切。3、如果!important声明冲突，则比较优先权。4、如果优先权一样，则按照在源码中出现的顺序决定，后来者居上。5、由继承而得到的样式没有specificity的计算，它低于一切其它规则(比如全局选择符*定义的规则)。 css属性操作css text文本颜色：color颜色属性被用来设置文字的颜色。 颜色是通过CSS最经常的指定： 十六进制值 - 如: ＃FF0000 一个RGB值 - 如: RGB(255,0,0) 颜色的名称 - 如: red 1p &#123; color: rebeccapurple; &#125; 水平对齐方式text-align 属性规定元素中的文本的水平对齐方式。 left 把文本排列到左边。默认值：由浏览器决定。 right 把文本排列到右边。 center 把文本排列到中间。 justify 实现两端对齐文本效果。 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;css&lt;/title&gt;&lt;style&gt; h2 &#123;text-align:center;&#125; p.publish_time &#123;text-align:right;&#125; p.content &#123;text-align:justify;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;CSS text-align 水平居中&lt;/h1&gt;&lt;p class="publish_time"&gt;2017 年 5 月 17 号&lt;/p&gt;&lt;p class="content"&gt; 有个落拓不得志的中年人每隔三两天就到教堂祈祷，而且他的祷告词几乎每次都相同。第一次他到教堂时， 跪在圣坛前，虔诚地低语：“上帝啊，请念在我多年来敬畏您的份上。让我中一次彩票吧！阿门。” 几天后，他又垂头丧气回到教堂，同样跪着祈祷：“上帝啊，为何不让我中彩票？我愿意更谦卑地来 服侍你，求您让我中一次彩票吧！阿门。”又过了几天，他再次出现在教堂，同样重复他的祈祷。如此周而 复始，不间断地祈求着。到了最后一次，他跪着：“我的上帝，为何您不垂听我的祈求？让我中一次彩票吧！ 只要一次，让我解决所有困难，我愿终身奉献，专心侍奉您……”就在这时，圣坛上发出一阵宏伟庄严的声 音：“我一直垂听你的祷告。可是最起码？你也该先去买一张彩票吧!”&lt;/p&gt;&lt;p&gt;&lt;b&gt;注意：&lt;/b&gt; 重置浏览器窗口大小查看 &amp;quot;justify&amp;quot; 是如何工作的。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 文本其它属性12345678910111213141516171819202122232425262728/*font-size: 10px;line-height: 200px; 文本行高 通俗的讲，文字高度加上文字上下的空白区域的高度 50%:基于字体大小的百分比vertical-align:－4px 设置元素内容的垂直对齐方式 ,只对行内元素有效，对块级元素无效text-decoration:none text-decoration 属性用来设置或删除文本的装饰。主要是用来删除链接的下划线font-family: 'Lucida Bright'font-weight: lighter/bold/border/font-style: obliquetext-indent: 150px; 首行缩进150pxletter-spacing: 10px; 字母间距word-spacing: 20px; 单词间距text-transform: capitalize/uppercase/lowercase ; 文本转换，用于所有字句变成大写或小写字母，或每个单词的首字母大写*/ 背景属性属性介绍 background-color background-image background-repeat background-position 1234567background-color: cornflowerblue background-image: url('1.jpg'); background-repeat: no-repeat;(repeat:平铺满) background-position: right top（20px 20px）; 简写1background:#ffffff url('1.png') no-repeat right top; 边框属性属性介绍 border-width border-style (required) border-color 12345border-style: solid; border-color: chartreuse; border-width: 20px; 简写 1简写：border: 30px rebeccapurple solid; 边框-单独设置各边1234border-top-style:dotted;border-right-style:solid;border-bottom-style:dotted;border-left-style:none; 列表属性12345list-style-type 设置列表项标志的类型。list-style-image 将图象设置为列表项标志。list-style-position 设置列表中列表项标志的位置。 list-style 简写属性。用于把所有用于列表的属性设置于一个声明中 ist-style-type属性指定列表项标记的类型： 1ul &#123; list-style-type: square; &#125; 使用图像来替换列表项的标记: 123ul &#123; list-style-image: url(''); &#125; dispaly属性 none block inline inline-block none(隐藏某标签)1p&#123;display:none;&#125; 注意与visibility:hidden的区别： visibility:hidden可以隐藏某个元素，但隐藏的元素仍需占用与未隐藏之前一样的空间。也就是说，该元素虽然被隐藏了，但仍然会影响布局。 display:none可以隐藏某个元素，且隐藏的元素不会占用任何空间。也就是说，该元素不但被隐藏了，而且该元素原本占用的空间也会从页面布局中消失。 block(内联标签设置为块级标签)1span &#123;display:block;&#125; inline(块级标签设置为内联标签)1li &#123;display:inline;&#125; inline-blockdisplay:inline-block可做列表布局，其中的类似于图片间的间隙小bug可以通过如下设置解决： 1234#outer&#123; border: 3px dashed; word-spacing: -5px; &#125; 外边距(margine)和内边距(padding)盒子模型 margin: 用于控制元素与元素之间的距离；margin的最基本用途就是控制元素周围空间的间隔，从视觉角度上达到相互隔开的目的。 padding: 用于控制内容与边框之间的距离； Border(边框): 围绕在内边距和内容外的边框。 Content(内容): 盒子的内容，显示文本和图像。 margine(外边距)单边外边距属性 1234margin-top:100px;margin-bottom:100px;margin-right:50px;margin-left:50px; 简写属性 123456789101112131415161718192021margin:10px 20px 20px 10px； 上边距为10px 右边距为20px 下边距为20px 左边距为10pxmargin:10px 20px 10px; 上边距为10px 左右边距为20px 下边距为10pxmargin:10px 20px; 上下边距为10px 左右边距为20pxmargin:25px; 所有的4个边距都是25px 居中应用 1margin: 0 auto; padding(内边距)单独使用填充属性可以改变上下左右的填充。缩写填充属性也可以使用，一旦改变一切都改变。 设置同margine； 页码实例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .outer&#123; margin: 0 auto; width: 80%; &#125; .content&#123; background-color: darkgrey; height: 500px; &#125; a&#123; text-decoration: none; &#125; .page-area&#123; text-align: center; padding-top: 30px; padding-bottom: 30px; background-color: #f0ad4e; &#125; .page-area ul li&#123; display: inline-block; &#125; .page-area ul li a ,.page-area ul li span&#123; display: inline-block; color: #369; height: 25px; width: 25px; text-align: center; line-height: 25px; padding: 8px; margin-left: 8px; border: 1px solid #e1e1e1; border-radius: 15%; &#125; .page-area ul li .page-next&#123; width: 70px; border-radius:0 &#125; .page-area ul li span.current_page&#123; border: none; color: black; font-weight:900; &#125; .page-area ul li a:hover&#123; color: #fff; background-color: #2459a2; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="outer"&gt;&lt;div class="content"&gt;&lt;/div&gt;&lt;div class="page-area"&gt; &lt;ul&gt; &lt;li&gt;&lt;span class="current_page"&gt;1&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#" class="page-a"&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#" class="page-a"&gt;3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#" class="page-a"&gt;4&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#" class="page-a"&gt;5&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#" class="page-a"&gt;6&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#" class="page-a"&gt;7&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#" class="page-a"&gt;8&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#" class="page-a"&gt;9&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#" class="page-a"&gt;10&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#" class="page-a page-next"&gt;下一页&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 思考1:body的外边距 ​ 边框在默认情况下会定位于浏览器窗口的左上角，但是并没有紧贴着浏览器的窗口的边框，这是因为body本身也是一个盒子（外层还有html），在默认情况下， body距离html会有若干像素的margin，具体数值因各个浏览器不尽相同，所以body中的盒子不会紧贴浏览器窗口的边框了，为了验证这一点，加上： 1234body&#123; border: 1px solid; background-color: cadetblue;&#125; 解决方法： 123*&#123; margin: 0;&#125; 思考2：margin collapse（边界塌陷或者说边界重叠） 1、兄弟div：上面div的margin-bottom和下面div的margin-top会塌陷，也就是会取上下两者margin里最大值作为显示值 2、父子div：if 父级div中没有border，padding，inlinecontent，子级div的margin会一直向上找，直到找到某个标签包括border，padding，inline content中的其中一个，然后按此div 进行margin； 解决方法： 1overflow: hidden; float属性基本浮动规则先来了解一下block元素和inline元素在文档流中的排列方式。 block元素通常被现实为独立的一块，独占一行，多个block元素会各自新起一行，默认block元素宽度自动填满其父元素宽度。block元素可以设置width、height、margin、padding属性； inline元素不会独占一行，多个相邻的行内元素会排列在同一行里，直到一行排列不下，才会新换一行，其宽度随元素的内容而变化。inline元素设置width、height属性无效 常见的块级元素有 div、form、table、p、pre、h1～h5、dl、ol、ul 等。 常见的内联元素有span、a、strong、em、label、input、select、textarea、img、br等 所谓的文档流，指的是元素排版布局过程中，元素会自动从左往右，从上往下的流式排列。 脱离文档流，也就是将元素从普通的布局排版中拿走，其他盒子在定位的时候，会当做脱离文档流的元素不存在而进行定位。 ​ 假如某个div元素A是浮动的，如果A元素上一个元素也是浮动的，那么A元素会跟随在上一个元素的后边(如果一行放不下这两个元素，那么A元素会被挤到下一行)；如果A元素上一个元素是标准流中的元素，那么A的相对垂直位置不会改变，也就是说A的顶部总是和上一个元素的底部对齐。此外，浮动的框之后的block元素元素会认为这个框不存在，但其中的文本依然会为这个元素让出位置。 浮动的框之后的inline元素，会为这个框空出位置，然后按顺序排列。 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; &#125; .r1&#123; width: 300px; height: 100px; background-color: #7A77C8; float: left; &#125; .r2&#123; width: 200px; height: 200px; background-color: wheat; /*float: left;*/ &#125; .r3&#123; width: 100px; height: 200px; background-color: darkgreen; float: left; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="r1"&gt;&lt;/div&gt;&lt;div class="r2"&gt;&lt;/div&gt;&lt;div class="r3"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 非完全脱离文档流左右结构div盒子重叠现象，一般是由于相邻两个DIV一个使用浮动一个没有使用浮动。一个使用浮动一个没有导致DIV不是在同个“平面”上，但内容不会造成覆盖现象，只有DIV形成覆盖现象。 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; &#125; .r1&#123; width: 100px; height: 100px; background-color: #7A77C8; float: left; &#125; .r2&#123; width: 200px; height: 200px; background-color: wheat; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="r1"&gt;&lt;/div&gt;&lt;div class="r2"&gt;region2&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 解决方法：要么都不使用浮动；要么都使用float浮动；要么对没有使用float浮动的DIV设置margin样式。 父级坍塌现象123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;style type="text/css"&gt; * &#123; margin:0;padding:0; &#125; .container&#123; border:1px solid red;width:300px; &#125; #box1&#123; background-color:green;float:left;width:100px;height:100px; &#125; #box2&#123; background-color:deeppink; float:right;width:100px;height:100px; &#125; #box3&#123; background-color:pink;height:40px; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div id="box1"&gt;box1 向左浮动&lt;/div&gt; &lt;div id="box2"&gt;box2 向右浮动&lt;/div&gt; &lt;/div&gt; &lt;div id="box3"&gt;box3&lt;/div&gt;&lt;/body&gt;&lt;/body&gt;&lt;/html&gt; 例子如上：.container和box3的布局是上下结构，上图发现box3跑到了上面，与.container产生了重叠，但文本内容没有发生覆盖，只有div发生覆盖现象。这个原因是因为第一个大盒子里的子元素使用了浮动，脱离了文档流，导致.container没有被撑开。box3认为.container没有高度（未被撑开），因此跑上去了。 解决方法： 1、固定高度 给.container设置固定高度，一般情况下文字内容不确定多少就不能设置固定高度，所以一般不能设置“.container”高度(当然能确定内容多高，这种情况下“.container是可以设置一个高度即可解决覆盖问题。 或者给.container加一个固定高度的子div： 123456&lt;div class="container"&gt; &lt;div id="box1"&gt;box1 向左浮动&lt;/div&gt; &lt;div id="box2"&gt;box2 向右浮动&lt;/div&gt; &lt;div id="empty" style="height: 100px"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div id="box3"&gt;box3&lt;/div&gt; 但是这样限定固定高度会使页面操作不灵活，不推荐！ 2、清除浮动(推荐)。 clear语法：clear : none | left | right | both 取值：none : 默认值。允许两边都可以有浮动对象left : 不允许左边有浮动对象right : 不允许右边有浮动对象both : 不允许有浮动对象 但是需要注意的是：clear属性只会对自身起作用，而不会影响其他元素。 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; &#125; .r1&#123; width: 300px; height: 100px; background-color: #7A77C8; float: left; &#125; .r2&#123; width: 200px; height: 200px; background-color: wheat; float: left; clear: left; &#125; .r3&#123; width: 100px; height: 200px; background-color: darkgreen; float: left; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="r1"&gt;&lt;/div&gt;&lt;div class="r2"&gt;&lt;/div&gt;&lt;div class="r3"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 把握住两点：1、元素是从上到下、从左到右依次加载的。 ​ 2、clear: left;对自身起作用，一旦左边有浮动元素，即切换到下一行来保证左边元素不是浮动的，依据这一点解决父级塌陷问题。 思考： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; &#125; .r1&#123; width: 300px; height: 100px; background-color: #7A77C8; float: left; &#125; .r2&#123; width: 200px; height: 200px; background-color: wheat; float: left; clear: both; &#125; .r3&#123; width: 100px; height: 200px; background-color: darkgreen; float: left; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="r1"&gt;&lt;/div&gt;&lt;div class="r2"&gt;&lt;/div&gt;&lt;div class="r3"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 解决父级塌陷： 12345678910111213141516171819202122''' .clearfix:after &#123; &lt;----在类名为“clearfix”的元素内最后面加入内容； content: "."; &lt;----内容为“.”就是一个英文的句号而已。也可以不写。 display: block; &lt;----加入的这个元素转换为块级元素。 clear: both; &lt;----清除左右两边浮动。 visibility: hidden; &lt;----可见度设为隐藏。注意它和display:none;是有区别的。 visibility:hidden;仍然占据空间，只是看不到而已； line-height: 0; &lt;----行高为0； height: 0; &lt;----高度为0； font-size:0; &lt;----字体大小为0； &#125; .clearfix &#123; *zoom:1;&#125; &lt;----这是针对于IE6的，因为IE6不支持:after伪类，这个神 奇的zoom:1让IE6的元素可以清除浮动来包裹内部元素。整段代码就相当于在浮动元素后面跟了个宽高为0的空div，然后设定它clear:both来达到清除浮动的效果。之所以用它，是因为，你不必在html文件中写入大量无意义的空标签，又能清除浮动。&lt;div class="head clearfix"&gt;&lt;/div&gt;''' 3、overflow:hidden overflow：hidden的含义是超出的部分要裁切隐藏，float的元素虽然不在普通流中，但是他是浮动在普通流之上的，可以把普通流元素+浮动元素想象成一个立方体。如果没有明确设定包含容器高度的情况下，它要计算内容的全部高度才能确定在什么位置hidden，这样浮动元素的高度就要被计算进去。这样包含容器就会被撑开，清除浮动。 position(定位)1 staticstatic 默认值，无定位，不能当作绝对定位的参照物，并且设置标签对象的left、top等值是不起作用的的。 2 position: relative／absoluterelative: 相对定位。 相对定位是相对于该元素在文档流中的原始位置，即以自己原始位置为参照物。有趣的是，即使设定了元素的相对定位以及偏移值，元素还占有着原来的位置，即占据文档流空间。对象遵循正常文档流，但将依据top，right，bottom，left等属性在正常文档流中偏移位置。而其层叠通过z-index属性定义。 注意：position：relative的一个主要用法：方便绝对定位元素找到参照物。 absolute: 绝对定位。 定义：设置为绝对定位的元素框从文档流完全删除，并相对于最近的已定位祖先元素定位，如果元素没有已定位的祖先元素，那么它的位置相对于最初的包含块（即body元素）。元素原先在正常文档流中所占的空间会关闭，就好像该元素原来不存在一样。元素定位后生成一个块级框，而不论原来它在正常流中生成何种类型的框。 重点：如果父级设置了position属性，例如position:relative;，那么子元素就会以父级的左上角为原始点进行定位。这样能很好的解决自适应网站的标签偏离问题，即父级为自适应的，那我子元素就设置position:absolute;父元素设置position:relative;，然后Top、Right、Bottom、Left用百分比宽度表示。 另外，对象脱离正常文档流，使用top，right，bottom，left等属性进行绝对定位。而其层叠通过z-index属性定义。 示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; &#125; .outet&#123; /*position: relative;*/ &#125; .item&#123; width: 200px; height:200px ; &#125; .r1&#123; background-color: #7A77C8; &#125; .r2&#123; background-color: wheat; /*position: relative;*/ position: absolute; top: 200px; left: 200px; &#125; .r3&#123; background-color: darkgreen; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="item r1"&gt;&lt;/div&gt;&lt;div class="outet"&gt; &lt;div class="item r2"&gt;&lt;/div&gt; &lt;div class="item r3"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 总结：参照物用相对定位，子元素用绝对定位，并且保证相对定位参照物不会偏移即可。 3 position:fixedfixed：对象脱离正常文档流，使用top，right，bottom，left等属性以窗口为参考点进行定位，当出现滚动条时，对象不会随着滚动。而其层叠通过z-index属性 定义。 注意点： 一个元素若设置了 position:absolute | fixed; 则该元素就不能设置float。这 是一个常识性的知识点，因为这是两个不同的流，一个是浮动流，另一个是“定位流”。但是 relative 却可以。因为它原本所占的空间仍然占据文档流。 ​ 在理论上，被设置为fixed的元素会被定位于浏览器窗口的一个指定坐标，不论窗口是否滚动，它都会固定在这个位置。 示例代码： 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; &#125; .back&#123; background-color: wheat; width: 100%; height: 1200px; &#125; span&#123; display: inline-block; width: 80px; height: 50px; position: fixed; bottom: 20px; right: 20px; background-color: rebeccapurple; color: white; text-align: center; line-height: 50px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="back"&gt; &lt;span&gt;返回顶部&lt;/span&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql进阶]]></title>
    <url>%2F2018%2F12%2F05%2Fmysql%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[视图（不常用）临时表搜索1234SELECT * FROM (SELECT nid,NAME FROM tb1 WHERE nid &gt; 2 ) AS AWHERE A. NAME &gt; 'alex'; 创建视图123--格式：CREATE VIEW 视图名称 AS SQL语句CREATE VIEW v1 AS SELET nid,name FROM A WHERE nid &gt; 4 删除视图12--格式：DROP VIEW 视图名称DROP VIEW v1 修改视图123456789101112-- 格式：ALTER VIEW 视图名称 AS SQL语句 ALTER VIEW v1 ASSELET A.nid, B. NAMEFROM ALEFT JOIN B ON A.id = B.nidLEFT JOIN C ON A.id = C.nidWHERE A.id &gt; 2AND C.nid &lt; 5 使用视图使用视图时，将其当作表进行操作即可，由于视图是虚拟表，所以无法使用其对真实表进行创建、更新和删除操作，仅能做查询用。 1select * from v1 触发器对某个表进行【增/删/改】操作的前后如果希望触发某个特定的行为时，可以使用触发器，触发器用于定制用户对表的行进行【增/删/改】前后的行为。 1、创建基本语法1234567891011121314151617181920212223242526272829303132333435# 插入前CREATE TRIGGER tri_before_insert_tb1 BEFORE INSERT ON tb1 FOR EACH ROWBEGIN ...END # 插入后CREATE TRIGGER tri_after_insert_tb1 AFTER INSERT ON tb1 FOR EACH ROWBEGIN ...END # 删除前CREATE TRIGGER tri_before_delete_tb1 BEFORE DELETE ON tb1 FOR EACH ROWBEGIN ...END # 删除后CREATE TRIGGER tri_after_delete_tb1 AFTER DELETE ON tb1 FOR EACH ROWBEGIN ...END # 更新前CREATE TRIGGER tri_before_update_tb1 BEFORE UPDATE ON tb1 FOR EACH ROWBEGIN ...END # 更新后CREATE TRIGGER tri_after_update_tb1 AFTER UPDATE ON tb1 FOR EACH ROWBEGIN ...END 插入前触发器 1234567891011delimiter //CREATE TRIGGER tri_before_insert_tb1 BEFORE INSERT ON tb1 FOR EACH ROWBEGIN IF NEW. NAME == 'alex' THEN INSERT INTO tb2 (NAME)VALUES ('aa')ENDEND//delimiter ; 插入后触发器 12345678910111213141516delimiter //CREATE TRIGGER tri_after_insert_tb1 AFTER INSERT ON tb1 FOR EACH ROWBEGIN IF NEW. num = 666 THEN INSERT INTO tb2 (NAME) VALUES ('666'), ('666') ; ELSEIF NEW. num = 555 THEN INSERT INTO tb2 (NAME) VALUES ('555'), ('555') ; END IF;END//delimiter ; 2、删除触发器1DROP TRIGGER tri_after_insert_tb1; 3、使用触发器触发器无法由用户直接调用，而知由于对表的【增/删/改】操作被动引发的。 函数MySQL中提供了许多内置函数，例如： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899CHAR_LENGTH(str) 返回值为字符串str 的长度，长度的单位为字符。一个多字节字符算作一个单字符。 对于一个包含五个二字节字符集, LENGTH()返回值为 10, 而CHAR_LENGTH()的返回值为5。 CONCAT(str1,str2,...) 字符串拼接 如有任何一个参数为NULL ，则返回值为 NULL。CONCAT_WS(separator,str1,str2,...) 字符串拼接（自定义连接符） CONCAT_WS()不会忽略任何空字符串。 (然而会忽略所有的 NULL）。 CONV(N,from_base,to_base) 进制转换 例如： SELECT CONV('a',16,2); 表示将 a 由16进制转换为2进制字符串表示 FORMAT(X,D) 将数字X 的格式写为'#,###,###.##',以四舍五入的方式保留小数点后 D 位， 并将结果以字符串的形式返回。若 D 为 0, 则返回结果不带有小数点，或不含小数部分。 例如： SELECT FORMAT(12332.1,4); 结果为： '12,332.1000'INSERT(str,pos,len,newstr) 在str的指定位置插入字符串 pos：要替换位置其实位置 len：替换的长度 newstr：新字符串 特别的： 如果pos超过原字符串长度，则返回原字符串 如果len超过原字符串长度，则由新字符串完全替换INSTR(str,substr) 返回字符串 str 中子字符串的第一个出现位置。 LEFT(str,len) 返回字符串str 从开始的len位置的子序列字符。 LOWER(str) 变小写 UPPER(str) 变大写 LTRIM(str) 返回字符串 str ，其引导空格字符被删除。RTRIM(str) 返回字符串 str ，结尾空格字符被删去。SUBSTRING(str,pos,len) 获取字符串子序列 LOCATE(substr,str,pos) 获取子序列索引位置 REPEAT(str,count) 返回一个由重复的字符串str 组成的字符串，字符串str的数目等于count 。 若 count &lt;= 0,则返回一个空字符串。 若str 或 count 为 NULL，则返回 NULL 。REPLACE(str,from_str,to_str) 返回字符串str 以及所有被字符串to_str替代的字符串from_str 。REVERSE(str) 返回字符串 str ，顺序和字符顺序相反。RIGHT(str,len) 从字符串str 开始，返回从后边开始len个字符组成的子序列 SPACE(N) 返回一个由N空格组成的字符串。 SUBSTRING(str,pos) , SUBSTRING(str FROM pos) SUBSTRING(str,pos,len) , SUBSTRING(str FROM pos FOR len) 不带有len 参数的格式从字符串str返回一个子字符串，起始于位置 pos。带有len参数的格式从字符串str返回一个长度同len字符相同的子字符串，起始于位置 pos。 使用 FROM的格式为标准 SQL 语法。也可能对pos使用一个负值。假若这样，则子字符串的位置起始于字符串结尾的pos 字符，而不是字符串的开头位置。在以下格式的函数中可以对pos 使用一个负值。 mysql&gt; SELECT SUBSTRING('Quadratically',5); -&gt; 'ratically' mysql&gt; SELECT SUBSTRING('foobarbar' FROM 4); -&gt; 'barbar' mysql&gt; SELECT SUBSTRING('Quadratically',5,6); -&gt; 'ratica' mysql&gt; SELECT SUBSTRING('Sakila', -3); -&gt; 'ila' mysql&gt; SELECT SUBSTRING('Sakila', -5, 3); -&gt; 'aki' mysql&gt; SELECT SUBSTRING('Sakila' FROM -4 FOR 2); -&gt; 'ki' TRIM([&#123;BOTH | LEADING | TRAILING&#125; [remstr] FROM] str) TRIM(remstr FROM] str) 返回字符串 str ， 其中所有remstr 前缀和/或后缀都已被删除。若分类符BOTH、LEADIN或TRAILING中没有一个是给定的,则假设为BOTH 。 remstr 为可选项，在未指定情况下，可删除空格。 mysql&gt; SELECT TRIM(' bar '); -&gt; 'bar' mysql&gt; SELECT TRIM(LEADING 'x' FROM 'xxxbarxxx'); -&gt; 'barxxx' mysql&gt; SELECT TRIM(BOTH 'x' FROM 'xxxbarxxx'); -&gt; 'bar' mysql&gt; SELECT TRIM(TRAILING 'xyz' FROM 'barxxyz'); -&gt; 'barx' 1、自定义函数 1234567891011delimiter \\create function f1( i1 int, i2 int)returns intBEGIN declare num int; set num = i1 + i2; return(num);END \\delimiter ; 2、删除函数 1drop function func_name; 3、执行函数 1234567# 获取返回值declare @i VARCHAR(32);select UPPER('alex') into @i;SELECT @i; # 在查询中使用select f1(11,nid) ,name from tb2; 存储过程 存储过程是一个SQL语句集合，当主动去调用存储过程时，其中内部的SQL语句会按照逻辑执行。 1、创建存储过程 无参数存储过程 12345678910111213-- 创建存储过程 delimiter //create procedure p1()BEGIN select * from t1;END//delimiter ; -- 执行存储过程 call p1() 对于存储过程，可以接收参数，其参数有三类： in 仅用于传入参数用 out 仅用于返回值用 inout 既可以传入又可以当作返回值 1234567891011121314151617181920212223242526-- 创建存储过程delimiter //create procedure p1( in i1 int, in i2 int, inout i3 int, out r1 int)BEGIN DECLARE temp1 int; DECLARE temp2 int default 0; set temp1 = 1; set r1 = i1 + i2 + temp1 + temp2; set i3 = i3 + 100; end//delimiter ; -- 执行存储过程set @t1 =4;set @t2 = 0;CALL p1 (1, 2 ,@t1, @t2);SELECT @t1,@t2; 1.事务事务用于将某些操作的多个SQL作为原子性操作，一旦有某一个出现错误，即可回滚到原来的状态，从而保证数据库数据完整性。 支持事务的存储过程: 1234567891011121314151617181920212223242526272829delimiter //create PROCEDURE p1( OUT p_return_code tinyint)BEGIN DECLARE exit handler for sqlexception BEGIN -- ERROR set p_return_code = 1; rollback; END; DECLARE exit handler for sqlwarning BEGIN -- WARNING set p_return_code = 2; rollback; END; START TRANSACTION; DELETE from tb1; insert into tb2(name)values('seven'); COMMIT; -- SUCCESS set p_return_code = 0; END//delimiter ; 123set@i =0;call p1(@i);select @i; 2.游标有数据缓冲的思想：游标的设计是一种数据缓冲区的思想，用来存放SQL语句执行的结果。 先有数据基础：游标是在先从数据表中检索出数据之后才能继续灵活操作的技术。 类似于指针：游标类似于指向数据结构堆栈中的指针，用来pop出所指向的数据，并且只能每次取一个。 游标的使用场景： 针对游标的优缺点，游标主要用在循环处理、存储过程、函数中使用，用来查询结果集，就比如：我们需要从表中循环判断并得到想要的结果集，这时候使用游标操作很方便速度也很快。 1234567891011121314151617delimiter //CREATE PROCEDURE pro_try()BEGINDECLARE name1 int;DECLARE done boolean DEFAULT FALSE; DECLARE old_num CURSORFORSELECT price FROM test4;DECLARE CONTINUE HANDLER FOR NOT FOUND set done = TRUE;OPEN old_num;REPEATFETCH old_num into name1;INSERT into test5(name)VALUES(name1+1);UNTIL done END REPEAT;CLOSE old_num;end //delimiter ; 3.动态执行SQL（防sql注入）12345678910delimiter //CREATE PROCEDURE p4 (in nid int)BEGINset @nid = nid；PREPARE prod FROM 'select * from student where sid &gt; ?';EXECUTE prod USING @nid;DEALLOCATE prepare prod; END//delimiter ; 索引 1、索引索引是表的目录，在查找内容之前可以先在目录中查找索引位置，以此快速定位查询数据。对于索引，会保存在额外的文件中。 2、索引种类普通索引：仅加速查询唯一索引：加速查询 + 列值唯一（可以有null）主键索引：加速查询 + 列值唯一 + 表中只有一个（不可以有null）组合索引：多列值组成一个索引， 专门用于组合搜索，其效率大于索引合并全文索引：对文本的内容进行分词，进行搜索索引合并，使用多个单列索引组合搜索 覆盖索引，select的数据列只用从索引中就能够取得，不必读取数据行，换句话说查询列要被所建的索引覆盖 3、相关命令查看表结构 1desc 表名 查看生成表的SQL 1show create table 表名 查看索引 1show index from 表名 查看执行时间 12345set profiling = 1;SQL...show profiles; 4、使用索引和不使用索引由于索引是专门用于加速搜索而生，所以加上索引之后，查询效率会快到飞起来。 有索引 12mysql&gt; select * from tb1 where name = 'wzc';1 row in set (0.00 sec) 无索引 12mysql&gt; select * from tb1 where email = 'wzc123456@163.com';1 row in set (1.24 sec) 5、正确使用索引数据库表中添加索引后确实会让查询速度起飞，但前提必须是正确的使用索引来查询，如果以错误的方式使用，则即使建立索引也会不奏效。即使建立索引，索引也不会生效： like ‘%xx’ 1select * from tb1 where name like '%cn'; 使用函数 123select * from tb1 where reverse(name) = 'wupeiqi';orselect * from tb1 where nid = 1 or email = 'seven@live.com'; 特别的：当or条件中有未建立索引的列才失效，以下会走索引 12select * from tb1 where nid = 1 or name = 'seven';select * from tb1 where nid = 1 or email = 'seven@live.com' and name = 'alex' 类型不一致,如果列是字符串类型，传入条件是必须用引号引起来，不然… 123select * from tb1 where name = 999;!=select * from tb1 where name != 'alex' 特别的：如果是主键，则还是会走索引 123select * from tb1 where nid != 123&gt;select * from tb1 where name &gt; 'alex' 特别的：如果是主键或索引是整数类型，则还是会走索引 1234select * from tb1 where nid &gt; 123select * from tb1 where num &gt; 123order byselect email from tb1 order by name desc; 当根据索引排序时候，选择的映射如果不是索引，则不走索引 特别的：如果对主键排序，则还是走索引： 1select * from tb1 order by nid desc; 组合索引最左前缀 如果组合索引为：(name,email) name and email -- 使用索引 name -- 使用索引 email -- 不使用索引 6、其他注意事项避免使用select * count(1)或count(列) 代替 count(*) 创建表时尽量时 char 代替 varchar 表的字段顺序固定长度的字段优先 组合索引代替多个单列索引（经常使用多个条件查询时） 尽量使用短索引 使用连接（JOIN）来代替子查询(Sub-Queries) 连表时注意条件类型需一致 索引散列值（重复少）不适合建索引，例：性别不适合 7、limit分页无论是否有索引，limit分页是一个值得关注的问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354每页显示10条：当前 118 120， 125 倒序： 大 小 970 7 6 6 5 54 43 3219 98 下一页： select * from tb1 where nid &gt; (select nid from (select nid from tb1 where nid &lt; 当前页最小值 order by nid desc limit 每页数据 *【页码-当前页】) A order by A.nid asc limit 1) order by nid desc limit 10; select * from tb1 where nid &gt; (select nid from (select nid from tb1 where nid &lt; 970 order by nid desc limit 40) A order by A.nid asc limit 1) order by nid desc limit 10; 上一页： select * from tb1 where nid &lt; (select nid from (select nid from tb1 where nid &gt; 当前页最大值 order by nid asc limit 每页数据 *【当前页-页码】) A order by A.nid asc limit 1) order by nid desc limit 10; select * from tb1 where nid &lt; (select nid from (select nid from tb1 where nid &gt; 980 order by nid asc limit 20) A order by A.nid desc limit 1) order by nid desc limit 10; 8、执行计划explain + 查询SQL - 用于显示SQL执行信息参数，根据参考信息可以进行SQL优化 12mysql&gt; explain select * from tb2;1 row in set (0.00 sec)]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql基础]]></title>
    <url>%2F2018%2F12%2F05%2Fmysql%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[MySQL概述1、什么是数据库 ？ 答：数据的仓库，如：在ATM的示例中我们创建了一个 db 目录，称其为数据库 2、什么是 MySQL、Oracle、SQLite、Access、MS SQL Server等 ？ 答：他们均是一个软件，都有两个主要的功能： a. 将数据保存到文件或内存 b. 接收特定的命令，然后对文件进行相应的操作 3、什么是SQL ？ 答：MySQL等软件可以接受命令，并做出相应的操作，由于命令中可以包含删除文件、获取文件内容等众多操作，对于编写的命令就是是SQL语句。 MySQL安装MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下公司。MySQL 最流行的关系型数据库管理系统，在 WEB 应用方面MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。 想要使用MySQL来存储并操作数据，则需要做几件事情： a. 安装MySQL服务端 b. 安装MySQL客户端 c. 【客户端】连接【服务端】 d. 【客户端】发送命令给【服务端MySQL】服务的接受命令并执行相应操作(增删改查等) 下载 12345678http://dev.mysql.com/downloads/mysql/ 安装 windows： http://jingyan.baidu.com/article/f3ad7d0ffc061a09c3345bf0.html inux： yum install mysql-server mac： 一直点下一步 客户端连接 123456789连接： 1、mysql管理人默认为root，没有设置密码则直接登录 mysql -h host -u root -p 不用输入密码按回车自动进入 2、如果想设置mysql密码 mysqladmin -u root password 123456 3、如果你的root现在有密码了（123456），那么修改密码为abcdef的命令是： mysqladmin -u root -p password abcdef 退出： QUIT 或者 Control+D 数据库基础分为两大部分： ​ 1、数据库和表的创建; ​ 2、数据库和表内容的操作 1、数据库和表的创建（一）数据库的创建1.1、显示数据库1SHOW DATABASES; ​ 默认数据库： mysql - 用户权限相关数据 test - 用于用户测试数据 information_schema - MySQL本身架构相关数据 1.2、创建数据库12345# utf-8CREATE DATABASE 数据库名称 DEFAULT CHARSET utf8 COLLATE utf8_general_ci; # gbkCREATE DATABASE 数据库名称 DEFAULT CHARACTER SET gbk COLLATE gbk_chinese_ci; 1.3、打开数据库12USE db_name;注：每次使用数据库必须打开相应数据库 显示当前使用的数据库中所有表：SHOW TABLES; 1.4、用户管理用户设置: 123456789创建用户 create user &apos;用户名&apos;@&apos;IP地址&apos; identified by &apos;密码&apos;;删除用户 drop user &apos;用户名&apos;@&apos;IP地址&apos;;修改用户 rename user &apos;用户名&apos;@&apos;IP地址&apos;; to &apos;新用户名&apos;@&apos;IP地址&apos;;;修改密码 set password for &apos;用户名&apos;@&apos;IP地址&apos; = Password(&apos;新密码&apos;) PS：用户权限相关数据保存在mysql数据库的user表中，所以也可以直接对其进行操作（不建议） 用户权限设置: 123show grants for '用户'@'IP地址' -- 查看权限grant 权限 on 数据库.表 to '用户'@'IP地址' -- 授权revoke 权限 on 数据库.表 from '用户'@'IP地址' -- 取消权限 对于权限设置 123456789101112131415161718192021222324252627282930all privileges 除grant外的所有权限select 仅查权限select,insert 查和插入权限...usage 无访问权限alter 使用alter tablealter routine 使用alter procedure和drop procedurecreate 使用create tablecreate routine 使用create procedurecreate temporary tables 使用create temporary tablescreate user 使用create user、drop user、rename user和revoke all privilegescreate view 使用create viewdelete 使用deletedrop 使用drop tableexecute 使用call和存储过程file 使用select into outfile 和 load data infilegrant option 使用grant 和 revokeindex 使用indexinsert 使用insertlock tables 使用lock tableprocess 使用show full processlistselect 使用selectshow databases 使用show databasesshow view 使用show viewupdate 使用updatereload 使用flushshutdown 使用mysqladmin shutdown(关闭MySQL)super 􏱂􏰈使用change master、kill、logs、purge、master和set global。还允许mysqladmin􏵗􏵘􏲊􏲋调试登陆replication client 服务器位置的访问replication slave 由复制从属使用 对于数据库名的解释 12345对于目标数据库以及内部其他： 数据库名.* 数据库中的所有 数据库名.表 指定数据库中的某张表 数据库名.存储过程 指定数据库中的存储过程 *.* 所有数据库 对于ip地址的访问 123用户名@IP地址 用户只能在改IP下才能访问用户名@192.168.1.% 用户只能在改IP段下才能访问(通配符%表示任意)用户名@% 用户可以再任意IP下访问(默认IP地址为%) 实际例子 1234grant all privileges on db1.tb1 TO '用户名'@'IP'grant select on db1.* TO '用户名'@'IP'grant select,insert on *.* TO '用户名'@'IP'revoke select on db1.tb1 from '用户名'@'IP' 1.5、备份库和恢复库备份库： ​ MySQL备份和还原,都是利用mysqldump、mysql和source命令来完成。 1.在Windows下MySQL的备份与还原 12345678备份 1、开始菜单 | 运行 | cmd |利用“cd /Program Files/MySQL/MySQL Server 5.0/bin”命令进入bin文件夹 2、利用“mysqldump -u 用户名 -p databasename &gt;exportfilename”导出数据库到文件，如mysqldump -u root -p voice&gt;voice.sql，然后输入密码即可开始导出。 还原 1、进入MySQL Command Line Client，输入密码，进入到“mysql&gt;”。2、输入命令"show databases；"，回车，看看有些什么数据库；建立你要还原的数据库，输入"create database voice；"，回车。3、切换到刚建立的数据库，输入"use voice；"，回车；导入数据，输入"source voice.sql；"，回车，开始导入，再次出现"mysql&gt;"并且没有提示错误即还原成功。 2、在linux下MySQL的备份与还原 12345672.1 备份(利用命令mysqldump进行备份) [root@localhost mysql]# mysqldump -u root -p voice&gt;voice.sql，输入密码即可。2.2 还原方法一： [root@localhost ~]# mysql -u root -p 回车，输入密码，进入MySQL的控制台"mysql&gt;"，同1.2还原。方法二： [root@localhost mysql]# mysql -u root -p voice&lt;voice.sql，输入密码即可。 3、更多备份及还原命令 1234567891011121314151617181920212223242526272829303132333435363738394041424344备份：1.备份全部数据库的数据和结构mysqldump -uroot -p123456 -A &gt;F:\all.sql2.备份全部数据库的结构（加 -d 参数）mysqldump -uroot -p123456 -A -d&gt;F:\all_struct.sql3.备份全部数据库的数据(加 -t 参数)mysqldump -uroot -p123456 -A -t&gt;F:\all_data.sql4.备份单个数据库的数据和结构(,数据库名mydb)mysqldump -uroot -p123456 mydb&gt;F:\mydb.sql5.备份单个数据库的结构mysqldump -uroot -p123456 mydb -d&gt;F:\mydb.sql6.备份单个数据库的数据mysqldump -uroot -p123456 mydb -t&gt;F:\mydb.sql7.备份多个表的数据和结构（数据，结构的单独备份方法与上同）mysqldump -uroot -p123456 mydb t1 t2 &gt;f:\multables.sql8.一次备份多个数据库mysqldump -uroot -p123456 --databases db1 db2 &gt;f:\muldbs.sql还原：还原部分分（1）mysql命令行source方法 和 （2）系统命令行方法1.还原全部数据库:(1) mysql命令行：mysql&gt;source f:\all.sql(2) 系统命令行： mysql -uroot -p123456 &lt;f:\all.sql2.还原单个数据库(需指定数据库)(1) mysql&gt;use mydbmysql&gt;source f:\mydb.sql(2) mysql -uroot -p123456 mydb &lt;f:\mydb.sql3.还原单个数据库的多个表(需指定数据库)(1) mysql&gt;use mydbmysql&gt;source f:\multables.sql(2) mysql -uroot -p123456 mydb &lt;f:\multables.sql4.还原多个数据库，（一个备份文件里有多个数据库的备份，此时不需要指定数据库）(1) mysql命令行：mysql&gt;source f:\muldbs.sql(2) 系统命令行： mysql -uroot -p123456 &lt;f:\muldbs.sql （二）数据表的创建1.1、显示所有数据表1show tables; 1.2、创建数据表1234create table 表名( 列名 类型 是否可以为空， 列名 类型 是否可以为空)ENGINE=InnoDB DEFAULT CHARSET=utf8 设置是否为空 123是否可空，null表示空，非字符串 not null - 不可空 null - 可空 设置默认值 12345默认值，创建列时可以指定默认值，当插入数据时如果未主动设置，则自动添加默认值 create table tb1( nid int not null defalut 2, num int not null ) 设置自增 1234567891011121314151617181920自增，如果为某列设置自增列，插入数据时无需设置此列，默认将自增（表中只能有一个自增列） create table tb1( nid int not null auto_increment primary key, num int null ) 或 create table tb1( nid int not null auto_increment, num int null, index(nid) ) 注意：1、对于自增列，必须是索引（含主键）。 2、对于自增可以设置步长和起始值 show session variables like &apos;auto_inc%&apos;; set session auto_increment_increment=2; set session auto_increment_offset=10; shwo global variables like &apos;auto_inc%&apos;; set global auto_increment_increment=2; set global auto_increment_offset=10; 唯一键 唯一键；unique key，用来保证对应的字段中的数据唯一的。 主键也可以用保证字段数据唯一性，但是一张表只有一个主键。 唯一键特点： 1、唯一键在一张表中可以有多个。 2、唯一键允许字段数据为NULL，NULL可以有多个（NULL不参与比较） 创建唯一键 创建唯一键和创建主键非常类似 1、直接在表字段之后增加唯一键标识符：unique[key] 2、在所有的字段之后使用unique key（字段列表）; 3、在创建完表之后也可以用增加唯一键 alter table 表名 add unique key（字段列表）； 唯一键效果：在不为空的情况下，不允许重复。 删除唯一键： 一个表中允许存在多个唯一键： 删除基本语法：alter table 表名 drop index 唯一键名字； index代表索引，唯一键是索引的一种（提升查询效率） 设置主键 1234567891011主键，一种特殊的唯一索引，不允许有空值，如果主键使用单个列，则它的值必须唯一，如果是多列，则其组合必须唯一。 create table tb1( nid int not null auto_increment primary key, num int null ) 或 create table tb1( nid int not null, num int not null, primary key(nid,num) ) 设置外键 123456789101112外键，一个特殊的索引，只能是指定内容 creat table color( nid int not null primary key, name char(16) not null ) create table fruit( nid int not null primary key, smt char(32) null , color_id int not null, constraint fk_cc foreign key (color_id) references color(nid) ) 主键与外键关系 一、外键约束 ​ MySQL通过外键约束来保证表与表之间的数据的完整性和准确性。 外键的使用条件： 1231.两个表必须是InnoDB表，MyISAM表暂时不支持外键（据说以后的版本有可能支持，但至少目前不支持）；2.外键列必须建立了索引，MySQL 4.1.2以后的版本在建立外键时会自动创建索引，但如果在较早的版本则需要显示建立； 3.外键关系的两个表的列必须是数据类型相似，也就是可以相互转换类型的列，比如int和tinyint可以，而int和char则不可以； 外键的好处：可以使得两张表关联，保证数据的一致性和实现一些级联操作； 外键的使用规则： 从表的字段必须与外键类型同样；外键必须是主表的唯一键；有关联的字段；避免使用复合键（也就是说从表能够同一时候引用多个主表的字段作为一个外键，一般不推荐这样的做法）。 外键不一定须要作为从表的主键。外键也不一定是主表的主键。主表的唯一键就能够作为从表的外键。 外键的定义语法： 1234567891011[CONSTRAINT symbol] FOREIGN KEY [id] (index_col_name, ...) REFERENCES tbl_name (index_col_name, ...) [ON DELETE &#123;RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT&#125;] [ON UPDATE &#123;RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT&#125;]该语法可以在 CREATE TABLE 和 ALTER TABLE 时使用，如果不指定CONSTRAINT symbol，MYSQL会自动生成一个名字。ON DELETE、ON UPDATE表示事件触发限制，可设参数：RESTRICT（限制外表中的外键改动）CASCADE（跟随外键改动）SET NULL（设空值）SET DEFAULT（设默认值）NO ACTION（无动作，默认的） 能够在创建表的时候创建，也能够在创建表之后创建 123456789101112创建表时创建：create table student(id int primary key,name char(4),dept char(9)sex char(4))create table grade(id int ,grade intconstraint id_fk foreign key (id) references student (id)) 或创建了两表之后再建 12alter table gradeadd constraint id_fk foreign key (id) references student (id) 1.3、删除表1drop table 表名 1.4、清空表12delete from 表名truncate table 表名 1.5、基本数据类型MySQL的数据类型大致分为：数值、时间和字符串 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105bit[(M)]二进制位（101001），m表示二进制位的长度（1-64），默认m＝1tinyint[(m)] [unsigned] [zerofill]小整数，数据类型用于保存一些范围的整数数值范围：有符号：-128 ～ 127.无符号：～ 255特别的： MySQL中无布尔值，使用tinyint(1)构造。int[(m)][unsigned][zerofill]整数，数据类型用于保存一些范围的整数数值范围：有符号：-2147483648 ～ 2147483647无符号：～ 4294967295特别的：整数类型中的m仅用于显示，对存储范围无限制。例如： int(5),当插入数据2时，select 时数据显示为： 00002bigint[(m)][unsigned][zerofill]大整数，数据类型用于保存一些范围的整数数值范围：有符号：-9223372036854775808 ～ 9223372036854775807无符号：～18446744073709551615decimal[(m[,d])] [unsigned] [zerofill]准确的小数值，m是数字总个数（负号不算），d是小数点后个数。 m最大值为65，d最大值为30。特别的：对于精确数值计算时需要用此类型decaimal能够存储精确值的原因在于其内部按照字符串存储。FLOAT[(M,D)] [UNSIGNED] [ZEROFILL]单精度浮点数（非准确小数值），m是数字总个数，d是小数点后个数。无符号：-3.402823466E+38 to -1.175494351E-38,1.175494351E-38 to 3.402823466E+38有符号：1.175494351E-38 to 3.402823466E+38**** 数值越大，越不准确 ****DOUBLE[(M,D)] [UNSIGNED] [ZEROFILL]双精度浮点数（非准确小数值），m是数字总个数，d是小数点后个数。无符号：-1.7976931348623157E+308 to -2.2250738585072014E-3082.2250738585072014E-308 to 1.7976931348623157E+308有符号：2.2250738585072014E-308 to 1.7976931348623157E+308**** 数值越大，越不准确 ****char (m)char数据类型用于表示固定长度的字符串，可以包含最多达255个字符。其中m代表字符串的长度。PS: 即使数据小于m长度，也会占用m长度varchar(m)varchars数据类型用于变长的字符串，可以包含最多达255个字符。其中m代表该数据类型所允许保存的字符串的最大长度，只要长度小于该最大值的字符串都可以被保存在该数据类型中。注：虽然varchar使用起来较为灵活，但是从整个系统的性能角度来说，char数据类型的处理速度更快，有时甚至可以超出varchar处理速度的50%。因此，用户在设计数据库时应当综合考虑各方面的因素，以求达到最佳的平衡texttext数据类型用于保存变长的大字符串，可以组多到65535 (2**16 − 1)个字符。mediumtextA TEXT column with a maximum length of 16,777,215 (2**24 − 1) characters.longtextA TEXT column with a maximum length of 4,294,967,295 or 4GB (2**32 − 1) characters.enum枚举类型，An ENUM column can have a maximum of 65,535 distinct elements. (The practical limit is less than 3000.)示例： CREATE TABLE shirts ( name VARCHAR(40), size ENUM('x-small', 'small', 'medium', 'large', 'x-large') ); INSERT INTO shirts (name, size) VALUES ('dress shirt','large'), ('t-shirt','medium'),('polo shirt','small');set集合类型A SET column can have a maximum of 64 distinct members.示例： CREATE TABLE myset (col SET('a', 'b', 'c', 'd')); INSERT INTO myset (col) VALUES ('a,d'), ('d,a'), ('a,d,a'), ('a,d,d'), ('d,a,d');DATEYYYY-MM-DD（1000-01-01/9999-12-31）TIMEHH:MM:SS（'-838:59:59'/'838:59:59'）YEARYYYY（1901/2155）DATETIMEYYYY-MM-DD HH:MM:SS（1000-01-01 00:00:00/9999-12-31 23:59:59 Y）TIMESTAMPYYYYMMDD HHMMSS（1970-01-01 00:00:00/2037 年某时） 1.6、修改表(alter)123456789101112131415161718添加列：alter table 表名 add column 列名 类型删除列：alter table 表名 drop column 列名修改列： alter table 表名 modify column 列名 类型; -- 类型 alter table 表名 change 原列名 新列名 类型; -- 列名，类型 修改表名：alter table 表名 rename to 新表名添加主键： alter table 表名 add primary key(列名);删除主键： alter table 表名 drop primary key; alter table 表名 modify 列名 int, drop primary key; 添加外键：alter table 从表 add constraint 外键名称（形如：FK_从表_主表） foreign key 从表(外键字段) references 主表(主键字段);删除外键：alter table 表名 drop foreign key 外键名称 修改默认值：ALTER TABLE testalter_tbl ALTER i SET DEFAULT 1000;删除默认值：ALTER TABLE testalter_tbl ALTER i DROP DEFAULT; 1.7、数据表关系关联映射：一对多/多对一 存在最普遍的映射关系，简单来讲就如球员与球队的关系； 一对多：从球队角度来说一个球队拥有多个球员 即为一对多 多对一：从球员角度来说多个球员属于一个球队 即为多对一 数据表间一对多关系如下图： 关联映射：一对一 一对一关系就如球队与球队所在地址之间的关系，一支球队仅有一个地址，而一个地址区也仅有一支球队。 数据表间一对一关系的表现有两种，一种是外键关联，一种是主键关联。图示如下： 一对一外键关联： 一对一主键关联：要求两个表的主键必须完全一致，通过两个表的主键建立关联关系 关联映射：多对多 多对多关系也很常见，例如学生与选修课之间的关系，一个学生可以选择多门选修课，而每个选修课又可以被多名学生选择。 数据库中的多对多关联关系一般需采用中间表的方式处理，将多对多转化为两个一对多 1.8、数据表之间的约束约束是一种限制，它通过对表的行或列的数据做出限制，来确保表的数据的完整性、唯一性。 MYSQL中，常用的几种约束： =================================================== 主键(PRIMARY KEY)是用于约束表中的一行，作为这一行的标识符，在一张表中通过主键就能准确定位到一行，因此主键十分重要。主键要求这一行的数据不能有重复且不能为空。 还有一种特殊的主键——复合主键。主键不仅可以是表中的一列，也可以由表中的两列或多列来共同标识 =================================================== 默认值约束(DEFAULT)规定，当有DEFAULT约束的列，插入数据为空时该怎么办。 DEFAULT约束只会在使用INSERT语句（上一实验介绍过）时体现出来，INSERT语句中，如果被DEFAULT约束的位置没有值，那么这个位置将会被DEFAULT的值填充 =================================================== 唯一约束(UNIQUE)比较简单，它规定一张表中指定的一列的值必须不能有重复值，即这一列每个值都是唯一的。 当INSERT语句新插入的数据和已有数据重复的时候，如果有UNIQUE约束，则INSERT失败. =================================================== 外键(FOREIGN KEY)既能确保数据完整性，也能表现表之间的关系。 一个表可以有多个外键，每个外键必须REFERENCES(参考)另一个表的主键，被外键约束的列，取值必须在它参考的列中有对应值。 在INSERT时，如果被外键约束的值没有在参考列中有对应，比如以下命令，参考列(department表的dpt_name)中没有dpt3，则INSERT失败 =================================================== 非空约束(NOT NULL),听名字就能理解，被非空约束的列，在插入值时必须非空。 在MySQL中违反非空约束，不会报错，只会有警告. 2、数据库和表内容的操作(增、删、改、查)增123insert into 表 (列名,列名...) values (值,值,值...)insert into 表 (列名,列名...) values (值,值,值...),(值,值,值...)insert into 表 (列名,列名...) select (列名,列名...) from 表 删12345delete from 表delete from 表 where id＝1 and name＝&apos;alex&apos;truncate table 表 该方法只能全表删除，不能按条件删除delete from删除的数据可以回滚，truncate table删除的数据不能回滚delete from删不可以把自增长约束重置，truncate table可以 改1update 表 set name ＝ &apos;alex&apos; where id&gt;1 查4.1、普通查询123select * from 表select * from 表 where id &gt; 1select nid,name,gender as gg from 表 where id &gt; 1 更多选项查询 12345678910a、条件 select * from 表 where id &gt; 1 and name != &apos;alex&apos; and num = 12; select * from 表 where id between 5 and 16; select * from 表 where id in (11,22,33) select * from 表 where id not in (11,22,33) select * from 表 where id in (select nid from 表)b、限制 select * from 表 limit 5; - 前5行 select * from 表 limit 4,5; - 从第4行开始的5行 select * from 表 limit 5 offset 4 - 从第4行开始的5行 4.2、数据排序(查询)123select * from 表 order by 列 asc - 根据 “列” 从小到大排列select * from 表 order by 列 desc - 根据 “列” 从大到小排列select * from 表 order by 列1 desc,列2 asc - 根据 “列1” 从大到小排列，如果相同则按列2从小到大排序 4.3、模糊查询123通配符(模糊查询) select * from 表 where name like &apos;ale%&apos; - ale开头的所有（多个字符串） select * from 表 where name like &apos;ale_&apos; - ale开头的所有（一个字符） 4.4、聚集函数查询聚集函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143(1）COUNT 语法：COUNT(e1) 参数：e1为一个表达式，可以是任意的数据类型 返回：返回数值型数据 作用：返回e1指定列不为空的记录总数(2）SUM, 语法：SUM(e1) 参数：e1为类型为数值型的表达式 返回：返回数值型数据 作用：对e1指定的列进行求和计算(3）MIN, MAX 语法：MIN(e1)、MAX(e1) 参数：e1为一个字符型、日期型或数值类型的表达式。 若e1为字符型，则根据ASCII码来判断最大值与最小值。 返回：根据e1参数的类型，返回对应类型的数据。 作用：MIN(e1)返回e1表达式指定的列中最小值； MAX(e1)返回e1表达式指定的列中最大值；(4）AVG 语法：AVG(e1) 参数：e1为一个数值类型的表达式 返回：返回一个数值类型数据 作用：对e1表达式指定的列，求平均值。(5）MEDIAN 语法：MEDIAN(e1) 参数：e1为一个数值或日期类型的表达式 返回：返回一个数值或日期类型的数据 作用：首先，根据e1表达式指定的列，对值进行排序； 若排序后，总记录为奇数，则返回排序队列中，位于中间的值； 若排序后，总记录为偶数，则对位于排序队列中，中间两个值进行求平均，返回这个平均值；(6）RANK (1）用法1:RANK OVER 语法： RANK( ) OVER ([ PARTITION BY column1 ] ORDER BY column2 [ASC|DESC]) 为分析函数，为每条记录产生一个序列号，并返回。 参数： column1为列名，指定按照哪一列进行分类（分组） column2为列名，指定根据哪列排序，默认为升序； 若指定了分类子句（PARTITION BY），则对每类进行排序（每个分类单独排序） 返回：返回一个数值类型数据，作为该记录的序号！ 作用：为分析函数，对记录先按column1分类，再对每个分类进行排序，并为每条记录分配一个序号（每个分类单独排序）注意：排序字段值相同的记录，分配相同的序号。存在序号不连续的情况 实例：student表记录了学生每科的成绩，要求按学科排序，并获取每科分数前两名的记录student表如下： SQL&gt; select * from student order by kemu; NAME ID KEMU FENSHU ---------- -------------- -------------- ---------------- Li 0113101 物理 80 Luo 0113011 物理 80 Wang 0113077 物理 70 Zhang 0113098 物理 90 Luo 0113011 高数 80 Wang 0113077 高数 70 Zhang 0113098 高数 80 Li 0113101 高数 90rows selected按学科分类，按成绩排序（降序）SQL&gt; select rank() over(partition by KEMU order by FENSHU desc) as sort,student.* from student; SORT NAME ID KEMU FENSHU ---------- ---------- ---------------- ------------ ---------- 1 Zhang 0113098 物理 90 2 Li 0113101 物理 80 2 Luo 0113011 物理 80 4 Wang 0113077 物理 70 1 Li 0113101 高数 90 2 Luo 0113011 高数 80 2 Zhang 0113098 高数 80 4 Wang 0113077 高数 70由返回记录可了解，对排序列的值相同的记录，rank为其分配了相同的序号（SORT NAME列）。并且之后的记录的序号是不连续的。若获取每科前两名，只需对排序后的结果增加二次查询即可select * from (select rank() over(partition by KEMU order by FENSHU desc) as sort_id,student.* from student) st where st.sort_id&lt;=2; (2)用法2：RANK WITHIN GROUP语法： RANK( expr1 ) WITHIN GROUP ( ORDER BY expr2 )为聚合函数，返回一个值。参数：expr1为1个或多个常量表达式；expr2为如下格式的表达式： expr2的格式为'expr3 [ DESC | ASC ] [ NULLS &#123; FIRST | LAST &#125; ]'其中，expr1需要与expr2相匹配，即：expr1的常量表达式的类型、数量必须与ORDER BY子句后的expr2表达式的类型、数量相同实际是expr1需要与expr3相匹配如：RANK(a) WITHIN GROUP (ORDER BY b ASC NULLS FIRST);其中，a为常量，b需要是与相同类型的表达式RANK(a,b) WITHIN GROUP (ORDER BY c DESC NULLS LAST, d DESC NULLS LAST);其中，a与b都为常量；c是与a类型相同的表达式、d是与b类型相同的表达式； 返回：返回数值型数据，该值为假定记录在表中的序号。作用：确定一条假定的记录，在表中排序后的序号。如：假定一条记录（假设为r1）的expr2指定字段值为常量expr1，则将r1插入表中后，与原表中的记录，按照ORDER BY expr2排序后，该记录r1在表中的序号为多少，返回该序号。注释： NULLS FIRST指定，将ORDER BY指定的排序字段为空值的记录放在前边；NULLS LAST指定，将ORDER BY指定的排序字段为空值的记录放在后边；实例：假设一个员工的薪水为1500，求该员工的薪水在员工表中的排名为多少？已知员工表如下： SQL&gt; select * from employees;EMP_ID EMP_NAME SALARY---------- -------------------- ---------------10001 ZhangSan 50010002 LiSi 100010003 WangWu 150010004 MaLiu 200010005 NiuQi 2500SQL&gt; select rank(1500) within group (order by salary) as "rank number" from employees;rank number-----------由结果可知，薪水为1500的员工，在表中按升序排序，序号为3 (7）FIRST、LAST语法： agg_function（e1） KEEP (DENSE_RANK FIRST ORDER BY e2 [NULLS &#123;FIRST|LAST&#125;]) [OVER PARTITION BY e3 ] agg_function（e1） KEEP (DENSE_RANK LAST ORDER BY e2 [NULLS &#123;FIRST|LAST&#125;]) [OVER PARTITION BY e3 ] 参数： agg_function为一个聚合函数，可以为 MIN、MAX、SUM、AVG、COUNT、VARIANCE或STDDEV e2指定以哪个字段为依据，进行排序； e3指定以哪个字段为依据，进行分类（分组）； 当指定OVER PARTITION BY子句后，针对分类后的每个类单独排序； DENSE_RANK为排序后的记录分配序号，并且序号为连续的。 NULLS &#123;FIRST|LAST&#125;指定排序字段e1的值若为空，则拍在序列前边（NULLS FIRST）或者后边（NULLS LAST） DENSE_RANK后的FIRST/LAST确定选取通过DENSE_RANK排好序后的序列中，序号最小/最大的记录。序号相同时，返回多条记录当序号相同，返回多条记录时，agg_function(e1)聚合函数继续对这多条记录的e1字段做聚合操作。作用： 如果agg_function为min(e1)，获取排序后的FIRST或LAST的多条记录中，某字段e1的最小值该字段不是排序关键字段e2实例：已知员工表有薪水字段，奖金字段。要求获取薪水最低的员工中，奖金最高的员工的记录。已知表内容如下：SQL&gt; select * from employees order by salary; EMP_ID EMP_NAME SALARY COMMISSION ---------- ---------------------------- ------------ ------------ 10001 ZhangSan 500 200 10002 LiSi 500 300 10003 WangWu 500 100 10004 MaLiu 2000 500 10005 NiuQi 2500 200 10006 ShangDuo 2500 300 10007 BaiQi 2500 400 SQL&gt; select max(commission) keep(dense_rank first order by salary asc) as commission from employees;COMMISSION----------首先，按salary排序后，获取薪水最低的记录，分别为员工10001、10002、10003三条记录。聚合函数max(commission)对3条记录获取奖金最高的为员工10002，奖金为300。 4.5、分组查询1234567select num from 表 group by numselect num,nid from 表 group by num,nidselect num,nid from 表 where nid &gt; 10 group by num,nid order nid descselect num,nid,count(*),sum(score),max(score),min(score) from 表 group by num,nidselect num from 表 group by num having max(id) &gt; 10特别的：group by 必须在where之后，order by之前 4.6多表查询12345678910111213141516171819202122232425262728293031323334a、连表 无对应关系则不显示 select A.num, A.name, B.name from A,B Where A.nid = B.nid 无对应关系则不显示 select A.num, A.name, B.name from A inner join B on A.nid = B.nid A表所有显示，如果B中无对应关系，则值为null select A.num, A.name, B.name from A left join B on A.nid = B.nid B表所有显示，如果B中无对应关系，则值为null select A.num, A.name, B.name from A right join B on A.nid = B.nidb、组合 组合，自动处理重合 select nickname from A union select name from B 组合，不处理重合 select nickname from A union all select name from B 4.7正则正则表达式的作用是匹配文本，将一个模式（正则表达式）与一个文本串进行比较。MySQL用WHERE子句对正则表达式提供了初步的支持，允许你指定正则表达式，过滤SELECT检索出的数据。 基本字符匹配 REGEXP关键字来匹配正则 1SELECT name FROM tab1 WHERE name REGEXP 'abc'; REGEXP后所跟的东西作为正则表达式 12345678'.'是以匹配任意一个字符'a|b'可以匹配了两个a或者'[abc]'可以匹配abc中的某一个字符'[^a]'匹配除a以外的数据'[1-9]'匹配1到9中的任何一个数字，[a-z]和[A-Z]同[1-9]'\'是相当于转义字符SELECT name FROM tab1 WHERE name REGEXP 'a|b'; 匹配字符类 123456789101112[:alnum:] 任意字母和数字（同[a-zA-Z0-9]）[:alpha:] 任意字符（同[a-zA-Z]）[:blank:] 空格和制表（同[\t]）[:cntrl:] ASCII控制字符（ASCII 0到31和127）[:digit:] 任意数字（同[0-9]）[:graph:] 与[:print:]相同，但不包括空格[:lower:] 任意小写字母（同[a-z]）[:print:] 任意可打印字符[:punct:] 既不在[:alnum:]又不在[:cntrl:]中的任意字符[:space:] 包括空格在内的任意空白字符（同[\f\n\r\t\v]）[:upper:] 任意大写字母（同[A-Z]）[:xdigit:] 任意十六进制数字（同[a-fA-F0-9]） 匹配多个字符 1234567* 0个或多个匹配+ 1个或多个匹配（等于&#123;1,&#125;）? 0个或1个匹配（等于&#123;0,1&#125;）&#123;n&#125; 指定数目的匹配&#123;n,&#125; 不少于指定数目的匹配&#123;n,m&#125; 匹配数目的范围（m不超过255）SELECT name FROM tab1 WHERE name REGEXP 'a*'; 匹配0个和多个a 定位符 1234'^' 匹配文本的开始'$' 匹配文本的结尾[[:&lt;:]] 匹配词的开始[[:&gt;:]] 匹配词的结尾 4.8 创建联结内部联结 inner join 1select vend_name,pro_name from vendors inner join products on vendors.id = products.id; 外部联结 left join 和 right join 12select vend_name,pro_name from vendors left join products on vendors.id = products.id;select vend_name,pro_name from vendors right join products on vendors.id = products.id;]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python并发编程之多线程]]></title>
    <url>%2F2018%2F12%2F03%2Fpython%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[进程一 什么是进程进程：正在进行的一个过程或者说一个任务。而负责执行任务则是cpu。 举例（单核+多道，实现多个进程的并发执行）： jack在一个时间段内有很多任务要做：python备课的任务，写书的任务，交女朋友的任务，王者荣耀上分的任务， 但jack同一时刻只能做一个任务（cpu同一时间只能干一个活），如何才能玩出多个任务并发执行的效果？ jack备一会课，再去跟李杰的女朋友聊聊天，再去打一会王者荣耀….这就保证了每个任务都在进行中 二 进程与程序的区别程序仅仅只是一堆代码而已，而进程指的是程序的运行过程。 举例： 想象一位有一手好厨艺的计算机科学家jack正在为他的女儿元昊烘制生日蛋糕。 他有做生日蛋糕的食谱， 厨房里有所需的原料:面粉、鸡蛋、韭菜，蒜泥等。 在这个比喻中： ​ 做蛋糕的食谱就是程序(即用适当形式描述的算法) ​ 计算机科学家就是处理器(cpu) ​ 而做蛋糕的各种原料就是输入数据。 进程就是厨师阅读食谱、取来各种原料以及烘制蛋糕等一系列动作的总和。 现在假设计算机科学家jack的儿子rose哭着跑了进来，说：XXXXXXXXXXXXXX 科学家jack想了想，处理儿子rose蛰伤的任务比给女儿元昊做蛋糕的任务更重要，于是 计算机科学家就记录下他照着食谱做到哪儿了(保存进程的当前状态)，然后拿出一本急救手册，按照其中的指示处理蛰伤。这里，我们看到处理机从一个进程(做蛋糕)切换到另一个高优先级的进程(实施医疗救治)，每个进程拥有各自的程序(食谱和急救手册)。当蜜蜂蛰伤处理完之后，这位计算机科学家又回来做蛋糕，从他离开时的那一步继续做下去。 需要强调的是：同一个程序执行两次，那也是两个进程，比如打开暴风影音，虽然都是同一个软件，但是一个可以播放苍井空，一个可以播放饭岛爱。 三 并发与并行无论是并行还是并发，在用户看来都是’同时’运行的，不管是进程还是线程，都只是一个任务而已，真是干活的是cpu，cpu来做这些任务，而一个cpu同一时刻只能执行一个任务 一 并发：是伪并行，即看起来是同时运行。单个cpu+多道技术就可以实现并发，（并行也属于并发） 单cpu，多进程，并发举例一： 1234你是一个cpu，你同时谈了三个女朋友，每一个都可以是一个恋爱任务，你被这三个任务共享要玩出并发恋爱的效果，应该是你先跟女友1去看电影，看了一会说：不好，我要拉肚子，然后跑去跟第二个女友吃饭，吃了一会说：那啥，我去趟洗手间，然后跑去跟女友3开了个房 单cpu，多进程，并发举例二： 12某天下午，egon，yuanhao，wupeiqi，alex约好了一起去嫖娼，但娼只有一个，cpu只有一个，但是却要‘同时’干四个任务(嫖出并发的效果)，那就必须是干一会egon，再干一会yuanhao，再干一会wupeiqi，再干一会alex 二 并行：同时运行，只有具备多个cpu才能实现并行 单核下，可以利用多道技术，多个核，每个核也都可以利用多道技术（多道技术是针对单核而言的） 有四个核，六个任务，这样同一时间有四个任务被执行，假设分别被分配给了cpu1，cpu2，cpu3，cpu4， 一旦任务1遇到I/O就被迫中断执行，此时任务5就拿到cpu1的时间片去执行，这就是单核下的多道技术 而一旦任务1的I/O结束了，操作系统会重新调用它(需知进程的调度、分配给哪个cpu运行，由操作系统说了算)，可能被分配给四个cpu中的任意一个去执行 所有现代计算机经常会在同一时间做很多件事，一个用户的PC（无论是单cpu还是多cpu），都可以同时运行多个任务（一个任务可以理解为一个进程）。 启动一个进程来杀毒（360软件） 启动一个进程来看电影（暴风影音） 启动一个进程来聊天（腾讯QQ） 所有的这些进程都需被管理，于是一个支持多进程的多道程序系统是至关重要的 多道技术概念回顾：内存中同时存入多道（多个）程序，cpu从一个进程快速切换到另外一个，使每个进程各自运行几十或几百毫秒，这样，虽然在某一个瞬间，一个cpu只能执行一个任务，但在1秒内，cpu却可以运行多个进程，这就给人产生了并行的错觉，即伪并发，以此来区分多处理器操作系统的真正硬件并行（多个cpu共享同一个物理内存） 线程一 什么是线程在传统操作系统中，每个进程有一个地址空间，而且默认就有一个控制线程 线程顾名思义，就是一条流水线工作的过程，一条流水线必须属于一个车间，一个车间的工作过程是一个进程 车间负责把资源整合到一起，是一个资源单位，而一个车间内至少有一个流水线 流水线的工作需要电源，电源就相当于cpu 所以，进程只是用来把资源集中到一起（进程只是一个资源单位，或者说资源集合），而线程才是cpu上的执行单位。 多线程（即多个控制线程）的概念是，在一个进程中存在多个控制线程，多个控制线程共享该进程的地址空间，相当于一个车间内有多条流水线，都共用一个车间的资源。 例如，北京地铁与上海地铁是不同的进程，而北京地铁里的13号线是一个线程，北京地铁所有的线路共享北京地铁所有的资源，比如所有的乘客可以被所有线路拉。 二 线程的创建开销小创建进程的开销要远大于线程？ 如果我们的软件是一个工厂，该工厂有多条流水线，流水线工作需要电源，电源只有一个即cpu（单核cpu） 一个车间就是一个进程，一个车间至少一条流水线（一个进程至少一个线程） 创建一个进程，就是创建一个车间（申请空间，在该空间内建至少一条流水线） 而建线程，就只是在一个车间内造一条流水线，无需申请空间，所以创建开销小 进程之间是竞争关系，线程之间是协作关系？ 车间直接是竞争/抢电源的关系，竞争（不同的进程直接是竞争关系，是不同的程序员写的程序运行的，迅雷抢占其他进程的网速，360把其他进程当做病毒干死）一个车间的不同流水线式协同工作的关系（同一个进程的线程之间是合作关系，是同一个程序写的程序内开启动，迅雷内的线程是合作关系，不会自己干自己） 三 线程与进程的区别123456Threads share the address space of the process that created it; processes have their own address space.Threads have direct access to the data segment of its process; processes have their own copy of the data segment of the parent process.Threads can directly communicate with other threads of its process; processes must use interprocess communication to communicate with sibling processes.New threads are easily created; new processes require duplication of the parent process.Threads can exercise considerable control over threads of the same process; processes can only exercise control over child processes.Changes to the main thread (cancellation, priority change, etc.) may affect the behavior of the other threads of the process; changes to the parent process does not affect child processes. 四 为何要用多线程多线程指的是，在一个进程中开启多个线程，简单的讲：如果多个任务共用一块地址空间，那么必须在一个进程内开启多个线程。详细的讲分为4点： 多线程共享一个进程的地址空间 线程比进程更轻量级，线程比进程更容易创建可撤销，在许多操作系统中，创建一个线程比创建一个进程要快10-100倍，在有大量线程需要动态和快速修改时，这一特性很有用 若多个线程都是cpu密集型的，那么并不能获得性能上的增强，但是如果存在大量的计算和大量的I/O处理，拥有多个线程允许这些活动彼此重叠运行，从而会加快程序执行的速度。 在多cpu系统中，为了最大限度的利用多核，可以开启多个线程，比开进程开销要小的多。（这一条并不适用于python） 进程与线程总结进程：最小的资源管理单位(盛放线程的容器) 线程：最小的执行单位 Cpython因为同一时刻同一进程只有一个线程被执行，所以python没有线程的并行，只能进程并行 threading模块介绍multiprocess模块的完全模仿了threading模块的接口，二者在使用层面，有很大的相似性，因而不再详细介绍 开启线程的两种方式Thread类直接创建12345678910from threading import Threadimport timedef sayhi(name): time.sleep(2) print('%s say hello' %name) if __name__ == '__main__': t=Thread(target=sayhi,args=('egon',)) t.start() print('主线程') Thread类继承式创建12345678910111213141516171819from threading import Threadimport time class MyThread(Thread): def __init__(self,num): Thread.__init__(self) self.num=num def run(self): print("running on number:%s" %self.num) time.sleep(3) t1=MyThread(56)t2=MyThread(78) t1.start()t2.start()print("ending") Thread类的实例方法join()：在子线程完成运行之前，这个子线程的父线程将一直被阻塞（join写在start之后） setDaemon(True)：将线程声明为守护线程，必须在start() 方法调用之前设置，如果不设置为守护线程程序会被无限挂起。 当我们在程序运行中，执行一个主线程，如果主线程又创建一个子线程，主线程和子线程 就分兵两路，分别运行，那么当主线程完成想退出时，会检验子线程是否完成。如果子线程未完成，则主线程会等待子线程完成后再退出。但是有时候我们需要的是只要主线程完成了，不管子线程是否完成，都要和主线程一起退出，这时就可以 用setDaemon方法啦 当主线程执行完，要等非守护线程完成，而此时守护线程并没有死，等待的过程中可以执行 1234567891011121314151617181920212223242526272829303132333435363738394041import threadingfrom time import ctime,sleepimport time def Music(name): print ("Begin listening to &#123;name&#125;. &#123;time&#125;".format(name=name,time=ctime())) sleep(3) print("end listening &#123;time&#125;".format(time=ctime())) def Blog(title): print ("Begin recording the &#123;title&#125;. &#123;time&#125;".format(title=title,time=ctime())) sleep(5) print('end recording &#123;time&#125;'.format(time=ctime())) threads = [] t1 = threading.Thread(target=Music,args=('FILL ME',))t2 = threading.Thread(target=Blog,args=('',)) threads.append(t1)threads.append(t2) if __name__ == '__main__': #t2.setDaemon(True) for t in threads: #t.setDaemon(True) #注意:一定在start之前设置 t.start() #t.join() #t1.join() #t2.join() # 考虑这三种join位置下的结果？ print ("all over %s" %ctime()) daemon 12A boolean value indicating whether this thread is a daemon thread (True) or not (False). This must be set before start() is called, otherwise RuntimeError is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to daemon = False.The entire Python program exits when no alive non-daemon threads are left. 当daemon被设置为True时，如果主线程退出，那么子线程也将跟着退出,(注意退出不是死，) 反之，子线程将继续运行，直到正常退出。 Thread实例对象的方法isAlive(): 返回线程是否活动的。getName(): 返回线程名。setName(): 设置线程名。 threading模块提供的一些方法：threading.currentThread(): 返回当前的线程变量。threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。 GIL12345定义：In CPython, the global interpreter lock, or GIL, is a mutex that prevents multiple native threads from executing Python bytecodes at once. This lock is necessary mainly because CPython’s memory management is not thread-safe. (However, since the GIL exists, other features have grown to depend on the guarantees that it enforces.) Python中的线程是操作系统的原生线程，Python虚拟机使用一个全局解释器锁（Global Interpreter Lock）来互斥线程对Python虚拟机的使用。为了支持多线程机制，一个基本的要求就是需要实现不同线程对共享资源访问的互斥，所以引入了GIL。GIL：在一个线程拥有了解释器的访问权之后，其他的所有线程都必须等待它释放解释器的访问权，即使这些线程的下一条指令并不会互相影响。在调用任何Python C API之前，要先获得GILGIL缺点：多处理器退化为单处理器；优点：避免大量的加锁解锁操作 GIL的早期设计Python支持多线程，而解决多线程之间数据完整性和状态同步的最简单方法自然就是加锁。 于是有了GIL这把超级大锁，而当越来越多的代码库开发者接受了这种设定后，他们开始大量依赖这种特性（即默认python内部对象是thread-safe的，无需在实现时考虑额外的内存锁和同步操作）。慢慢的这种实现方式被发现是蛋疼且低效的。但当大家试图去拆分和去除GIL的时候，发现大量库代码开发者已经重度依赖GIL而非常难以去除了。有多难？做个类比，像MySQL这样的“小项目”为了把Buffer Pool Mutex这把大锁拆分成各个小锁也花了从5.5到5.6再到5.7多个大版为期近5年的时间，并且仍在继续。MySQL这个背后有公司支持且有固定开发团队的产品走的如此艰难，那又更何况Python这样核心开发和代码贡献者高度社区化的团队呢？ GIL的影响无论你启多少个线程，你有多少个cpu, Python在执行一个进程的时候会淡定的在同一时刻只允许一个线程运行。所以，python是无法利用多核CPU实现多线程的。这样，python对于计算密集型的任务开多线程的效率甚至不如串行(没有大量切换)，但是，对于IO密集型的任务效率还是有显著提升的。 计算密集型： 123456789101112131415161718192021222324252627282930313233343536373839404142#coding:utf8from threading import Threadimport time def counter(): i = 0 for _ in range(50000000): i = i + 1 return True def main(): l=[] start_time = time.time() for i in range(2): t = Thread(target=counter) t.start() l.append(t) t.join() # for t in l: # t.join() end_time = time.time() print("Total time: &#123;&#125;".format(end_time - start_time)) if __name__ == '__main__': main() '''py2.7: 串行:25.4523348808s 并发:31.4084379673spy3.5: 串行:8.62115597724914s 并发:8.99609899520874s''' 解决方案用multiprocessing替代Thread multiprocessing库的出现很大程度上是为了弥补thread库因为GIL而低效的缺陷。它完整的复制了一套thread所提供的接口方便迁移。唯一的不同就是它使用了多进程而不是多线程。每个进程有自己的独立的GIL，因此也不会出现进程之间的GIL争抢。 12345678910111213141516171819202122232425262728293031323334353637383940#coding:utf8from multiprocessing import Processimport time def counter(): i = 0 for _ in range(40000000): i = i + 1 return True def main(): l=[] start_time = time.time() for _ in range(2): t=Process(target=counter) t.start() l.append(t) #t.join() for t in l: t.join() end_time = time.time() print("Total time: &#123;&#125;".format(end_time - start_time)) if __name__ == '__main__': main() '''py2.7: 串行:6.1565990448 s 并行:3.1639978885 spy3.5: 串行:6.556925058364868 s 并发:3.5378448963165283 s''' 当然multiprocessing也不是万能良药。它的引入会增加程序实现时线程间数据通讯和同步的困难。就拿计数器来举例子，如果我们要多个线程累加同一个变量，对于thread来说，申明一个global变量，用thread.Lock的context包裹住三行就搞定了。而multiprocessing由于进程之间无法看到对方的数据，只能通过在主线程申明一个Queue，put再get或者用share memory的方法。这个额外的实现成本使得本来就非常痛苦的多线程程序编码，变得更加痛苦了。 总结：因为GIL的存在，只有IO Bound场景下得多线程会得到较好的性能 - 如果对并行计算性能较高的程序可以考虑把核心部分也成C模块，或者索性用其他语言实现 - GIL在较长一段时间内将会继续存在，但是会不断对其进行改进。 所以对于GIL，既然不能反抗，那就学会去享受它吧！ 总结： GIL（全局解释器锁） 加在cpython解释器上： 计算密集型：一直在使用cpu IO：存在大量IO操作 对于算计密集型任务：python的多线程没有用 对于IO密集型任务：python的多线程有意义的 python使用多核：多个进程，弊端：开销大而且切换复杂 着重点:协程+多进程 方向：IO多路复用 终极思路：换c模块实现多线程 同步锁 (Lock)123456789101112131415161718192021222324import timeimport threading def addNum(): global num #在每个线程中都获取这个全局变量 #num-=1 temp=num time.sleep(0.1) num =temp-1 # 对此公共变量进行-1操作 num = 100 #设定一个共享变量 thread_list = [] for i in range(100): t = threading.Thread(target=addNum) t.start() thread_list.append(t) for t in thread_list: #等待所有线程执行完毕 t.join() print('Result: ', num) 锁通常被用来实现对共享资源的同步访问。为每一个共享资源创建一个Lock对象，当你需要访问该资源时，调用acquire方法来获取锁对象（如果其它线程已经获得了该锁，则当前线程需等待其被释放），待资源访问完后，再调用release方法释放锁： 12345678import threading R=threading.Lock()R.acquire()'''对公共数据的操作'''R.release() 扩展思考1、为什么有了GIL，还需要线程同步？ 多线程环境下必须存在资源的竞争,那么如何才能保证同一时刻只有一个线程对共享资源进行存取? 加锁, 对, 加锁可以保证存取操作的唯一性, 从而保证同一时刻只有一个线程对共享数据存取. 通常加锁也有2种不同的粒度的锁: ​ coarse-grained(粗粒度)： python解释器层面维护着一个全局的锁机制,用来保证线程安全。​ 内核级通过GIL实现的互斥保护了内核的共享资源。 ​ fine-grained(细粒度)： 那么程序员需要自行地加,解锁来保证线程安全，​ 用户级通过自行加锁保护的用户程序的共享资源。 2、GIL为什么限定在一个进程上？ 你写一个py程序，运行起来本身就是一个进程，这个进程是有解释器来翻译的，所以GIL限定在当前进程； 如果又创建了一个子进程，那么两个进程是完全独立的，这个字进程也是有python解释器来运行的，所以 这个子进程上也是受GIL影响的 死锁与递归锁所谓死锁： 是指两个或两个以上的进程或线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import threadingimport time mutexA = threading.Lock()mutexB = threading.Lock() class MyThread(threading.Thread): def __init__(self): threading.Thread.__init__(self) def run(self): self.fun1() self.fun2() def fun1(self): mutexA.acquire() # 如果锁被占用,则阻塞在这里,等待锁的释放 print ("I am %s , get res: %s---%s" %(self.name, "ResA",time.time())) mutexB.acquire() print ("I am %s , get res: %s---%s" %(self.name, "ResB",time.time())) mutexB.release() mutexA.release() def fun2(self): mutexB.acquire() print ("I am %s , get res: %s---%s" %(self.name, "ResB",time.time())) time.sleep(0.2) mutexA.acquire() print ("I am %s , get res: %s---%s" %(self.name, "ResA",time.time())) mutexA.release() mutexB.release() if __name__ == "__main__": print("start---------------------------%s"%time.time()) for i in range(0, 10): my_thread = MyThread() my_thread.start() 在Python中为了支持在同一线程中多次请求同一资源，python提供了可重入锁RLock。这个RLock内部维护着一个Lock和一个counter变量，counter记录了acquire的次数，从而使得资源可以被多次require。直到一个线程所有的acquire都被release，其他的线程才能获得资源。上面的例子如果使用RLock代替Lock，则不会发生死锁： 1mutex=threading.RLock() Event对象线程的一个关键特性是每个线程都是独立运行且状态不可预测。如果程序中的其 他线程需要通过判断某个线程的状态来确定自己下一步的操作,这时线程同步问题就 会变得非常棘手。为了解决这些问题,我们需要使用threading库中的Event对象。 对象包含一个可由线程设置的信号标志,它允许线程等待某些事件的发生。在 初始情况下,Event对象中的信号标志被设置为假。如果有线程等待一个Event对象, 而这个Event对象的标志为假,那么这个线程将会被一直阻塞直至该标志为真。一个线程如果将一个Event对象的信号标志设置为真,它将唤醒所有等待这个Event对象的线程。如果一个线程等待一个已经被设置为真的Event对象,那么它将忽略这个事件, 继续执行 event.isSet()：返回event的状态值； event.wait()：如果 event.isSet()==False将阻塞线程； event.set()： 设置event的状态值为True，所有阻塞池的线程激活进入就绪状态， 等待操作系统调度； event.clear()：恢复event的状态值为False 可以考虑一种应用场景（仅仅作为说明），例如，我们有多个线程从Redis队列中读取数据来处理，这些线程都要尝试去连接Redis的服务，一般情况下，如果Redis连接不成功，在各个线程的代码中，都会去尝试重新连接。如果我们想要在启动时确保Redis服务正常，才让那些工作线程去连接Redis服务器，那么我们就可以采用threading.Event机制来协调各个工作线程的连接操作：主线程中会去尝试连接Redis服务，如果正常的话，触发事件，各工作线程会尝试连接Redis服务。 1234567891011121314151617181920212223242526import threadingimport timeimport logging logging.basicConfig(level=logging.DEBUG, format='(%(threadName)-10s) %(message)s',) def worker(event): logging.debug('Waiting for redis ready...') event.wait() logging.debug('redis ready, and connect to redis server and do some work [%s]', time.ctime()) time.sleep(1) def main(): readis_ready = threading.Event() t1 = threading.Thread(target=worker, args=(readis_ready,), name='t1') t1.start() t2 = threading.Thread(target=worker, args=(readis_ready,), name='t2') t2.start() logging.debug('first of all, check redis server, make sure it is OK, and then trigger the redis ready event') time.sleep(3) # simulate the check progress readis_ready.set() if __name__=="__main__": main() threading.Event的wait方法还接受一个超时参数，默认情况下如果事件一致没有发生，wait方法会一直阻塞下去，而加入这个超时参数之后，如果阻塞时间超过这个参数设定的值之后，wait方法会返回。对应于上面的应用场景，如果Redis服务器一致没有启动，我们希望子线程能够打印一些日志来不断地提醒我们当前没有一个可以连接的Redis服务，我们就可以通过设置这个超时参数来达成这样的目的： 123456def worker(event): while not event.is_set(): logging.debug('Waiting for redis ready...') event.wait(2) logging.debug('redis ready, and connect to redis server and do some work [%s]', time.ctime()) time.sleep(1) 这样，我们就可以在等待Redis服务启动的同时，看到工作线程里正在等待的情况。 Semaphore（信号量）Semaphore管理一个内置的计数器，每当调用acquire()时内置计数器-1；调用release() 时内置计数器+1；计数器不能小于0；当计数器为0时，acquire()将阻塞线程直到其他线程调用release()。 实例：(同时只有5个线程可以获得semaphore,即可以限制最大连接数为5)： 1234567891011121314import threadingimport time semaphore = threading.Semaphore(5) def func(): if semaphore.acquire(): print (threading.currentThread().getName() + ' get semaphore') time.sleep(2) semaphore.release() for i in range(20): t1 = threading.Thread(target=func) t1.start() 队列(queue)get与put方法创建一个“队列”对象 12import Queueq = Queue.Queue(maxsize = 10) # 默认先进先出 Queue.Queue类即是一个队列的同步实现。队列长度可为无限或者有限。可通过Queue的构造函数的可选参数maxsize来设定队列长度。如果maxsize小于1就表示队列长度无限。 将一个值放入队列中 1q.put(10) 调用队列对象的put()方法在队尾插入一个项目。put()有两个参数，第一个item为必需的，为插入项目的值；第二个block为可选参数，默认为1。如果队列当前为空且block为1，put()方法就使调用线程暂停,直到空出一个数据单元。如果block为0，put方法将引发Full异常。 将一个值从队列中取出 1q.get() 调用队列对象的get()方法从队头删除并返回一个项目。可选参数为block，默认为True。如果队列为空且block为True，get()就使调用线程暂停，直至有项目可用。如果队列为空且block为False，队列将引发Empty异常。 join与task_done方法join() 阻塞进程，直到所有任务完成，需要配合另一个方法task_done 1234def join(self): with self.all_tasks_done: while self.unfinished_tasks: self.all_tasks_done.wait() task_done() 表示某个任务完成。每一条get语句后需要一条task_done 123456789101112import queueq = queue.Queue(5)q.put(10)q.put(20)print(q.get())q.task_done()print(q.get())q.task_done() q.join() print("ending!") 其他常用方法此包中的常用方法(q = Queue.Queue()): q.qsize() 返回队列的大小q.empty() 如果队列为空，返回True,反之Falseq.full() 如果队列满了，返回True,反之Falseq.full 与 maxsize 大小对应q.get([block[, timeout]]) 获取队列，timeout等待时间q.get_nowait() 相当q.get(False)非阻塞q.put(item) 写入队列，timeout等待时间q.put_nowait(item) 相当q.put(item, False)q.task_done() 在完成一项工作之后，q.task_done() 函数向任务已经完成的队列发送一个信号q.join() 实际上意味着等到队列为空，再执行别的操作 其他模式Python Queue模块有三种队列及构造函数: 1、Python Queue模块的FIFO队列先进先出。 class queue.Queue(maxsize)2、LIFO类似于堆，即先进后出。 class queue.LifoQueue(maxsize)3、还有一种是优先级队列级别越低越先出来。 class queue.PriorityQueue(maxsize) 1234567891011121314151617181920import queue #先进后出 q=queue.LifoQueue() q.put(34)q.put(56)q.put(12) #优先级q=queue.PriorityQueue()q.put([5,100])q.put([7,200])q.put([3,"hello"])q.put([4,&#123;"name":"alex"&#125;]) while 1: data=q.get() print(data) 生产者消费者模型在线程世界里，生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程开发当中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。为了解决这个问题于是引入了生产者和消费者模式。 生产者消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。 这就像，在餐厅，厨师做好菜，不需要直接和客户交流，而是交给前台，而客户去饭菜也不需要不找厨师，直接去前台领取即可，这也是一个结耦的过程。 1234567891011121314151617181920212223242526272829303132333435363738import time,randomimport queue,threading q = queue.Queue() def Producer(name): count = 0 while count &lt;10: print("making........") time.sleep(random.randrange(3)) q.put(count) print('Producer %s has produced %s baozi..' %(name, count)) count +=1 #q.task_done() #q.join() print("ok......")def Consumer(name): count = 0 while count &lt;10: time.sleep(random.randrange(4)) if not q.empty(): data = q.get() #q.task_done() #q.join() print(data) print('\033[32;1mConsumer %s has eat %s baozi...\033[0m' %(name, data)) else: print("-----no baozi anymore----") count +=1 p1 = threading.Thread(target=Producer, args=('A',))c1 = threading.Thread(target=Consumer, args=('B',))# c2 = threading.Thread(target=Consumer, args=('C',))# c3 = threading.Thread(target=Consumer, args=('D',))p1.start()c1.start()# c2.start()# c3.start() multiprocessing模块1Multiprocessing is a package that supports spawning processes using an API similar to the threading module. The multiprocessing package offers both local and remote concurrency,effectively side-stepping the Global Interpreter Lock by using subprocesses instead of threads. Due to this, the multiprocessing module allows the programmer to fully leverage multiple processors on a given machine. It runs on both Unix and Windows. 由于GIL的存在，python中的多线程其实并不是真正的多线程，如果想要充分地使用多核CPU的资源，在python中大部分情况需要使用多进程。 multiprocessing包是Python中的多进程管理包。与threading.Thread类似，它可以利用multiprocessing.Process对象来创建一个进程。该进程可以运行在Python程序内部编写的函数。该Process对象与Thread对象的用法相同，也有start(), run(), join()的方法。此外multiprocessing包中也有Lock/Event/Semaphore/Condition类 (这些对象可以像多线程那样，通过参数传递给各个进程)，用以同步进程，其用法与threading包中的同名类一致。所以，multiprocessing的很大一部份与threading使用同一套API，只不过换到了多进程的情境。 python的进程调用123456789101112131415161718192021222324252627282930313233343536373839404142434445# Process类调用 from multiprocessing import Processimport timedef f(name): print('hello', name,time.ctime()) time.sleep(1) if __name__ == '__main__': p_list=[] for i in range(3): p = Process(target=f, args=('alvin:%s'%i,)) p_list.append(p) p.start() for i in p_list: p.join() print('end') # 继承Process类调用from multiprocessing import Processimport time class MyProcess(Process): def __init__(self): super(MyProcess, self).__init__() # self.name = name def run(self): print ('hello', self.name,time.ctime()) time.sleep(1) if __name__ == '__main__': p_list=[] for i in range(3): p = MyProcess() p.start() p_list.append(p) for p in p_list: p.join() print('end') process类构造方法： Process([group [, target [, name [, args [, kwargs]]]]]) group: 线程组，目前还没有实现，库引用中提示必须是None； target: 要执行的方法； name: 进程名； args/kwargs: 要传入方法的参数。 实例方法： is_alive()：返回进程是否在运行。 join([timeout])：阻塞当前上下文环境的进程程，直到调用此方法的进程终止或到达指定的timeout（可选参数）。 start()：进程准备就绪，等待CPU调度 run()：strat()调用run方法，如果实例进程时未制定传入target，这star执行t默认run()方法。 terminate()：不管任务是否完成，立即停止工作进程 属性： daemon：和线程的setDeamon功能一样 name：进程名字 pid：进程号 123456789101112131415161718192021222324252627282930from multiprocessing import Processimport osimport timedef info(name): print("name:",name) print('parent process:', os.getppid()) print('process id:', os.getpid()) print("------------------") time.sleep(1) def foo(name): info(name) if __name__ == '__main__': info('main process line') p1 = Process(target=info, args=('alvin',)) p2 = Process(target=foo, args=('egon',)) p1.start() p2.start() p1.join() p2.join() print("ending") 协程协程，又称微线程，纤程。英文名Coroutine。一句话说明什么是线程：协程是一种用户态的轻量级线程。 协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。因此： 协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。 yield与协程1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import time """传统的生产者-消费者模型是一个线程写消息，一个线程取消息，通过锁机制控制队列和等待，但一不小心就可能死锁。如果改用协程，生产者生产消息后，直接通过yield跳转到消费者开始执行，待消费者执行完毕后，切换回生产者继续生产，效率极高。"""# 注意到consumer函数是一个generator（生成器）:# 任何包含yield关键字的函数都会自动成为生成器(generator)对象 def consumer(): r = '' while True: # 3、consumer通过yield拿到消息，处理，又通过yield把结果传回； # yield指令具有return关键字的作用。然后函数的堆栈会自动冻结(freeze)在这一行。 # 当函数调用者的下一次利用next()或generator.send()或for-in来再次调用该函数时， # 就会从yield代码的下一行开始，继续执行，再返回下一次迭代结果。通过这种方式，迭代器可以实现无限序列和惰性求值。 n = yield r if not n: return print('[CONSUMER] ←← Consuming %s...' % n) time.sleep(1) r = '200 OK'def produce(c): # 1、首先调用c.next()启动生成器 next(c) n = 0 while n &lt; 5: n = n + 1 print('[PRODUCER] →→ Producing %s...' % n) # 2、然后，一旦生产了东西，通过c.send(n)切换到consumer执行； cr = c.send(n) # 4、produce拿到consumer处理的结果，继续生产下一条消息； print('[PRODUCER] Consumer return: %s' % cr) # 5、produce决定不生产了，通过c.close()关闭consumer，整个过程结束。 c.close()if __name__=='__main__': # 6、整个流程无锁，由一个线程执行，produce和consumer协作完成任务，所以称为“协程”，而非线程的抢占式多任务。 c = consumer() produce(c) '''result:[PRODUCER] →→ Producing 1...[CONSUMER] ←← Consuming 1...[PRODUCER] Consumer return: 200 OK[PRODUCER] →→ Producing 2...[CONSUMER] ←← Consuming 2...[PRODUCER] Consumer return: 200 OK[PRODUCER] →→ Producing 3...[CONSUMER] ←← Consuming 3...[PRODUCER] Consumer return: 200 OK[PRODUCER] →→ Producing 4...[CONSUMER] ←← Consuming 4...[PRODUCER] Consumer return: 200 OK[PRODUCER] →→ Producing 5...[CONSUMER] ←← Consuming 5...[PRODUCER] Consumer return: 200 OK''' greenletGreenlet是python的一个C扩展，来源于Stackless python，旨在提供可自行调度的‘微线程’， 即协程。generator实现的协程在yield value时只能将value返回给调用者(caller)。 而在greenlet中，target.switch（value）可以切换到指定的协程（target）， 然后yield value。greenlet用switch来表示协程的切换，从一个协程切换到另一个协程需要显式指定。 greenlet的安装很简单：pip install greenlet 即可，安装好了之后我们来看一个官方的例子 1234567891011121314from greenlet import greenletdef test1(): print 12 gr2.switch() print 34 def test2(): print 56 gr1.switch() print 78 gr1 = greenlet(test1)gr2 = greenlet(test2)gr1.switch() 输出为：12 56 34 当创建一个greenlet时，首先初始化一个空的栈， switch到这个栈的时候，会运行在greenlet构造时传入的函数（首先在test1中打印 12）， 如果在这个函数（test1）中switch到其他协程（到了test2 打印34），那么该协程会被挂起，等到切换回来（在test2中切换回来 打印34）。当这个协程对应函数执行完毕，那么这个协程就变成dead状态。 注意 上面没有打印test2的最后一行输出 78，因为在test2中切换到gr1之后挂起，但是没有地方再切换回来。这个可能造成泄漏，后面细说。 基于greenlet的框架gevent模块实现协程Python通过yield提供了对协程的基本支持，但是不完全。而第三方的gevent为Python提供了比较完善的协程支持。 gevent是第三方库，通过greenlet实现协程，其基本思想是： 当一个greenlet遇到IO操作时，比如访问网络，就自动切换到其他的greenlet，等到IO操作完成，再在适当的时候切换回来继续执行。由于IO操作非常耗时，经常使程序处于等待状态，有了gevent为我们自动切换协程，就保证总有greenlet在运行，而不是等待IO。 由于切换是在IO操作时自动完成，所以gevent需要修改Python自带的一些标准库，这一过程在启动时通过monkey patch完成： 123456789101112131415161718192021import geventimport time def foo(): print("running in foo") gevent.sleep(2) print("switch to foo again") def bar(): print("switch to bar") gevent.sleep(5) print("switch to bar again") start=time.time() gevent.joinall( [gevent.spawn(foo), gevent.spawn(bar)]) print(time.time()-start) 当然，实际代码里，我们不会用gevent.sleep()去切换协程，而是在执行到IO操作时，gevent自动切换，代码如下： 12345678910111213141516171819202122232425from gevent import monkeymonkey.patch_all()import geventfrom urllib import requestimport time def f(url): print('GET: %s' % url) resp = request.urlopen(url) data = resp.read() print('%d bytes received from %s.' % (len(data), url)) start=time.time() gevent.joinall([ gevent.spawn(f, 'https://itk.org/'), gevent.spawn(f, 'https://www.github.com/'), gevent.spawn(f, 'https://zhihu.com/'),]) # f('https://itk.org/')# f('https://www.github.com/')# f('https://zhihu.com/') print(time.time()-start) IO模型同步（synchronous） IO和异步（asynchronous） IO，阻塞（blocking） IO和非阻塞（non-blocking）IO分别是什么，到底有什么区别？这个问题其实不同的人给出的答案都可能不同，比如wiki，就认为asynchronous IO和non-blocking IO是一个东西。这其实是因为不同的人的知识背景不同，并且在讨论这个问题的时候上下文(context)也不相同。所以，为了更好的回答这个问题，先限定一下本文的上下文。本文讨论的背景是Linux环境下的network IO。 Stevens在文章中一共比较了五种IO Model： ​ blocking IO ​ nonblocking IO ​ IO multiplexing ​ signal driven IO ​ asynchronous IO 由于signal driven IO在实际中并不常用，所以我这只提及剩下的四种IO Model。再说一下IO发生时涉及的对象和步骤。对于一个network IO (这里我们以read举例)，它会涉及到两个系统对象，一个是调用这个IO的process (or thread)，另一个就是系统内核(kernel)。当一个read操作发生时，它会经历两个阶段： 等待数据准备 (Waiting for the data to be ready) 将数据从内核拷贝到进程中 (Copying the data from the kernel to the process) 记住这两点很重要，因为这些IO Model的区别就是在两个阶段上各有不同的情况。 blocking IO （阻塞IO）在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样： 当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据。对于network io来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的UDP包），这个时候kernel就要等待足够的数据到来。而在用户进程这边，整个进程会被阻塞。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。所以，blocking IO的特点就是在IO执行的两个阶段都被block了。 non-blocking IO（非阻塞IO）linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子： 从图中可以看出，当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。所以，用户进程其实是需要不断的主动询问kernel数据好了没有。 注意： ​ 在网络IO时候，非阻塞IO也会进行recvform系统调用，检查数据是否准备好，与阻塞IO不一样，”非阻塞将大的整片时间的阻塞分成N多的小的阻塞, 所以进程不断地有机会 ‘被’ CPU光顾”。即每次recvform系统调用之间，cpu的权限还在进程手中，这段时间是可以做其他事情的， ​ 也就是说非阻塞的recvform系统调用调用之后，进程并没有被阻塞，内核马上返回给进程，如果数据还没准备好，此时会返回一个error。进程在返回之后，可以干点别的事情，然后再发起recvform系统调用。重复上面的过程，循环往复的进行recvform系统调用。这个过程通常被称之为轮询。轮询检查内核数据，直到数据准备好，再拷贝数据到进程，进行数据处理。需要注意，拷贝数据整个过程，进程仍然是属于阻塞的状态。 12345678910111213141516171819202122232425262728293031import timeimport socketsk = socket.socket(socket.AF_INET,socket.SOCK_STREAM)sk.setsockoptsk.bind(('127.0.0.1',6667))sk.listen(5)sk.setblocking(False)while True: try: print ('waiting client connection .......') connection,address = sk.accept() # 进程主动轮询 print("+++",address) client_messge = connection.recv(1024) print(str(client_messge,'utf8')) connection.close() except Exception as e: print (e) time.sleep(4) #############################client import timeimport socketsk = socket.socket(socket.AF_INET,socket.SOCK_STREAM) while True: sk.connect(('127.0.0.1',6667)) print("hello") sk.sendall(bytes("hello","utf8")) time.sleep(2) break 优点：能够在等待任务完成的时间里干其他活了（包括提交其他任务，也就是 “后台” 可以有多个任务在同时执行）。 缺点：任务完成的响应延迟增大了，因为每过一段时间才去轮询一次read操作，而任务可能在两次轮询之间的任意时间完成。这会导致整体数据吞吐量的降低。 IO multiplexing（IO多路复用） IO multiplexing这个词可能有点陌生，但是如果我说select，epoll，大概就都能明白了。有些地方也称这种IO方式为event driven IO。我们都知道，select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select/epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。它的流程如图： IO多路复用实现机制 win ：select linux : select(效率最低) poll epoll select 当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。（多说一句。所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。 结论: select的优势在于可以处理多个连接，不适用于单个连接 select的缺点： 1.每次调用select都要将所有别的fd(文件描述符)拷贝至内核空间，导致效率下降 2.遍历所有的fd，是否有数据访问(最重要的问题) 3.最大连接数比较少 123456789101112131415161718192021222324252627282930import socketimport time import selectsock=socket.socket() sock.bind(("127.0.0.1",8800)) sock.listen(5) sock.setblocking(False)inputs=[sock,] print("sock",sock) while 1: r,w,e=select.select(inputs,[],[]) # 监听有变化的套接字 inputs=[sock,conn1,conn2,conn3..] print("r",r) for obj in r: # 第一次 [sock,] 第二次 #[conn1,] if obj==sock: print('change') conn,addr=obj.accept() inputs.append(conn) # inputs=[sock,conn] else: data=obj.recv(1024) print(data.decode("utf8")) send_data=input("&gt;&gt;&gt;") obj.send(send_data.encode("utf8")) poll 最大连接数没有限制 epoll 最大连接数没有上限 select是通过一个函数来实现，而epoll需要三个； 1.第一个函数：创建epoll句柄：将所有别的fd(文件描述符)拷贝至内核空间，但是只需拷贝一次 2.回调函数：某一个函数或者某一个动作成功完成后会自动触发的函数，为所有的fd(文件描述符)绑定一个回调函数，一旦有数据访问，触发该回调函数，回调函数将fd放到链表中； 3.第三个函数：判断链表是否为空 Asynchronous I/O（异步IO）linux下的asynchronous IO其实用得很少。先看一下它的流程： 用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。 IO模型比较分析到目前为止，已经将四个IO Model都介绍完了。现在回过头来回答最初的那几个问题：blocking和non-blocking的区别在哪，synchronous IO和asynchronous IO的区别在哪。先回答最简单的这个：blocking vs non-blocking。前面的介绍中其实已经很明确的说明了这两者的区别。调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还准备数据的情况下会立刻返回。 在说明synchronous IO和asynchronous IO的区别之前，需要先给出两者的定义。Stevens给出的定义（其实是POSIX的定义）是这样子的： A synchronous I/O operation causes the requesting process to be blocked until that I/O operationcompletes; An asynchronous I/O operation does not cause the requesting process to be blocked; 两者的区别就在于synchronous IO做”IO operation”的时候会将process阻塞。按照这个定义，之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。有人可能会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的IO操作，就是例子中的recvfrom这个system call。non-blocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程。但是，当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内，进程是被block的。而asynchronous IO则不一样，当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。 各个IO Model的比较如图所示： 经过上面的介绍，会发现non-blocking IO和asynchronous IO的区别还是很明显的。在non-blocking IO中，虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而asynchronous IO则完全不同。它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。 IO模型 1 阻塞IO:全程阻塞 2 非阻塞IO: 发送多次系统调用；优点：wait for data时无阻塞 缺点：1 系统调用太多 2 数据不是实时接受的 两个阶段：wait for data:非阻塞 copy data :阻塞 3 IO多路复用（监听多个连接） sock::sock &lt;socket.socket fd=224, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=0, laddr=(‘127.0.0.1’, 8800)&gt; 对于文件描述符（套接字对象）： 1 是一个非零整数，不会变 2 收发数据的时候，对于接收端而言，数据先到内核空间，然后copy到用户空间，同时，内核空间数据清除。 特点： 1 全程（wait for data,copy）阻塞 2 能监听多个文件描述符 3 实现并发 4 异步IO 全程无阻塞 总结： 同步： 阻塞IO 非阻塞IO io多路复用异步： 异步IO selectors模块12345678910111213141516171819202122232425262728293031323334353637383940414243import selectors # 基于select模块实现的IO多路复用，建议大家使用 import socket sock=socket.socket()sock.bind(("127.0.0.1",8800)) sock.listen(5) sock.setblocking(False) sel=selectors.DefaultSelector() #根据具体平台选择最佳IO多路机制，比如在linux，选择epoll def read(conn,mask): try: data=conn.recv(1024) print(data.decode("UTF8")) data2=input("&gt;&gt;&gt;") conn.send(data2.encode("utf8")) except Exception: sel.unregister(conn) def accept(sock,mask): conn, addr = sock.accept() print("conn",conn) sel.register(conn,selectors.EVENT_READ,read) sel.register(sock,selectors.EVENT_READ,accept) # 注册事件 while 1: print("wating...") events=sel.select() # 监听 [(key1,mask1),(key2,mask2)] for key,mask in events: # print(key.fileobj) # conn或者sock 对应有变化的对象 # print(key.data) # read或者accept 对应的触发函数 func=key.data obj=key.fileobj func(obj,mask) # 1 accept(sock,mask) # 2 read(conn,mask)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python之socket编程]]></title>
    <url>%2F2018%2F12%2F02%2Fpython%E4%B9%8Bsocket%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[客户端/服务器架构1.硬件C/S架构(打印机) 2.软件C/S架构 互联网中处处是C/S架构 如百度是服务端，你的浏览器是客户端（B/S架构也是C/S架构的一种） 腾讯作为服务端为你提供视频，你得下个腾讯视频客户端才能看它的视频） C/S架构与socket的关系： 我们学习socket就是为了完成C/S架构的开发 osi七层引子： 须知一个完整的计算机系统是由硬件、操作系统、应用软件三者组成,具备了这三个条件，一台计算机系统就可以自己跟自己玩了（打个单机游戏，玩个扫雷啥的） 如果你要跟别人一起玩，那你就需要上网了，什么是互联网？ 互联网的核心就是由一堆协议组成，协议就是标准，比如全世界人通信的标准是英语 如果把计算机比作人，互联网协议就是计算机界的英语。所有的计算机都学会了互联网协议，那所有的计算机都就可以按照统一的标准去收发信息从而完成通信了。 人们按照分工不同把互联网协议从逻辑上划分了层级： 互联网协议按照功能不同分为osi七层或tcp/ip五层或tcp/ip四层 每层运行常见物理设备 为何学习socket一定要先学习互联网协议： 1.首先：本节课程的目标就是教会你如何基于socket编程，来开发一款自己的C/S架构软件 2.其次：C/S架构的软件（软件属于应用层）是基于网络进行通信的 3.然后：网络的核心即一堆协议，协议即标准，你想开发一款基于网络通信的软件，就必须遵循这些标准。 4.最后：就让我们从这些标准开始研究，开启我们的socket编程之旅 socket层在上面中，我们没有看到Socket的影子，那么它到底在哪里呢？还是用图来说话，一目了然。 socket是什么Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。 所以，我们无需深入理解tcp/udp协议，socket已经为我们封装好了，我们只需要遵循socket的规定去编程，写出的程序自然就是遵循tcp/udp标准的。 也有人将socket说成ip+port，ip是用来标识互联网中的一台主机的位置，而port是用来标识这台机器上的一个应用程序，ip地址是配置到网卡上的，而port是应用程序开启的，ip与port的绑定就标识了互联网中独一无二的一个应用程序 而程序的pid是同一台机器上不同进程或者线程的标识 套接字发展史及分类套接字起源于 20 世纪 70 年代加利福尼亚大学伯克利分校版本的 Unix,即人们所说的 BSD Unix。 因此,有时人们也把套接字称为“伯克利套接字”或“BSD 套接字”。一开始,套接字被设计用在同 一台主机上多个应用程序之间的通讯。这也被称进程间通讯,或 IPC。套接字有两种（或者称为有两个种族）,分别是基于文件型的和基于网络型的。 基于文件类型的套接字家族 套接字家族的名字：AF_UNIX unix一切皆文件，基于文件的套接字调用的就是底层的文件系统来取数据，两个套接字进程运行在同一机器，可以通过访问同一个文件系统间接完成通信 基于网络类型的套接字家族 套接字家族的名字：AF_INET (还有AF_INET6被用于ipv6，还有一些其他的地址家族，不过，他们要么是只用于某个平台，要么就是已经被废弃，或者是很少被使用，或者是根本没有实现，所有地址家族中，AF_INET是使用最广泛的一个，python支持很多种地址家族，但是由于我们只关心网络编程，所以大部分时候我么只使用AF_INET) 套接字工作流程一个生活中的场景。你要打电话给一个朋友，先拨号，朋友听到电话铃声后提起电话，这时你和你的朋友就建立起了连接，就可以讲话了。等交流结束，挂断电话结束此次交谈。 生活中的场景就解释了这工作原理。 先从服务器端说起。服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。在这时如果有个客户端初始化一个Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束 socket()模块函数用法 123456789101112import socketsocket.socket(socket_family,socket_type,protocal=0)socket_family 可以是 AF_UNIX 或 AF_INET。socket_type 可以是 SOCK_STREAM 或 SOCK_DGRAM。protocol 一般不填,默认值为 0。 获取tcp/ip套接字tcpSock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 获取udp/ip套接字udpSock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) 由于 socket 模块中有太多的属性。我们在这里破例使用了'from module import *'语句。使用 'from socket import *',我们就把 socket 模块里的所有属性都带到我们的命名空间里了,这样能 大幅减短我们的代码。例如tcpSock = socket(AF_INET, SOCK_STREAM) 1234567891011121314151617181920212223242526272829服务端套接字函数s.bind() 绑定(主机,端口号)到套接字s.listen() 开始TCP监听s.accept() 被动接受TCP客户的连接,(阻塞式)等待连接的到来 客户端套接字函数s.connect() 主动初始化TCP服务器连接s.connect_ex() connect()函数的扩展版本,出错时返回出错码,而不是抛出异常 公共用途的套接字函数s.recv() 接收TCP数据s.send() 发送TCP数据(send在待发送数据量大于己端缓存区剩余空间时,数据丢失,不会发完)s.sendall() 发送完整的TCP数据(本质就是循环调用send,sendall在待发送数据量大于己端缓存区剩余空间时,数据不丢失,循环调用send直到发完)s.recvfrom() 接收UDP数据s.sendto() 发送UDP数据s.getpeername() 连接到当前套接字的远端的地址s.getsockname() 当前套接字的地址s.getsockopt() 返回指定套接字的参数s.setsockopt() 设置指定套接字的参数s.close() 关闭套接字 面向锁的套接字方法s.setblocking() 设置套接字的阻塞与非阻塞模式s.settimeout() 设置阻塞套接字操作的超时时间s.gettimeout() 得到阻塞套接字操作的超时时间 面向文件的套接字的函数s.fileno() 套接字的文件描述符s.makefile() 创建一个与该套接字相关的文件 基于TCP的套接字tcp是基于链接的，必须先启动服务端，然后再启动客户端去链接服务端 tcp服务端 12345678910import socketss = socket() #创建服务器套接字ss.bind() #把地址绑定到套接字ss.listen() #监听链接inf_loop: #服务器无限循环 cs = ss.accept() #接受客户端链接 comm_loop: #通讯循环 cs.recv()/cs.send() #对话(接收与发送) cs.close() #关闭客户端套接字ss.close() #关闭服务器套接字(可选) tcp客户端 123456import socketcs = socket() # 创建客户套接字cs.connect() # 尝试连接服务器comm_loop: # 通讯循环cs.send()/cs.recv() # 对话(发送/接收)cs.close() 实例：模仿ssh写服务端与客户端 tcp服务端 123456789101112131415161718192021222324252627import socketimport subprocessphone = socket.socket(socket.AF_INET, socket.SOCK_STREAM)phone.bind(('192.168.1.5', 8017))phone.listen(5)print('start....')while True: conf,message = phone.accept() print(conf) print(message) while True: try: data = conf.recv(1024) if not data: break data_tr = data.decode('utf-8') print(data_tr) # stdin,stdout, stderr： 分别指示要执行的程序标准输入、标准输出、标准错误输出文件的句柄 re = subprocess.Popen(data_tr, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) r1 = re.stdout.read() #读出来的是字节格式 r2 = re.stderr.read() conf.send(r1) conf.send(r2) except Exception: break conf.close()phone.close() tcp客户端 123456789101112import socketphone = socket.socket(socket.AF_INET, socket.SOCK_STREAM)phone.connect(('192.168.1.5', 8017))while True: sd = input("输入:".strip()) if not sd: continue phone.send(sd.encode('utf-8')) message = phone.recv(1024) print("----------------------") print(message.decode('gbk'))phone.close() 基于UDP的套接字udp是无链接的，先启动哪一端都不会报错 udp服务端 12345ss = socket() #创建一个服务器的套接字ss.bind() #绑定服务器套接字inf_loop: #服务器无限循环 cs = ss.recvfrom()/ss.sendto() # 对话(接收与发送)ss.close() # 关闭服务器套接字 udp客户端 1234cs = socket() # 创建客户套接字comm_loop: # 通讯循环 cs.sendto()/cs.recvfrom() # 对话(发送/接收)cs.close() # 关闭客户套接字 udp套接字简单示例 udp服务端 123456789101112import socketip_port=('127.0.0.1',9000)BUFSIZE=1024udp_server_client=socket.socket(socket.AF_INET,socket.SOCK_DGRAM) udp_server_client.bind(ip_port) while True: msg,addr=udp_server_client.recvfrom(BUFSIZE) print(msg,addr) udp_server_client.sendto(msg.upper(),addr) udp客户端 12345678910111213import socketip_port=('127.0.0.1',9000)BUFSIZE=1024udp_server_client=socket.socket(socket.AF_INET,socket.SOCK_DGRAM) while True: msg=input('&gt;&gt;: ').strip() if not msg:continue udp_server_client.sendto(msg.encode('utf-8'),ip_port) back_msg,addr=udp_server_client.recvfrom(BUFSIZE) print(back_msg.decode('utf-8'),addr) 粘包现象根据我之前写的模仿ssh程序，如果输入的命令，得到的内容比较大时，recv(1024)则可能不够用 什么是粘包须知：只有TCP有粘包现象，UDP永远不会粘包，为何，且听我娓娓道来 首先需要掌握一个socket收发消息的原理 发送端可以是一K一K地发送数据，而接收端的应用程序可以两K两K地提走数据，当然也有可能一次提走3K或6K数据，或者一次只提走几个字节的数据，也就是说，应用程序所看到的数据是一个整体，或说是一个流（stream），一条消息有多少字节对应用程序是不可见的，因此TCP协议是面向流的协议，这也是容易出现粘包问题的原因。而UDP是面向消息的协议，每个UDP段都是一条消息，应用程序必须以消息为单位提取数据，不能一次提取任意字节的数据，这一点和TCP是很不同的。怎样定义消息呢？可以认为对方一次性write/send的数据为一个消息，需要明白的是当对方send一条信息的时候，无论底层怎样分段分片，TCP协议层会把构成整条消息的数据段排序完成后才呈现在内核缓冲区。 例如基于tcp的套接字客户端往服务端上传文件，发送时文件内容是按照一段一段的字节流发送的，在接收方看了，根本不知道该文件的字节流从何处开始，在何处结束 所谓粘包问题主要还是因为接收方不知道消息之间的界限，不知道一次性提取多少字节的数据所造成的。 此外，发送方引起的粘包是由TCP协议本身造成的，TCP为提高传输效率，发送方往往要收集到足够多的数据后才发送一个TCP段。若连续几次需要send的数据都很少，通常TCP会根据优化算法把这些数据合成一个TCP段后一次发送出去，这样接收方就收到了粘包数据。 1231. TCP（transport control protocol，传输控制协议）是面向连接的，面向流的，提供高可靠性服务。收发两端（客户端和服务器端）都要有一一成对的socket，因此，发送端为了将多个发往接收端的包，更有效的发到对方，使用了优化方法（Nagle算法），将多次间隔较小且数据量小的数据，合并成一个大的数据块，然后进行封包。这样，接收端，就难于分辨出来了，必须提供科学的拆包机制。 即面向流的通信是无消息保护边界的。2. UDP（user datagram protocol，用户数据报协议）是无连接的，面向消息的，提供高效率服务。不会使用块的合并优化算法，, 由于UDP支持的是一对多的模式，所以接收端的skbuff(套接字缓冲区）采用了链式结构来记录每一个到达的UDP包，在每个UDP包中就有了消息头（消息来源地址，端口等信息），这样，对于接收端来说，就容易进行区分处理了。 即面向消息的通信是有消息保护边界的。3. tcp是基于数据流的，于是收发的消息不能为空，这就需要在客户端和服务端都添加空消息的处理机制，防止程序卡住，而udp是基于数据报的，即便是你输入的是空内容（直接回车），那也不是空消息，udp协议会帮你封装上消息头，实验略 udp的recvfrom是阻塞的，一个recvfrom(x)必须对唯一一个sendinto(y),收完了x个字节的数据就算完成,若是y&gt;x数据就丢失，这意味着udp根本不会粘包，但是会丢数据，不可靠 tcp的协议数据不会丢，没有收完包，下次接收，会继续上次继续接收，己端总是在收到ack时才会清除缓冲区内容。数据是可靠的，但是会粘包。 两种情况下会发生粘包。 1.发送端需要等缓冲区满才发送出去，造成粘包（发送数据时间间隔很短，数据了很小，会合到一起，产生粘包） 服务端 123456789101112131415161718from socket import *ip_port=('127.0.0.1',8080) tcp_socket_server=socket(AF_INET,SOCK_STREAM)tcp_socket_server.bind(ip_port)tcp_socket_server.listen(5) conn,addr=tcp_socket_server.accept() data1=conn.recv(10)data2=conn.recv(10) print('-----&gt;',data1.decode('utf-8'))print('-----&gt;',data2.decode('utf-8')) conn.close() 客户端 12345678910import socketBUFSIZE=1024ip_port=('127.0.0.1',8080) s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)res=s.connect_ex(ip_port) s.send('hello'.encode('utf-8'))s.send('feng'.encode('utf-8')) 2.接收方不及时接收缓冲区的包，造成多个包接收（客户端发送了一段数据，服务端只收了一小部分，服务端下次再收的时候还是从缓冲区拿上次遗留的数据，产生粘包） 服务端 123456789101112131415161718from socket import *ip_port=('127.0.0.1',8080) tcp_socket_server=socket(AF_INET,SOCK_STREAM)tcp_socket_server.bind(ip_port)tcp_socket_server.listen(5) conn,addr=tcp_socket_server.accept() data1=conn.recv(2) #一次没有收完整data2=conn.recv(10)#下次收的时候,会先取旧的数据,然后取新的 print('-----&gt;',data1.decode('utf-8'))print('-----&gt;',data2.decode('utf-8')) conn.close() 客户端 123456789import socketBUFSIZE=1024ip_port=('127.0.0.1',8080) s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)res=s.connect_ex(ip_port) s.send('hello feng'.encode('utf-8')) 拆包的发生情况 当发送端缓冲区的长度大于网卡的MTU时，tcp会将这次发送的数据拆成几个数据包发送出去。 补充问题一：为何tcp是可靠传输，udp是不可靠传输 tcp在数据传输时，发送端先把数据发送到自己的缓存中，然后协议控制将缓存中的数据发往对端，对端返回一个ack=1，发送端则清理缓存中的数据，对端返回ack=0，则重新发送数据，所以tcp是可靠的 而udp发送数据，对端是不会返回确认信息的，因此不可靠 补充问题二：send(字节流)和recv(1024)及sendall recv里指定的1024意思是从缓存里一次拿出1024个字节的数据 send的字节流是先放入己端缓存，然后由协议控制将缓存内容发往对端，如果待发送的字节流大小大于缓存剩余空间，那么数据丢失，用sendall就会循环调用send，数据不会丢失 解决粘包的方法为字节流加上自定义固定长度报头，报头中包含字节流长度，然后一次send到对端，对端在接收时，先从缓存中取出定长的报头，然后再取真实数据 struct模块 该模块可以把一个类型，如数字，转成固定长度的bytes 1struct.pack('i',1111111111111) struct.error: ‘i’ format requires -2147483648 &lt;= number &lt;= 2147483647 #这个是范围 123456789101112131415161718192021222324252627import json,struct#假设通过客户端上传1T:1073741824000的文件a.txt #为避免粘包,必须自定制报头header=&#123;'file_size':1073741824000,'file_name':'/a/b/c/d/e/a.txt','md5':'8f6fbf8347faa4924a76856701edb0f3'&#125; #1T数据,文件路径和md5值 #为了该报头能传送,需要序列化并且转为byteshead_bytes=bytes(json.dumps(header),encoding='utf-8') #序列化并转成bytes,用于传输 #为了让客户端知道报头的长度,用struck将报头长度这个数字转成固定长度:4个字节head_len_bytes=struct.pack('i',len(head_bytes)) #这4个字节里只包含了一个数字,该数字是报头的长度 #客户端开始发送conn.send(head_len_bytes) #先发报头的长度,4个bytesconn.send(head_bytes) #再发报头的字节格式conn.sendall(文件内容) #然后发真实内容的字节格式 #服务端开始接收head_len_bytes=s.recv(4) #先收报头4个bytes,得到报头长度的字节格式x=struct.unpack('i',head_len_bytes)[0] #提取报头的长度 head_bytes=s.recv(x) #按照报头长度x,收取报头的bytes格式header=json.loads(json.dumps(header)) #提取报头 #最后根据报头的内容提取真实的数据,比如real_data_len=s.recv(header['file_size'])s.recv(real_data_len) 服务端（自定制报头） 123456789101112131415161718192021222324252627282930313233343536373839404142import socketimport subprocessimport structimport jsonphone = socket.socket(socket.AF_INET, socket.SOCK_STREAM)phone.bind(('192.168.1.1', 8019))phone.listen(5)print('start....')while True: conf,message = phone.accept() print(conf) print(message) while True: try: data = conf.recv(1024) if not data: break data_tr = data.decode('utf-8') print(data_tr) # stdin,stdout, stderr： 分别指示要执行的程序标准输入、标准输出、标准错误输出文件的句柄 re = subprocess.Popen(data_tr, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) r1 = re.stdout.read() r2 = re.stderr.read() # 真正内容的长度 r_size = len(r1) + len(r2) # head头字典的格式 head_dict = &#123;'data_size': r_size&#125; # 用json转换 head_json = json.dumps(head_dict) head_content = head_json.encode('utf-8') # 发送报头的长度 head_size = len(head_content) conf.send(struct.pack('i', head_size)) # 发送报头 conf.send(head_content) # 发送真正的内容 conf.send(r1) conf.send(r2) except Exception: break conf.close()phone.close() 客户端（自定制报头） 1234567891011121314151617181920212223import socketimport structimport jsonphone = socket.socket(socket.AF_INET, socket.SOCK_STREAM)phone.connect(('192.168.1.1', 8019))while True: sd = input("输入:".strip()) if not sd: continue phone.send(sd.encode('utf-8')) baotou = phone.recv(4) baotou_len = struct.unpack('i', baotou)[0] head_json = phone.recv(baotou_len).decode('utf-8') head_size = json.loads(head_json) data_size = head_size['data_size'] real_content = b'' real_size = 0 if real_size &lt; data_size: data = phone.recv(1024) real_size += len(data) real_content += data print(real_content.decode('gbk'))phone.close() FTP例子：服务端有上传文件到服务器的功能 客户端 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import jsonimport structimport osimport socket class MyClient: coding = 'utf-8' address_family = socket.AF_INET socket_type = socket.SOCK_STREAM def __init__(self, client_address, client_active=True): self.client_address = client_address self.sock = socket.socket(self.address_family, self.socket_type) if client_active: try: self.client_connect() except: self.client_close() raise def client_connect(self): self.sock.connect(self.client_address) def client_close(self): self.sock.close() def run(self): print('请输入命令以及要上传的文件的路径') while True: inp = input("&gt;&gt;: ").strip() if not inp: continue inp_split = inp.split() cmd = inp_split[0] if hasattr(self, cmd): fu = getattr(self, cmd) fu(inp_split) def put(self, args): cmd = args[0] filename = args[1] if not os.path.isfile(filename): print('file:%s is not exists' % filename) return else: filesize = os.path.getsize(filename) head_dic = &#123;'cmd': cmd, 'file_name': os.path.basename(filename), 'file_size': filesize&#125; head_json = json.dumps(head_dic) head_json_bytes = head_json.encode(self.coding) head_struct = struct.pack('i', len(head_json_bytes)) # 发送报头的长度 self.sock.send(head_struct) # 发送真正的报头 self.sock.send(head_json_bytes) # 发送内容 send_size = 0 with open(filename, 'rb') as f: for i in f: self.sock.send(i) send_size += len(i) print(send_size) else: print('upload successful') c = MyClient(('192.168.1.1', 8089))c.run() 服务端 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import jsonimport osimport structimport socket class MyFtp: coding = 'utf-8' address_family = socket.AF_INET socket_type = socket.SOCK_STREAM server_dir = 'D://test' request_size = 5 max_packet_size = 8000 def __init__(self, server_address, server_active=True): self.server_address = server_address self.sock = socket.socket(self.address_family, self.socket_type) if server_active: try: self.server_bind() self.server_listen() except: self.server_close() raise def server_bind(self): self.sock.bind(self.server_address) def server_listen(self): self.sock.listen(self.request_size) def server_close(self): self.sock.close() def get_requset(self): return self.sock.accept() def run(self): while True: self.con,self.client_address = self.get_requset() while True: try: head_struct = self.con.recv(4) if not head_struct: break head_size = struct.unpack('i', head_struct)[0] head_json = self.con.recv(head_size).decode(self.coding) head_content = json.loads(head_json) cmd = head_content['cmd'] if hasattr(self, cmd): fuc = getattr(self, cmd) fuc(head_content) except Exception: break def put(self, head_content): file_path = os.path.normpath(os.path.join(self.server_dir, head_content['file_name'])) file_size = head_content['file_size'] recv_size = 0 with open(file_path, 'wb') as f: while recv_size &lt; file_size: file_content = self.con.recv(self.max_packet_size) f.write(file_content) recv_size += len(file_content) print(recv_size) t = MyFtp(('192.168.1.1', 8089))t.run() socketserver实现并发基于tcp的套接字，关键就是两个循环，一个链接循环，一个通信循环 socketserver模块中分两大类：server类（解决链接问题）和request类（解决通信问题） server类： request类： 继承关系: 以下述代码为例，分析socketserver源码： 123456789101112import socketserver class MyServer(socketserver.BaseRequestHandler): def handle(self): data = self.request.recv(1024) self.request.send(data.upper()) if __name__ == '__main__': obj = socketserver.ThreadingTCPServer(('192.168.1.1', 8014), MyServer) # 循环链接 obj.serve_forever() 查找属性的顺序：ThreadingTCPServer-&gt;ThreadingMixIn-&gt;TCPServer-&gt;BaseServer 123451、实例化得到ftpserver，先找类ThreadingTCPServer的__init__,在TCPServer中找到，进而执行server_bind,server_active2、找ftpserver下的serve_forever,在BaseServer中找到，进而执行self._handle_request_noblock()，该方法同样是在BaseServer中3、执行self._handle_request_noblock()进而执行request, client_address = self.get_request()（就是TCPServer中的self.socket.accept()），然后执行self.process_request(request, client_address)4、在ThreadingMixIn中找到process_request，开启多线程应对并发，进而执行process_request_thread，执行self.finish_request(request, client_address)5、上述四部分完成了链接循环，本部分开始进入处理通讯部分，在BaseServer中找到finish_request,触发我们自己定义的类的实例化，去找__init__方法，而我们自己定义的类没有该方法，则去它的父类也就是BaseRequestHandler中找.... 源码分析总结： 基于tcp的socketserver我们自己定义的类中的 1.self.server即套接字对象 2.self.request即一个链接 3.self.client_address即客户端地址 基于udp的socketserver我们自己定义的类中的 self.request是一个元组（第一个元素是客户端发来的数据，第二部分是服务端的udp套接字对象），如(b’adsf’, &lt;socket.socket fd=200, family=AddressFamily.AF_INET, type=SocketKind.SOCK_DGRAM, proto=0, laddr=(‘127.0.0.1’, 8080)&gt;) 1.self.client_address即客户端地址 2.self.client_address即客户端地址 将之前的服务端改成并发的： 123456789101112131415161718192021222324252627282930313233343536373839404142import jsonimport osimport structimport socketserver class MyFtp(socketserver.BaseRequestHandler): coding = 'utf-8' server_dir = 'D://test' request_size = 5 max_packet_size = 8000 def handle(self): #所有请求的交互都是在handle里执行的, while True: try: head_struct = self.request.recv(4) if not head_struct: break head_size = struct.unpack('i', head_struct)[0] head_json = self.request.recv(head_size).decode(self.coding) head_content = json.loads(head_json) cmd = head_content['cmd'] if hasattr(self, cmd): fuc = getattr(self, cmd) fuc(head_content) except Exception: break def put(self, head_content): file_path = os.path.normpath(os.path.join(self.server_dir, head_content['file_name'])) file_size = head_content['file_size'] recv_size = 0 with open(file_path, 'wb') as f: while recv_size &lt; file_size: file_content = self.request.recv(self.max_packet_size) f.write(file_content) recv_size += len(file_content) print(recv_size) obj = socketserver.ThreadingTCPServer(('192.168.1.1', 8089), MyFtp)obj.serve_forever() UDP的并发 客户端： 12345678910import socket sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)sever_address = ('192.168.1.1', 8089)while True: inp = input("&gt;&gt;&gt;&gt;&gt;&gt;") sock.sendto(inp.encode('utf-8'), sever_address) data, server = sock.recvfrom(1024) print(data.decode('utf-8')) print(server) 服务端 1234567891011import socketserver class MyUdpServer(socketserver.BaseRequestHandler): def handle(self): print(self.request[0]) # 得到的是客户端发来的信息 print(self.request[1]) # 得到一个对象 self.request[1].sendto('草拟吗'.encode('utf-8'), self.client_address) if __name__ == '__main__': obj = socketserver.ThreadingUDPServer(('192.168.1.1', 8089), MyUdpServer) obj.serve_forever()]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python软件目录结构规范]]></title>
    <url>%2F2018%2F11%2F29%2Fpython%E8%BD%AF%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[软件目录结构规范软件开发规范 一、为什么要设计好目录结构? 1.可读性高: 不熟悉这个项目的代码的人，一眼就能看懂目录结构，知道程序启动脚本是哪个，测试目录在哪儿，配置文件在哪儿等等。从而非常快速的了解这个项目。 2.可维护性高: 定义好组织规则后，维护者就能很明确地知道，新增的哪个文件和代码应该放在什么目录之下。这个好处是，随着时间的推移，代码/配置的规模增加，项目结构不会混乱，仍然能够组织良好。 二、目录组织方式 关于如何组织一个较好的Python工程目录结构，已经有一些得到了共识的目录结构。 假设你的项目名为ATM 12345678910111213141516171819202122232425262728293031ATM/|-- bin/ 存放项目的一些可执行文件，当然你可以起名script/之类的也行，但bin/更直观。易懂| |-- __init__| |-- start.py 写启动程序||-- core/ 存放项目的所有源代码(核心代码）。(1) 源代码中的所有模块、包都应该放在此目录。不要置于顶层目录。 (2) 其子目录tests/存放单元测试代码； (3) 程序的入口最好命名为main.py。| |-- tests/ | | |-- __init__.py| | |-- test.main.py | || |-- __init__.py| |-- test_main.py| 存放核心逻辑 ||-- conf/ 配置文件| |-- __init__.py| |-- setting.py 写上相关配置||---db/ 数据库文件| |--db.json 写数据库文件| |-- docs/ 存放一些文档| |-- lib/ 库文件，放自定义模块和包| |-- __init__.py| |-- common.py 放常用的功能||-- log/ 日志文件| |-- access.log 写上日志||-- __init__.py|-- README 项目说明文件 运行程序时，在bin目录下执行start.py代码，不可以直接执行core下的模块。 README相关 使用过开源软件的朋友们都知道README可以给软件的使用带来很大的帮助，包括软件介绍、功能定位、安装启动使用方法、有建议或bug怎么联系作者等，其必要性和重要性不言而喻。 因此每一个项目都应该有README说明，好的README应该至少包括以下几方面的内容： 软件的简要介绍、功能定位、适用场景等软件的安装、环境依赖、启动方法、常见使用命令（使用说明）等代码的目录结构说明常见问题说明遇到建议或bug如何联系作者或项目组 如果再编写的更详细，可以考虑简述软件的基本原理。这方面最好的参考就是开源软件的README，如nginx，redis等。！]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>目录规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python包]]></title>
    <url>%2F2018%2F11%2F29%2Fpython%E5%8C%85%2F</url>
    <content type="text"><![CDATA[包介绍1、什么是包？ 官网解释Packages are a way of structuring Python’s module namespace by using “dotted module names”包是一种通过使用‘.模块名’来组织python模块名称空间的方式。 具体的：包就是一个包含有__init__.py文件的文件夹，所以其实我们创建包的目的就是为了用文件夹将文件/模块组织起来 需要强调的是： 在python3中，即使包下没有__init__.py文件，import 包仍然不会报错，而在python2中，包下一定要有该文件，否则import 包报错 创建包的目的不是为了运行，而是被导入使用，记住，包只是模块的一种形式而已，包的本质就是一种模块 2、为何要使用包 包的本质就是一个文件夹，那么文件夹唯一的功能就是将文件组织起来 随着功能越写越多，我们无法将所以功能都放到一个文件中，于是我们使用模块去组织功能，而随着模块越来越多，我们就需要用文件夹将模块文件组织起来，以此来提高程序的结构性和可维护性 3、注意事项 1.关于包相关的导入语句也分为import和from … import …两种，但是无论哪种，无论在什么位置，在导入时都必须遵循一个原则：凡是在导入时带点的，点的左边都必须是一个包，否则非法。可以带有一连串的点，如item.subitem.subsubitem,但都必须遵循这个原则。但对于导入后，在使用时就没有这种限制了，点的左边可以是包,模块，函数，类(它们都可以用点的方式调用自己的属性)。 2、import导入文件时，产生名称空间中的名字来源于文件，import 包，产生的名称空间的名字同样来源于文件，即包下的init.py，导入包本质就是在导入该文件 3、包A和包B下有同名模块也不会冲突，如A.a与B.a来自俩个命名空间 包的使用1、示范文件 1234567891011121314151617181920212223glance/ #Top-level package├── __init__.py #Initialize the glance package├── api #Subpackage for api│ ├── __init__.py│ ├── policy.py│ └── versions.py├── cmd #Subpackage for cmd│ ├── __init__.py│ └── manage.py└── db #Subpackage for db ├── __init__.py └── models.py 包所包含的文件内容 文件内容 #policy.py 12def get(): print('from policy.py') #versions.py 12def create_resource(conf): print('from version.py: ',conf) #manage.py 12def main(): print('from manage.py') #models.py 12def register_models(engine): print('from models.py:',engine) 执行文件与示范文件在同级目录下 2、包的使用之import 12import glance.db.modelsglance.db.models.register_models('mysql') 单独导入包名称时不会导入包中所有包含的所有子模块，如 12345678#在与glance同级的test.py中import glanceglance.cmd.manage.main() '''执行结果：AttributeError: module 'glance' has no attribute 'cmd'''' 解决方法： 12345#glance/__init__.pyfrom . import cmd#glance/cmd/__init__.pyfrom . import manage 执行： 123#在于glance同级的test.py中import glanceglance.cmd.manage.main() 3、包的使用之from … import … 需要注意的是from后import导入的模块，必须是明确的一个不能带点，否则会有语法错误，如：from a import b.c是错误语法 4、from glance.api import * 在讲模块时，我们已经讨论过了从一个模块内导入所有，此处我们研究从一个包导入所有。 此处是想从包api中导入所有，实际上该语句只会导入包api下__init__.py文件中定义的名字，我们可以在这个文件中定义__all___: 1234567#在__init__.py中定义x=10 def func(): print('from api.__init.py') __all__=['x','func','policy'] 此时我们在于glance同级的文件中执行from glance.api import *就导入__all__中的内容（versions仍然不能导入）。 5、绝对导入和相对导入 我们的最顶级包glance是写给别人用的，然后在glance包内部也会有彼此之间互相导入的需求，这时候就有绝对导入和相对导入两种方式： 绝对导入：以glance作为起始 相对导入：用.或者..的方式最为起始（只能在一个包中使用，不能用于不同目录内） 例如：我们在glance/api/version.py中想要导入glance/cmd/manage.py 在glance/api/version.py #绝对导入 12from glance.cmd import managemanage.main() #相对导入 12from ..cmd import managemanage.main() 测试结果：注意一定要在于glance同级的文件中测试 6、包以及包所包含的模块都是用来被导入的，而不是被直接执行的。而环境变量都是以执行文件为准的 比如我们想在glance/api/versions.py中导入glance/api/policy.py，有的同学一抽这俩模块是在同一个目录下，十分开心的就去做了，它直接这么做 12345678910111213from glance.api import versions '''执行结果:ImportError: No module named 'policy'''' '''分析:此时我们导入versions在versions.py中执行import policy需要找从sys.path也就是从当前目录找policy.py,这必然是找不到的''' 7、 绝对导入与相对导入总结 绝对导入与相对导入 绝对导入: 以执行文件的sys.path为起始点开始导入,称之为绝对导入 优点: 执行文件与被导入的模块中都可以使用 缺点: 所有导入都是以sys.path为起始点,导入麻烦 相对导入: 参照当前所在文件的文件夹为起始开始查找,称之为相对导入 符号: .代表当前所在文件的文件加,..代表上一级文件夹,…代表上一级的上一级文件夹 优点: 导入更加简单 缺点: 只能在导入包中的模块时才能使用注意: 1.相对导入只能用于包内部模块之间的相互导入,导入者与被导入者都必须存在于一个包内 2.attempted relative import beyond top-level package # 试图在顶级包之外使用相对导入是错误的,言外之意,必须在顶级包内使用相对导入,每增加一个.代表跳到上一级文件夹,而上一级不应该超出顶级包 如果要导入的文件不在同一个包中 例：在a1.py中导入test3 1234import os,sysre = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))) #找到当前文件的上上级目录sys.path.append(re) #添加到路径中import test3 例：如果在test1.py中 12import AA.kill() 这样肯定会报错，想要通过这样调用到A下面的AA下面的a1.py的kill方法，需要在A下面的__init__文件中加入 1from .AA.a1 import kill 这样在test1文件中就能直接使用A.kill() 对于包来说必须要遵守以下原则 特别要注意的是： 可以 用import导入内置或者第三方模块，但是要绝对避免使用import来导入自定义包的子模块，应该使用from… import… 的绝对或者相对导入，且包的相对导入只能用from的形式]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python模块]]></title>
    <url>%2F2018%2F11%2F27%2Fpython%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[模块介绍1、什么是模块？ 模块就是一组功能的集合体，我们的程序可以导入模块来复用模块里的功能。 123456常见的场景：一个模块就是一个包含了一组功能的python文件,比如spam.py，模块名为spam，可以通过import spam使用。在python中，模块的使用方式都是一样的，但其实细说的话，模块可以分为四个通用类别： 1 使用python编写的.py文件 2 已被编译为共享库或DLL的C或C++扩展 3 把一系列模块组织到一起的文件夹（注：文件夹下有一个__init__.py文件，该文件夹称之为包） 4 使用C编写并链接到python解释器的内置模块 2、为何要使用模块？ 1、从文件级别组织程序，更方便管理 随着程序的发展，功能越来越多，为了方便管理，我们通常将程序分成一个个的文件，这样做程序的结构更清晰，方便管理。这时我们不仅仅可以把这些文件当做脚本去执行，还可以把他们当做模块来导入到其他的模块中，实现了功能的重复利用 2、拿来主义，提升开发效率 同样的原理，我们也可以下载别人写好的模块然后导入到自己的项目中使用，这种拿来主义，可以极大地提升我们的开发效率 ps： 如果你退出python解释器然后重新进入，那么你之前定义的函数或者变量都将丢失，因此我们通常将程序写到文件中以便永久保存下来，需要时就通过python test.py方式去执行，此时test.py被称为脚本script。 3、以spam.py为例来介绍模块的使用：文件名spam.py,模块名spam 123456789101112131415#spam.pyprint('from the spam.py') money=1000 def read1(): print('spam模块：',money) def read2(): print('spam模块') read1() def change(): global money money=0 使用模块之import1、模块可以包含可执行的语句和函数的定义 这些语句的目的是初始化模块，它们只在模块名第一次遇到导入import语句时才执行（import语句是可以在程序中的任意位置使用的,且针对同一个模块很import多次,为了防止你重复导入，python的优化手段是：第一次导入后就将模块名加载到内存了，后续的import语句仅是对已经加载到内存中的模块对象增加了一次引用，不会重新执行模块内的语句），如下 12345#test.pyimport spam #只在第一次导入时才执行spam.py内代码,此处的显式效果是只打印一次'from the spam.py',当然其他的顶级代码也都被执行了,只不过没有显示效果.import spamimport spamimport spam 执行结果：from the spam.py 2、在第一次导入模块时会做三件事，重复导入会直接引用内存中已经加载好的结果 1.为源文件(spam模块)创建新的名称空间，在spam中定义的函数和方法若是使用到了global时访问的就是这个名称空间。 2.在新创建的命名空间中执行模块中包含的代码，见初始导入import spam 提示:导入模块时到底执行了什么？ In fact function definitions are also ‘statements’ that are ‘executed’; the execution of a module-level function definition enters the function name in the module’s global symbol table. 事实上函数定义也是“被执行”的语句，模块级别函数定义的执行将函数名放 入模块全局名称空间表，用globals()可以查看 3.创建名字spam来引用该命名空间 这个名字和变量名没什么区别，都是‘第一类的’，且使用spam.名字的方式 可以访问spam.py文件中定义的名字，spam.名字与test.py中的名字来自 两个完全不同的地方。 3、被导入模块有独立的名称空间 每个模块都是一个独立的名称空间，定义在这个模块中的函数，把这个模块的名称空间当做全局名称空间，这样我们在编写自己的模块时，就不用担心我们定义在自己模块中全局变量会在被导入时，与使用者的全局变量冲突 测试一:money与spam.money不冲突 12345678910#test.pyimport spam money=10print(spam.money) '''执行结果：from the spam.py1000''' 测试二：read1与spam.read1不冲突 1234567891011#test.pyimport spamdef read1(): print('========')spam.read1() '''执行结果:from the spam.pyspam模块：1000''' 测试三：执行spam.change()操作的全局变量money仍然是spam中的 1234567891011#test.pyimport spammoney=1spam.change()print(money) '''执行结果：from the spam.py1''' 4、为模块名起别名 为已经导入的模块起别名的方式对编写可扩展的代码很有用 12import spam as smprint(sm.money) 有两中sql模块mysql和oracle，根据用户的输入，选择不同的sql功能 123456789101112131415#mysql.pydef sqlparse(): print('from mysql sqlparse')#oracle.pydef sqlparse(): print('from oracle sqlparse') #test.pydb_type=input('&gt;&gt;: ')if db_type == 'mysql': import mysql as dbelif db_type == 'oracle': import oracle as db db.sqlparse() 假设有两个模块xmlreader.py和csvreader.py，它们都定义了函数read_data(filename):用来从文件中读取一些数据，但采用不同的输入格式。可以编写代码来选择性地挑选读取模块 12345if file_format == 'xml': import xmlreader as readerelif file_format == 'csv': import csvreader as readerdata=reader.read_date(filename) 5、在一行导入多个模块（不推荐） 1import sys,os,re 使用模块之from … import…1、from…import…的使用 1from spam import read1,read2 2、from…import 与import的对比 唯一的区别就是：使用from…import…则是将spam中的名字直接导入到当前的名称空间中，所以在当前名称空间中，直接使用名字就可以了、无需加前缀：spam. from...import...的方式有好处也有坏处 好处：使用起来方便了 坏处：容易与当前执行文件中的名字冲突 验证一：当前位置直接使用read1和read2就好了，执行时，仍然以spam.py文件全局名称空间 123456789101112131415161718192021222324#测试一：导入的函数read1，执行时仍然回到spam.py中寻找全局变量money#test.pyfrom spam import read1money=1000read1()'''执行结果:from the spam.pyspam-&gt;read1-&gt;money 1000''' #测试二:导入的函数read2，执行时需要调用read1(),仍然回到spam.py中找read1()#test.pyfrom spam import read2def read1(): print('==========')read2() '''执行结果:from the spam.pyspam-&gt;read2 calling readspam-&gt;read1-&gt;money 1000''' 验证二：如果当前有重名read1或者read2，那么会有覆盖效果 12345678910#test.pyfrom spam import read1def read1(): print('==========')read1()'''执行结果:from the spam.py==========''' 验证三：导入的方法在执行时，始终是以源文件为准的 12345678910from spam import money,read1money=100 #将当前位置的名字money绑定到了100print(money) #打印当前的名字read1() #读取spam.py中的名字money,仍然为1000 '''from the spam.py100spam-&gt;read1-&gt;money 1000''' 3、也支持as from spam import read1 as read 4、一行导入多个名字 from spam import read1,read2,money 5、from…import * from spam import * 把spam中所有的不是以下划线(_)开头的名字都导入到当前位置 大部分情况下我们的python程序不应该使用这种导入方式，因为*你不知道你导入什么名字，很有可能会覆盖掉你之前已经定义的名字。而且可读性极其的差，在交互式环境中导入时没有问题。 可以使用__all__来控制*（用来发布新版本），在spam.py中新增一行 __all__=[&#39;money&#39;,&#39;read1&#39;]#这样在另外一个文件中用from spam import *就这能导入列表中规定的两个名字 模块的重载 (了解)考虑到性能的原因，每个模块只被导入一次,放入字典sys.module中，如果你改变了模块的内容，你必须重启程序，python不支持重新加载或卸载之前导入的模块， 有的同学可能会想到直接从sys.module中删除一个模块不就可以卸载了吗，注意了，你删了sys.module中的模块对象仍然可能被其他程序的组件所引用，因而不会被清楚。 特别的对于我们引用了这个模块中的一个类，用这个类产生了很多对象，因而这些对象都有关于这个模块的引用。 编写好的一个python文件可以有两种用途： 一：脚本，一个文件就是整个程序，用来被执行 二：模块，文件中存放着一堆功能，用来被导入使用 python为我们内置了全局变量__name__， 当文件被当做脚本执行时：__name__ 等于__main__ 当文件被当做模块导入时：__name__等于模块名 作用：用来控制.py文件在不同的应用场景下执行不同的逻辑 if __name__ == &#39;__main__&#39;: 模块搜索路径模块的查找顺序是：内存中已经加载的模块-&gt;内置模块-&gt;sys.path路径中包含的模块 搜索路径：当一个命名为spam的模块被导入时 解释器首先会从内建模块中寻找该名字 找不到，则去sys.path中找该名字 sys.path从以下位置初始化 1 执行文件所在的当前目录 2 PTYHONPATH（包含一系列目录名，与shell变量PATH语法一样） 3 依赖安装时默认指定的 注意：在支持软连接的文件系统中，执行脚本所在的目录是在软连接之后被计算的，换句话说，包含软连接的目录不会被添加到模块的搜索路径中 在初始化后，我们也可以在python程序中修改sys.path,执行文件所在的路径默认是sys.path的第一个目录，在所有标准库路径的前面。这意味着，当前目录是优先于标准库目录的，需要强调的是：我们自定义的模块名不要跟python标准库的模块名重复，除非你是故意的。 编译python文件（了解）为了提高加载模块的速度，强调强调强调：提高的是加载速度而绝非运行速度。python解释器会在pycache目录中下缓存每个模块编译后的版本，格式为：module.version.pyc。通常会包含python的版本号。例如，在CPython3.3版本下，spam.py模块会被缓存成pycache/spam.cpython-33.pyc。这种命名规范保证了编译后的结果多版本共存。 Python检查源文件的修改时间与编译的版本进行对比，如果过期就需要重新编译。这是完全自动的过程。并且编译的模块是平台独立的，所以相同的库可以在不同的架构的系统之间共享，即pyc使一种跨平台的字节码，类似于JAVA火.NET,是由python虚拟机来执行的，但是pyc的内容跟python的版本相关，不同的版本编译后的pyc文件不同，2.5编译的pyc文件不能到3.5上执行，并且pyc文件是可以反编译的，因而它的出现仅仅是用来提升模块的加载速度的，不是用来加密的。 python解释器在以下两种情况下不检测缓存1 如果是在命令行中被直接导入模块，则按照这种方式，每次导入都会重新编译，并且不会存储编译后的结果（python3.3以前的版本应该是这样） 1python -m spam.py 2 如果源文件不存在，那么缓存的结果也不会被使用，如果想在没有源文件的情况下来使用编译后的结果，则编译后的结果必须在源目录下 123456sh-3.2# ls__pycache__ spam.pysh-3.2# rm -rf spam.py sh-3.2# mv __pycache__/spam.cpython-36.pyc ./spam.pycsh-3.2# python3 spam.pyc spam 提示：1.模块名区分大小写，foo.py与FOO.py代表的是两个模块2.你可以使用-O或者-OO转换python命令来减少编译模块的大小 -O转换会帮你去掉assert语句 -OO转换会帮你去掉assert语句和__doc__文档字符串 由于一些程序可能依赖于assert语句或文档字符串，你应该在在确认需要 的情况下使用这些选项。3.在速度上从.pyc文件中读指令来执行不会比从.py文件中读指令执行更快，只有在模块被加载时，.pyc文件才是更快的 4.只有使用import语句是才将文件自动编译为.pyc文件，在命令行或标准输入中指定运行脚本则不会生成这类文件，因而我们可以使用compieall模块为一个目录中的所有模块创建.pyc文件 模块可以作为一个脚本（使用python -m compileall）编译Python源python -m compileall /module_directory 递归着编译如果使用python -O -m compileall /module_directory -l则只一层 命令行里使用compile()函数时，自动使用python -O -m compileall 详见：https://docs.python.org/3/library/compileall.html#module-compileall]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python异常处理]]></title>
    <url>%2F2018%2F11%2F27%2Fpython%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[什么是异常异常就是程序运行时发生错误的信号（在程序出现错误时，则会产生一个异常，若程序没有处理它，则会抛出该异常，程序的运行也随之终止），在python中,错误触发的异常如下 而错误分成两种 1.语法错误（这种错误，根本过不了python解释器的语法检测，必须在程序执行前就改正） 2.逻辑错误 异常的种类 在python中不同的异常可以用不同的类型（python中统一了类与类型，类型即类）去标识，一个异常标识一种错误 常用异常AttributeError 试图访问一个对象没有的树形，比如foo.x，但是foo没有属性xIOError 输入/输出异常；基本上是无法打开文件ImportError 无法引入模块或包；基本上是路径问题或名称错误IndentationError 语法错误（的子类） ；代码没有正确对齐IndexError 下标索引超出序列边界，比如当x只有三个元素，却试图访问x[5]KeyError 试图访问字典里不存在的键KeyboardInterrupt Ctrl+C被按下NameError 使用一个还未被赋予对象的变量SyntaxError Python代码非法，代码不能编译(个人认为这是语法错误，写错了）TypeError 传入对象类型与要求的不符合UnboundLocalError 试图访问一个还未被设置的局部变量，基本上是由于另有一个同名的全局变量，导致你以为正在访问它 ValueError 传入一个调用者不期望的值，即使值的类型是正确的 更多异常ArithmeticErrorAssertionErrorAttributeErrorBaseExceptionBufferErrorBytesWarningDeprecationWarningEnvironmentErrorEOFErrorExceptionFloatingPointErrorFutureWarningGeneratorExitImportErrorImportWarningIndentationErrorIndexErrorIOErrorKeyboardInterruptKeyErrorLookupErrorMemoryErrorNameErrorNotImplementedErrorOSErrorOverflowErrorPendingDeprecationWarningReferenceErrorRuntimeErrorRuntimeWarningStandardErrorStopIterationSyntaxErrorSyntaxWarningSystemErrorSystemExitTabErrorTypeErrorUnboundLocalErrorUnicodeDecodeErrorUnicodeEncodeErrorUnicodeErrorUnicodeTranslateErrorUnicodeWarningUserWarningValueErrorWarningZeroDivisionError 异常处理为了保证程序的健壮性与容错性，即在遇到错误时程序不会崩溃，我们需要对异常进行处理， 如果错误发生的条件是可预知的，我们需要用if进行处理：在错误发生之前进行预防 12345678AGE=10while True: age=input('&gt;&gt;: ').strip() if age.isdigit(): #只有在age为字符串形式的整数时,下列代码才不会出错,该条件是可预知的 age=int(age) if age == AGE: print('you got it') break 如果错误发生的条件是不可预知的，则需要用到try…except：在错误发生之后进行处理 #基本语法为try: 被检测的代码块except 异常类型： try中一旦检测到异常，就执行这个位置的逻辑举例： 12345678910try: f=open('a.txt') g=(line.strip() for line in f) print(next(g)) print(next(g)) print(next(g)) print(next(g)) print(next(g))except StopIteration: f.close() 1 异常类只能用来处理指定的异常情况，如果非指定异常则无法处理 12345s1 = 'hello'try: int(s1)except IndexError as e: # 未捕获到异常，程序直接报错 print e 2 多分支 123456789s1 = 'hello'try: int(s1)except IndexError as e: print(e)except KeyError as e: print(e)except ValueError as e: print(e) 3 万能异常Exception 12345s1 = 'hello'try: int(s1)except Exception as e: print(e) 4 多分支异常与万能异常4.1 如果你想要的效果是，无论出现什么异常，我们统一丢弃，或者使用同一段代码逻辑去处理他们，那么骚年，大胆的去做吧，只有一个Exception就足够了。4.2 如果你想要的效果是，对于不同的异常我们需要定制不同的处理逻辑，那就需要用到多分支了。 5 也可以在多分支后来一个Exception 1234567891011s1 = 'hello'try: int(s1)except IndexError as e: print(e)except KeyError as e: print(e)except ValueError as e: print(e)except Exception as e: print(e) 6 异常的其他机构 123456789101112131415s1 = 'hello'try: int(s1)except IndexError as e: print(e)except KeyError as e: print(e)except ValueError as e: print(e)#except Exception as e:# print(e)else: print('try内代码块没有异常则执行我')finally: print('无论异常与否,都会执行该模块,通常是进行清理工作') 7 主动触发异常 1234try: raise TypeError('类型错误')except Exception as e: print(e) 8 自定义异常 12345678910class EgonException(BaseException): def __init__(self,msg): self.msg=msg def __str__(self): return self.msg try: raise EgonException('类型错误')except EgonException as e: print(e) 9 断言:assert 条件 12assert 1 == 1 assert 1 == 2 10 总结try..except 1：把错误处理和真正的工作分开来2：代码更易组织，更清晰，复杂的工作任务更容易实现；3：毫无疑问，更安全了，不至于由于一些小的疏忽而使程序意外崩溃了； 什么时候用异常处理有的同学会这么想，学完了异常处理后，好强大，我要为我的每一段程序都加上try…except，干毛线去思考它会不会有逻辑错误啊，这样就很好啊，多省脑细胞===》2B青年欢乐多 首先try…except是你附加给你的程序的一种异常处理的逻辑，与你的主要的工作是没有关系的，这种东西加的多了，会导致你的代码可读性变差 然后异常处理本就不是你2b逻辑的擦屁股纸，只有在错误发生的条件无法预知的情况下，才应该加上try…except]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python常用模块]]></title>
    <url>%2F2018%2F11%2F25%2Fpython%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[time模块时间表示形式在Python中，通常有这三种方式来表示时间：时间戳、元组(struct_time)、格式化的时间字符串：(1)时间戳(timestamp) ：通常来说，时间戳表示的是从1970年1月1日00:00:00开始按秒计算的偏移量。我们运行“type(time.time())”，返回的是float类型。 (2)格式化的时间字符串(Format String)： ‘1988-03-16’ (3)元组(struct_time) ：struct_time元组共有9个元素共九个元素:(年，月，日，时，分，秒，一年中第几周，一年中第几天等） 12345678910111213141516# &lt;1&gt; 时间戳 &gt;&gt;&gt; import time&gt;&gt;&gt; time.time() #--------------返回当前时间的时间戳1493136727.099066 # &lt;2&gt; 时间字符串&gt;&gt;&gt; time.strftime("%Y-%m-%d %X")'2017-04-26 00:32:18' # &lt;3&gt; 时间元组 &gt;&gt;&gt; time.localtime()time.struct_time(tm_year=2017, tm_mon=4, tm_mday=26, tm_hour=0, tm_min=32, tm_sec=42, tm_wday=2, tm_yday=116, tm_isdst=0) 小结：时间戳是计算机能够识别的时间；时间字符串是人能够看懂的时间；元组则是用来操作时间的 几种时间形式的转换(1) #一 时间戳&lt;－－－－&gt;结构化时间： localtime/gmtime mktime 1234time.localtime(3600*24)time.gmtime(3600*24)time.mktime(time.localtime()) #字符串时间&lt;－－－－&gt;结构化时间： strftime／strptime 12ime.strftime("%Y-%m-%d %X", time.localtime())time.strptime("2017-03-16","%Y-%m-%d") (2) 1234&gt;&gt;&gt;time.asctime(time.localtime(312343423))'Sun Nov 25 10:03:43 1979'&gt;&gt;&gt;time.ctime(312343423)'Sun Nov 25 10:03:43 1979' random模块123456789101112131415161718import random print(random.random())#(0,1)----float 大于0且小于1之间的小数 print(random.randint(1,3)) #[1,3] 大于等于1且小于等于3之间的整数 print(random.randrange(1,3)) #[1,3) 大于等于1且小于3之间的整数 print(random.choice([1,'23',[4,5]]))#1或者23或者[4,5]，choice()中只能放列表格式 print(random.sample([1,'23',[4,5]],2))#列表元素任意2个组合 print(random.uniform(1,3))#大于1小于3的小数，如1.927109612082716 item=[1,3,5,7,9]random.shuffle(item) #打乱item的顺序,相当于"洗牌"print(item) 实例：5位随机验证码 12345678910111213 import random def test(): s = "" for i in range(5): r1 = random.randint(0, 9) r2 = chr(random.randint(65, 90)) #ASCII表对应A-Z r3 = chr(random.randint(97, 122)) #ASCII表对应a-z r4 = random.choice([str(r1), r2, r3]) #三选一 s += r4 return s print(test()) hash模块1.什么叫hash:hash是一种算法,3.x里代替了md5模块和sha模块，主要提供 SHA1, SHA224, SHA256, SHA384, SHA512 ，MD5 算法，该算法接受传入的内容，经过运算得到一串hash值 2.hash值的特点是：1 只要传入的内容一样，得到的hash值必然一样=====&gt;要用明文传输密码文件完整性校验2 不能由hash值返解成内容=======》把密码做成hash值，不应该在网络传输明文密码 3 只要使用的hash算法不变，无论校验的内容有多大，得到的hash值长度是固定的 hash算法就像一座工厂，工厂接收你送来的原材料（可以用m.update()为工厂运送原材料），经过加工返回的产品就是hash值 12345678910111213141516171819import hashlib m=hashlib.md5()# m=hashlib.sha256() m.update('hello'.encode('utf8'))print(m.hexdigest()) #5d41402abc4b2a76b9719d911017c592 m.update('alvin'.encode('utf8')) print(m.hexdigest()) #92a7e713c30abbb0319fa07da2a5c4af m2=hashlib.md5()m2.update('helloalvin'.encode('utf8'))print(m2.hexdigest()) #92a7e713c30abbb0319fa07da2a5c4af '''注意：把一段很长的数据update多次，与一次update这段长数据，得到的结果一样但是update多次为校验大文件提供了可能。''' 以上加密算法虽然依然非常厉害，但时候存在缺陷，即：通过撞库可以反解。所以，有必要对加密算法中添加自定义key再来做加密。 12345import hashlib hash = hashlib.sha256('898oaFs09f'.encode('utf8'))hash.update('alvin'.encode('utf8'))print (hash.hexdigest())#e79e68f070cdedcfe63eaf1a2e92c83b4cfb1b5c6bc452d214c1b7e77cdfd1c7 模拟撞库破解密码 123456789101112131415161718192021222324import hashlibpasswds=[ 'alex3714', 'alex1313', 'alex94139413', 'alex123456', '123456alex', 'a123lex', ]def make_passwd_dic(passwds): dic=&#123;&#125; for passwd in passwds: m=hashlib.md5() m.update(passwd.encode('utf-8')) dic[passwd]=m.hexdigest() return dic def break_code(cryptograph,passwd_dic): for k,v in passwd_dic.items(): if v == cryptograph: print('密码是===&gt;\033[46m%s\033[0m' %k) cryptograph='aee949757a2e698417463d47acac93df'break_code(cryptograph,make_passwd_dic(passwds)) os模块123456789101112131415161718192021222324252627282930os.getcwd() #获取当前工作目录，即当前python脚本工作的目录路径os.chdir("dirname") #改变当前脚本工作目录；相当于shell下cdos.curdir #返回当前目录: ('.')os.pardir #获取当前目录的父目录字符串名：('..')os.makedirs('dirname1/dirname2') #可生成多层递归目录os.removedirs('dirname1') #若目录为空，则删除，并递归到上一级目录，如若也为空，则删除，依此类推os.mkdir('dirname') #生成单级目录；相当于shell中mkdir dirnameos.rmdir('dirname') #删除单级空目录，若目录不为空则无法删除，报错；相当于shell中rmdir dirnameos.listdir('dirname') #列出指定目录下的所有文件和子目录，包括隐藏文件，并以列表方式打印os.remove() #删除一个文件os.rename("oldname","newname") #重命名文件/目录os.stat('path/filename') #获取文件/目录信息os.sep #输出操作系统特定的路径分隔符，win下为"\\",Linux下为"/"os.linesep #输出当前平台使用的行终止符，win下为"\t\n",Linux下为"\n"os.pathsep #输出用于分割文件路径的字符串 win下为;,Linux下为:os.name #输出字符串指示当前使用平台。win-&gt;'nt'; Linux-&gt;'posix'os.system("bash command") #运行shell命令，直接显示os.environ #获取系统环境变量os.path.abspath(path) #返回path规范化的绝对路径os.path.split(path) #将path分割成目录和文件名二元组返回os.path.dirname(path) #返回path的目录。其实就是os.path.split(path)的第一个元素os.path.basename(path) #返回path最后的文件名。如何path以／或\结尾，那么就会返回空值。即os.path.split(path)的第二个元素os.path.exists(path) #如果path存在，返回True；如果path不存在，返回Falseos.path.isabs(path) #如果path是绝对路径，返回Trueos.path.isfile(path) #如果path是一个存在的文件，返回True。否则返回Falseos.path.isdir(path) #如果path是一个存在的目录，则返回True。否则返回Falseos.path.join(path1[, path2[, ...]]) #将多个路径组合后返回，第一个绝对路径之前的参数将被忽略os.path.getatime(path) #返回path所指向的文件或者目录的最后存取时间os.path.getmtime(path) #返回path所指向的文件或者目录的最后修改时间os.path.getsize(path) #返回path的大小 sys模块1234567sys.argv 命令行参数List，第一个元素是程序本身路径sys.exit(n) 退出程序，正常退出时exit(0)sys.version 获取Python解释程序的版本信息sys.maxint 最大的Int值sys.path 返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值sys.platform 返回操作系统平台名称 logging模块1 函数式简单配置123456import logging logging.debug('debug message') logging.info('info message') logging.warning('warning message') logging.error('error message') logging.critical('critical message') 默认情况下Python的logging模块将日志打印到了标准输出中，且只显示了大于等于WARNING级别的日志，这说明默认的日志级别设置为WARNING（日志级别等级CRITICAL &gt; ERROR &gt; WARNING &gt; INFO &gt; DEBUG），默认的日志格式为日志级别：Logger名称：用户输出消息。 灵活配置日志级别，日志格式，输出位置: 123456789101112import logging logging.basicConfig(level=logging.DEBUG, format='%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s', datefmt='%a, %d %b %Y %H:%M:%S', filename='/tmp/test.log', filemode='w') logging.debug('debug message') logging.info('info message') logging.warning('warning message') logging.error('error message') logging.critical('critical message') 配置参数： 12345678910111213141516171819202122232425logging.basicConfig()函数中可通过具体参数来更改logging模块默认行为，可用参数有： filename：用指定的文件名创建FiledHandler，这样日志会被存储在指定的文件中。filemode：文件打开方式，在指定了filename时使用这个参数，默认值为“a”还可指定为“w”。format：指定handler使用的日志显示格式。datefmt：指定日期时间格式。level：设置rootlogger（后边会讲解具体概念）的日志级别stream：用指定的stream创建StreamHandler。可以指定输出到sys.stderr,sys.stdout或者文件(f=open(‘test.log’,’w’))，默认为sys.stderr。若同时列出了filename和stream两个参数，则stream参数会被忽略。 format参数中可能用到的格式化串：%(name)s Logger的名字%(levelno)s 数字形式的日志级别%(levelname)s 文本形式的日志级别%(pathname)s 调用日志输出函数的模块的完整路径名，可能没有%(filename)s 调用日志输出函数的模块的文件名%(module)s 调用日志输出函数的模块名%(funcName)s 调用日志输出函数的函数名%(lineno)d 调用日志输出函数的语句所在的代码行%(created)f 当前时间，用UNIX标准的表示时间的浮 点数表示%(relativeCreated)d 输出日志信息时的，自Logger创建以 来的毫秒数%(asctime)s 字符串形式的当前时间。默认格式是 “2003-07-08 16:49:45,896”。逗号后面的是毫秒%(thread)d 线程ID。可能没有%(threadName)s 线程名。可能没有%(process)d 进程ID。可能没有%(message)s用户输出的消息 2 logger对象配置（推荐）123456789101112131415161718192021222324252627282930import logging def test(): # 1、创建一个logger log = logging.getLogger() log.setLevel(logging.DEBUG) # 2.创建一个handler，用于写入日志文件 file = logging.FileHandler("test.txt") file.setLevel(logging.DEBUG) # 再创建一个handler，用于输出到控制台 stream = logging.StreamHandler() stream.setLevel(logging.DEBUG) # 3.定义handler的输出格式（formatter） formatter = logging.Formatter("%(asctime)s - %(name)s - %(levelname)s - %(message)s") # 4.给handler添加formatter file.setFormatter(formatter) stream.setFormatter(formatter) # 5.给logger添加handler log.addHandler(file) # logger对象可以添加多个file和stream对象 log.addHandler(stream) return log l = test()l.debug("debug")l.info("info")l.warning("warning")l.error("error")l.critical("critical") ogging库提供了多个组件：Logger、Handler、Filter、Formatter。Logger对象提供应用程序可直接使用的接口，Handler发送日志到适当的目的地，Filter提供了过滤日志信息的方法，Formatter指定日志显示格式。另外，可以通过：logger.setLevel(logging.Debug)设置级别,当然，也可以通过 fh.setLevel(logging.Debug)单对文件流设置某个级别。 序列化模块什么是序列化？我们把对象(变量)从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling，在其他语言中也被称之为serialization，marshalling，flattening等等，都是一个意思。序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。 json模块如果我们要在不同的编程语言之间传递对象，就必须把对象序列化为标准格式，比如XML，但更好的方法是序列化为JSON，因为JSON表示出来就是一个字符串，可以被所有语言读取，也可以方便地存储到磁盘或者通过网络传输。JSON不仅是标准格式，并且比XML更快，而且可以直接在Web页面中读取，非常方便。 JSON表示的对象就是标准的JavaScript语言的对象一个子集，JSON和Python内置的数据类型对应如下： python在文本中的使用： 123456789101112131415161718192021import json dic=&#123;'name':'alvin','age':23,'sex':'male'&#125;print(type(dic))#&lt;class 'dict'&gt; data=json.dumps(dic)print("type",type(data))#&lt;class 'str'&gt;print("data",data) f=open('序列化对象','w')f.write(data) #-------------------等价于json.dump(dic,f)f.close() #-----------------------------反序列化&lt;br&gt;import jsonf=open('序列化对象')new_data=json.loads(f.read())# 等价于data=json.load(f) print(type(new_data)) pickle模块 12345678910111213141516171819202122##----------------------------序列化import pickle dic=&#123;'name':'alvin','age':23,'sex':'male'&#125; print(type(dic))#&lt;class 'dict'&gt; j=pickle.dumps(dic)print(type(j))#&lt;class 'bytes'&gt; f=open('序列化对象_pickle','wb')#注意是w是写入str,wb是写入bytes,j是'bytes'f.write(j) #-------------------等价于pickle.dump(dic,f) f.close()#-------------------------反序列化import picklef=open('序列化对象_pickle','rb') data=pickle.loads(f.read())# 等价于data=pickle.load(f) print(data['age']) Pickle的问题和所有其他编程语言特有的序列化问题一样，就是它只能用于Python，并且可能不同版本的Python彼此都不兼容，因此，只能用Pickle保存那些不重要的数据，不能成功地反序列化也没关系 shelve模块shelve模块比pickle模块简单，只有一个open函数，返回类似字典的对象，可读可写;key必须为字符串，而值可以是python所支持的数据类型 123456789import shelve f=shelve.open(r'sheve.txt')# f['stu1_info']=&#123;'name':'egon','age':18,'hobby':['piao','smoking','drinking']&#125;# f['stu2_info']=&#123;'name':'gangdan','age':53&#125;# f['school_info']=&#123;'website':'http://www.pypy.org','city':'beijing'&#125; print(f['stu1_info']['hobby'])f.close() re模块一：什么是正则？ 正则就是用一些具有特殊含义的符号组合到一起（称为正则表达式）来描述字符或者字符串的方法。或者说：正则就是用来描述一类事物的规则。（在Python中）它内嵌在Python中，并通过 re 模块实现。正则表达式模式被编译成一系列的字节码，然后由用 C 编写的匹配引擎执行。 生活中处处都是正则： 比如我们描述：4条腿 你可能会想到的是四条腿的动物或者桌子，椅子等 继续描述：4条腿，活的 就只剩下四条腿的动物这一类了 二：常用匹配模式(元字符) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091# =================================匹配模式=================================#一对一的匹配# 'hello'.replace(old,new)# 'hello'.find('pattern') #正则匹配import re#\w与\Wprint(re.findall('\w','hello egon 123')) #['h', 'e', 'l', 'l', 'o', 'e', 'g', 'o', 'n', '1', '2', '3']print(re.findall('\W','hello egon 123')) #[' ', ' '] #\s与\Sprint(re.findall('\s','hello egon 123')) #[' ', ' ', ' ', ' ']print(re.findall('\S','hello egon 123')) #['h', 'e', 'l', 'l', 'o', 'e', 'g', 'o', 'n', '1', '2', '3'] #\n \t都是空,都可以被\s匹配print(re.findall('\s','hello \n egon \t 123')) #[' ', '\n', ' ', ' ', '\t', ' '] #\n与\tprint(re.findall(r'\n','hello egon \n123')) #['\n']print(re.findall(r'\t','hello egon\t123')) #['\n'] #\d与\Dprint(re.findall('\d','hello egon 123')) #['1', '2', '3']print(re.findall('\D','hello egon 123')) #['h', 'e', 'l', 'l', 'o', ' ', 'e', 'g', 'o', 'n', ' '] #\A与\Zprint(re.findall('\Ahe','hello egon 123')) #['he'],\A==&gt;^print(re.findall('123\Z','hello egon 123')) #['he'],\Z==&gt;$ #^与$print(re.findall('^h','hello egon 123')) #['h']print(re.findall('3$','hello egon 123')) #['3'] # 重复匹配：| . | * | ? | .* | .*? | + | &#123;n,m&#125; |#.print(re.findall('a.b','a1b')) #['a1b']print(re.findall('a.b','a1b a*b a b aaab')) #['a1b', 'a*b', 'a b', 'aab']print(re.findall('a.b','a\nb')) #[]print(re.findall('a.b','a\nb',re.S)) #['a\nb']print(re.findall('a.b','a\nb',re.DOTALL)) #['a\nb']同上一条意思一样 #*print(re.findall('ab*','bbbbbbb')) #[]print(re.findall('ab*','a')) #['a']print(re.findall('ab*','abbbb')) #['abbbb'] #?print(re.findall('ab?','a')) #['a']print(re.findall('ab?','abbb')) #['ab']#匹配所有包含小数在内的数字print(re.findall('\d+\.?\d*',"asdfasdf123as1.13dfa12adsf1asdf3")) #['123', '1.13', '12', '1', '3'] #.*默认为贪婪匹配print(re.findall('a.*b','a1b22222222b')) #['a1b22222222b'] #.*?为非贪婪匹配：推荐使用print(re.findall('a.*?b','a1b22222222b')) #['a1b'] #+print(re.findall('ab+','a')) #[]print(re.findall('ab+','abbb')) #['abbb'] #&#123;n,m&#125;print(re.findall('ab&#123;2&#125;','abbb')) #['abb']print(re.findall('ab&#123;2,4&#125;','abbb')) #['abb']print(re.findall('ab&#123;1,&#125;','abbb')) #'ab&#123;1,&#125;' ===&gt; 'ab+'print(re.findall('ab&#123;0,&#125;','abbb')) #'ab&#123;0,&#125;' ===&gt; 'ab*' #[]print(re.findall('a[1*-]b','a1b a*b a-b')) #[]内的都为普通字符了，且如果-没有被转意的话，应该放到[]的开头或结尾print(re.findall('a[^1*-]b','a1b a*b a-b a=b')) #[]内的^代表的意思是取反，所以结果为['a=b']print(re.findall('a[0-9]b','a1b a*b a-b a=b')) # 结果为['a1b']print(re.findall('a[a-z]b','a1b a*b a-b a=b aeb')) # 结果为['aeb']print(re.findall('a[a-zA-Z]b','a1b a*b a-b a=b aeb aEb')) # 结果为['aeb','aEb'] #\# print(re.findall('a\\c','a\c')) #对于正则来说a\\c确实可以匹配到a\c,但是在python解释器读取a\\c时，会发生转义，然后交给re去执行，所以抛出异常print(re.findall(r'a\\c','a\c')) #r代表告诉解释器使用rawstring，即原生字符串，把我们正则内的所有符号都当普通字符处理，不要转义print(re.findall('a\\\\c','a\c')) #同上面的意思一样，和上面的结果一样都是['a\\c'] #():分组print(re.findall('ab+','ababab123')) #['ab', 'ab', 'ab']print(re.findall('(ab)+123','ababab123')) #['ab']，匹配到末尾的ab123中的abprint(re.findall('(?:ab)+123','ababab123')) #findall的结果不是匹配的全部内容，而是组内的内容,?:可以让结果为匹配的全部内容print(re.findall('href="(.*?)"','&lt;a href="http://www.baidu.com"&gt;点击&lt;/a&gt;'))#['http://www.baidu.com']print(re.findall('href="(?:.*?)"','&lt;a href="http://www.baidu.com"&gt;点击&lt;/a&gt;'))#['href="http://www.baidu.com"']# 给分组加上名字，可以用名字来取组值s = re.search('(?P&lt;w&gt;\w+)\.(?P&lt;fuck&gt;\w+)\.(?P&lt;com&gt;\w+)', 'www.buleone.com')print(s.group('fuck'))#|print(re.findall('compan(?:y|ies)','Too many companies have gone bankrupt, and the next one is my company')) re模块提供的方法介绍 1234567891011121314151617181920212223242526import re#1print(re.findall('e','alex make love') ) #['e', 'e', 'e'],返回所有满足匹配条件的结果,放在列表里#2print(re.search('e','alex make love').group()) #e,只到找到第一个匹配然后返回一个包含匹配信息的对象,该对象可以通过调用group()方法得到匹配的字符串,如果字符串没有匹配，则返回None。 #3print(re.match('e','alex make love')) #None,同search,不过在字符串开始处进行匹配,完全可以用search+^代替match #4print(re.split('[ab]','abcd')) #['', '', 'cd']，先按'a'分割得到''和'bcd',再对''和'bcd'分别按'b'分割 #5print('===&gt;',re.sub('a','A','alex make love')) #===&gt; Alex mAke love，不指定n，默认替换所有print('===&gt;',re.sub('a','A','alex make love',1)) #===&gt; Alex make loveprint('===&gt;',re.sub('a','A','alex make love',2)) #===&gt; Alex mAke loveprint('===&gt;',re.sub('^(\w+)(.*?\s)(\w+)(.*?\s)(\w+)(.*?)$',r'\5\2\3\4\1','alex make love')) #===&gt; love make alex print('===&gt;',re.subn('a','A','alex make love')) #===&gt; ('Alex mAke love', 2),结果带有总共替换的个数 #6obj=re.compile('\d&#123;2&#125;') print(obj.search('abc123eeee').group()) #12print(obj.findall('abc123eeee')) #['12'],重用了obj]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>常用模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python面向对象高级]]></title>
    <url>%2F2018%2F11%2F23%2Fpython%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[isinstance(obj,cls)和issubclass(sub,super)isinstance(obj,cls)检查是否obj是否是类 cls 的对象12345class Foo(object): pass obj = Foo() isinstance(obj, Foo) issubclass(sub, super)检查sub类是否是 super 类的派生类1234567class Foo(object): pass class Bar(Foo): pass issubclass(Bar, Foo) 反射1 什么是反射反射的概念是由Smith在1982年首次提出的，主要是指程序可以访问、检测和修改它本身状态或行为的一种能力（自省）。这一概念的提出很快引发了计算机科学领域关于应用反射性的研究。它首先被程序语言的设计领域所采用,并在Lisp和面向对象方面取得了成绩。 2 python面向对象中的反射通过字符串的形式操作对象相关的属性。python中的一切事物都是对象（都可以使用反射） 四个可以实现自省的函数 下列方法适用于类和对象（一切皆对象，类本身也是一个对象） hasattr(object,name) 判断object中有没有一个name字符串对应的方法或属性 getattr(object, name, default=None) 1234567class People: def walk(self): print("fuck u walk") p = People()x = getattr(p, 'walk')x() setattr(x, y, v) 1234567class People: def walk(self): print("fuck u walk") p = People()setattr(p, 'age', 18) #设置age的值为18，没有这个属性则会创建print(p.age) delattr(x, y) 1234567class People: age = 18 def walk(self): print("fuck u walk") p = People()delattr(p, 'age') 反射当前模块成员 123456789101112import sys def s1(): print 's1' def s2(): print 's2' this_module = sys.modules[__name__] hasattr(this_module, 's1')getattr(this_module, 's2') 3 为什么用反射之反射的好处好处一：实现可插拔机制 有俩程序员，一个lili，一个是egon，lili在写程序的时候需要用到egon所写的类，但是egon去跟女朋友度蜜月去了，还没有完成他写的类，lili想到了反射，使用了反射机制lili可以继续完成自己的代码，等egon度蜜月回来后再继续完成类的定义并且去实现lili想要的功能。 总之反射的好处就是，可以事先定义好接口，接口只有在被完成后才会真正执行，这实现了即插即用，这其实是一种‘后期绑定’，什么意思？即你可以事先把主要的逻辑写好（只定义接口），然后后期再去实现接口的功能 12345class FtpClient: 'ftp客户端,但是还么有实现具体的功能' def __init__(self,addr): print('正在连接服务器[%s]' %addr) self.addr=addr 不影响lili的代码编写 12345678#from module import FtpClientf1=FtpClient('192.168.1.1')if hasattr(f1,'get'): func_get=getattr(f1,'get') func_get()else: print('----&gt;不存在此方法') print('处理其他的逻辑') 好处二：动态导入模块（基于反射当前模块成员） __setattr__,__delattr__,__getattr__三者的用法演示 1234567891011121314151617181920212223242526272829303132class Foo: x=1 def __init__(self,y): self.y=y def __getattr__(self, item): print('----&gt; from getattr:你找的属性不存在') def __setattr__(self, key, value): print('----&gt; from setattr') # self.key=value #这就无限递归了,你好好想想 # self.__dict__[key]=value #应该使用它 def __delattr__(self, item): print('----&gt; from delattr') # del self.item #无限递归了 self.__dict__.pop(item) #__setattr__添加/修改属性会触发它的执行f1=Foo(10)print(f1.__dict__) # 因为你重写了__setattr__,凡是赋值操作都会触发它的运行,你啥都没写,就是根本没赋值,除非你直接操作属性字典,否则永远无法赋值f1.z=3print(f1.__dict__) #__delattr__删除属性的时候会触发f1.__dict__['a']=3#我们可以直接修改属性字典,来完成添加/修改属性的操作del f1.aprint(f1.__dict__) #__getattr__只有在使用点调用属性且属性不存在的时候才会触发f1.xxxxxx 二次加工标准类型(包装)包装：python为大家提供了标准数据类型，以及丰富的内置方法，其实在很多场景下我们都需要基于标准数据类型来定制我们自己的数据类型，新增/改写方法，这就用到了我们刚学的继承/派生知识（其他的标准类型均可以通过下面的方式进行二次加工） 1234567891011121314151617181920212223242526class List(list): #继承list所有的属性，也可以派生出自己新的，比如append和mid def append(self, p_object): ' 派生自己的append：加上类型检查' if not isinstance(p_object,int): raise TypeError('must be int') super().append(p_object) @property def mid(self): '新增自己的属性' index=len(self)//2 return self[index] l=List([1,2,3,4])print(l)l.append(5)print(l)# l.append('1111111') #报错，必须为int类型 print(l.mid) #其余的方法都继承list的l.insert(0,-123)print(l)l.clear()print(l) 练习（clear加权限限制） 123456789101112131415161718192021222324class List(list): def __init__(self,item,tag=False): super().__init__(item) self.tag=tag def append(self, p_object): if not isinstance(p_object,str): raise TypeError super().append(p_object) def clear(self): if not self.tag: raise PermissionError super().clear() l=List([1,2,3],False)print(l)print(l.tag) l.append('saf')print(l) # l.clear() #异常 l.tag=Truel.clear() 授权：授权是包装的一个特性, 包装一个类型通常是对已存在的类型的一些定制,这种做法可以新建,修改或删除原有产品的功能。其它的则保持原样。授权的过程,即是所有更新的功能都是由新类的某部分来处理,但已存在的功能就授权给对象的默认属性。 实现授权的关键点就是覆盖__getattr__方法 例：利用open()函数重新定制一个文件处理器，增加写内容添加时间的功能； 1234567891011121314151617181920import time class FileHandler: def __init__(self,filename,mode='r',encoding="utf-8"): self.file = open(filename,mode,encoding=encoding) #self.file获取到一个文件句柄 def write(self,line): t = time.strftime("%Y-%m-%d %X") self.file.write("%s %s"%(t,line)) def __getattr__(self, item): return getattr(self.file,item) #当对象调用FileHandler类不存在的方法时，会返回open()函数的item字符串对应的方法； f1 = FileHandler("a.txt","r+")f1.write("你好吗\n")f1.seek(0)print(f1.tell()) __setitem__,__getitem,__delitem__把对象操作属性模拟成字典的形式 1234567891011121314151617181920212223class Foo: def __init__(self,name): self.name=name def __getitem__(self, item): print(self.__dict__[item]) def __setitem__(self, key, value): self.__dict__[key]=value def __delitem__(self, key): print('del obj[key]时,我执行') self.__dict__.pop(key) def __delattr__(self, item): print('del obj.key时,我执行') self.__dict__.pop(item) f1=Foo('sb')f1['age']=18f1['age1']=19del f1.age1del f1['age']f1['name']='alex'print(f1.__dict__) __str__当使用print输出对象的时候，只要自己定义了__str__(self)方法，那么就会打印从在这个方法中return的数据 12345678910class People: def __init__(self, name): self.name = name def __str__(self): return 'your name is %s' % self.name p = People('sb')print(p) 结果为 1your name is sb __slots__1234567891.__slots__是什么:是一个类变量,变量值可以是列表,元祖,或者可迭代对象,也可以是一个字符串(意味着所有实例只有一个数据属性)2.引子:使用点来访问属性本质就是在访问类或者对象的__dict__属性字典(类的字典是共享的,而每个实例的是独立的)3.为何使用__slots__:字典会占用大量内存,如果你有一个属性很少的类,但是有很多实例,为了节省内存可以使用__slots__取代实例的__dict__当你定义__slots__后,__slots__就会为实例使用一种更加紧凑的内部表示。实例通过一个很小的固定大小的数组来构建,而不是为每个实例定义一个字典,这跟元组或列表很类似。在__slots__中列出的属性名在内部被映射到这个数组的指定小标上。使用__slots__一个不好的地方就是我们不能再给实例添加新的属性了,只能使用在__slots__中定义的那些属性名。4.注意事项:__slots__的很多特性都依赖于普通的基于字典的实现。另外,定义了__slots__后的类不再 支持一些普通类特性了,比如多继承。大多数情况下,你应该只在那些经常被使用到 的用作数据结构的类上定义__slots__比如在程序中需要创建某个类的几百万个实例对象 。关于__slots__的一个常见误区是它可以作为一个封装工具来防止用户给实例增加新的属性。尽管使用__slots__可以达到这样的目的,但是这个并不是它的初衷。 更多的是用来作为一个内存优化工具。 123456789101112131415class Foo: __slots__='x' f1=Foo()f1.x=1f1.y=2#报错print(f1.__slots__) #f1不再有__dict__ class Bar: __slots__=['x','y'] n=Bar()n.x,n.y=1,2n.z=3#报错 __next__和__iter__实现迭代器协议模仿range的功能 12345678910111213141516171819class My_range: def __init__(self, start, end): self.start = start self.end = end def __iter__(self): return self def __next__(self): if self.start == self.end: raise StopIteration n = self.start self.start += 1 return n s = My_range(1, 20)for i in s: print(i) __doc__123456789class Foo: '我是描述信息' pass class Bar(Foo): passprint(Bar.__doc__) #该属性无法继承给子类 该属性无法被继承 __module__和__class__123__module__ 表示当前操作的对象在那个模块__class__ 表示当前操作的对象的类是什么 __del__析构方法，当对象在内存中被释放时，自动触发执行。 注：如果产生的对象仅仅只是python程序级别的（用户级），那么无需定义del,如果产生的对象的同时还会向操作系统发起系统调用，即一个对象有用户级与内核级两种资源，比如（打开一个文件，创建一个数据库链接），则必须在清除对象的同时回收系统资源，这就用到了__del__ 123456789101112class Foo: def __del__(self): print('执行我啦') f1=Foo()del f1print('-------&gt;') #输出结果执行我啦-------&gt; 典型的应用场景： 创建数据库类，用该类实例化出数据库链接对象，对象本身是存放于用户空间内存中，而链接则是由操作系统管理的，存放于内核空间内存中 当程序结束时，python只会回收自己的内存空间，即用户态内存，而操作系统的资源则没有被回收，这就需要我们定制__del__，在对象被删除前向操作系统发起关闭数据库链接的系统调用，回收资源 __enter__和__exit__我们知道在操作文件对象的时候可以这么写 12with open('a.txt') as f: '代码块' 上述叫做上下文管理协议，即with语句，为了让一个对象兼容with语句，必须在这个对象的类中声明__enter__和__exit__方法 1234567891011121314class Open: def __init__(self,name): self.name=name def __enter__(self): print('出现with语句,对象的__enter__被触发,有返回值则赋值给as声明的变量') # return self def __exit__(self, exc_type, exc_val, exc_tb): print('with中代码块执行完毕时执行我啊') with Open('a.txt') as f: print('=====&gt;执行代码块') # print(f,f.name) __exit__()中的三个参数分别代表异常类型，异常值和追溯信息,with语句中代码块出现异常，则with后的代码都无法执行 12345678910111213141516171819class Open: def __init__(self,name): self.name=name def __enter__(self): print('出现with语句,对象的__enter__被触发,有返回值则赋值给as声明的变量') def __exit__(self, exc_type, exc_val, exc_tb): print('with中代码块执行完毕时执行我啊') print(exc_type) print(exc_val) print(exc_tb) with Open('a.txt') as f: print('=====&gt;执行代码块') raise AttributeError('***着火啦,救火啊***')print('0'*100) #-------------------------------&gt;不会执行 如果__exit()返回值为True,那么异常会被清空，就好像啥都没发生一样，with后的语句正常执行 实例： 1234567891011121314151617181920212223242526import time class Open: def __init__(self, file, m='r', en='utf-8'): self.file = file self.m = m self.en = en self.x = open(file, mode=m, encoding=en) def __enter__(self): return self def __exit__(self, exc_type, exc_val, exc_tb): self.x.close() def __getattr__(self, item): return getattr(self.x, item) def write(self, content): t = time.strftime("%Y-%m-%d-%X") self.x.write('%s %s' % (t, content)) with Open('b.txt') as f: print(f.read()) 用途或者说好处： 1.使用with语句的目的就是把代码块放入with中执行，with结束后，自动完成清理工作，无须手动干预 2.在需要管理一些资源比如文件，网络连接和锁的编程环境中，可以在exit中定制自动释放资源的机制，你无须再去关系这个问题，这将大有用处 __call__对象后面加括号，触发执行。 注：构造方法的执行是由创建对象触发的，即：对象 = 类名() ；而对于 call 方法的执行是由对象后加括号触发的，即：对象() 或者 类()() 123456789101112class Foo: def __init__(self): pass def __call__(self, *args, **kwargs): print('__call__') obj = Foo() # 执行 __init__obj() # 执行 __call__]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python面向对象之绑定方法与非绑定方法]]></title>
    <url>%2F2018%2F11%2F22%2Fpython%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E7%BB%91%E5%AE%9A%E6%96%B9%E6%B3%95%E4%B8%8E%E9%9D%9E%E7%BB%91%E5%AE%9A%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[类中定义的函数分成两大类一：绑定方法绑定给谁，谁来调用就自动将它本身当作第一个参数传入 1.绑定到类的方法：用classmethod装饰器装饰的方法。 为类量身定制 类.boud_method(),自动将类当作第一个参数传入 (其实对象也可调用，但仍将类当作第一个参数传入) 2.绑定到对象的方法：没有被任何装饰器装饰的方法。 为对象量身定制 对象.boud_method(),自动将对象当作第一个参数传入 (属于类的函数，类可以调用，但是必须按照函数的规则来，没有自动传值那么一说) 二：非绑定方法用staticmethod装饰器装饰的方法 1.不与类或对象绑定，类和对象都可以调用，但是没有自动传值那么一说。就是一个普通工具而已 注意：与绑定到对象方法区分开，在类中直接定义的函数，没有被任何装饰器装饰的，都是绑定到对象的方法，可不是普通函数，对象调用该方法会自动传值，而staticmethod装饰的方法，不管谁来调用，都没有自动传值一说 绑定方法绑定给对象的方法首先我们明确一个知识点，凡是类中的方法或函数，默认情况下都是绑定给对象使用的。下面，我们通过实例，来慢慢解析绑定方法的应用。 123456789101112class People: def __init__(self,name,age): self.name = name self.age = age def talk(self): pass p = People('xiaohua',18)print(p.talk)输出结果：&lt;bound method People.talk of &lt;__main__.People object at 0x000000F802C69358&gt;&gt; 从上面的输出结果来看，talk()這个类中的方法，是绑定给对象使用的。下面，我在看看另外一种情况。 123456789101112class People: def __init__(self,name,age): self.name = name self.age = age def talk(): passp = People('xiaohua',18)print(p.talk)输出结果：&lt;bound method People.talk of &lt;__main__.People object at 0x000000FF68F39358&gt;&gt; 现在，我们将talk()函数的参数去掉，结果显示与上面是一样。这说明，不管是类中的方法，还是类中函数，默认情况下都是绑定给对象使用的。绑定给对象使用有一种好处，那就是不用手动将对象传入。对象是自动传到类中。如果你不信，我们来看看下面的例子： 1234567891011121314class People: def __init__(self,name,age): self.name = name self.age = age def talk(): passp = People('xiaohua',18)print(People.talk)print(p.talk)输出结果：&lt;function People.talk at 0x000000C54E3D0A60&gt; 类来调用仅仅是当作函数使用&lt;bound method People.talk of &lt;__main__.People object at 0x000000C54E249358&gt;&gt; 而对象来调用则为绑定方法 上面很好说明了，如果类来调用类中的方法，那么这个方法仅仅只是一个函数，那么既然是函数，就不会有自动传值这一功能。来看看下面代码： 1234567891011121314class People: def __init__(self,name,age): self.name = name self.age = age def talk(self): passp = People('xiaohua',18)People.talk() 1p.talk() 2#代码1处报错talk() missing 1 required positional argument: 'self'#代码2处正常 从上面输出结果来看，当类调用类中的方法时候，是不会进行自动传值的，也就是说，函数有几个参数，我们就得传递进去几个参数。如果想结果正常运行，那么在类名调用talk()的时候，将参数一一都传递进去。即： 1People.talk(312312) 這个参数可以是任意的，但是，必须传递进去。而，当对象调用类中方法时候，则不用传递，如上面的2正常执行。既然知道了区别，那么，我们来看看下面代码： 1234567891011121314class People: def __init__(self,name,age): self.name = name self.age = age def talk(): passp = People('xiaohua',18)People.talk() 1p.talk() 2# 1处正常执行# 2 处报错talk() takes 0 positional arguments but 1 was given 从输出结果来看，People来调用talk()方法时候，并不需要传递参数；而当对象来调用talk()的时候，由于对象调用自己的绑定方法，会自动将对象当作第一个参数传递进去，所以，当类中talk()方法没有带参数时，而你又给它传递了一个，显然是会报错的。 综上所述，我们可以得出以下结论： 1.凡是类中的方法和函数，都是绑定给对象使用的； 2.绑定方法都有自动传值的功能。传递进去的值，就是对象本身。 3.如果类想调用绑定方法，就必须遵循函数的参数规则，有几个参数，就必须传递几个参数。 绑定给类的方法（classmethod）classmehtod是给类用的，即绑定到类，类在使用时会将类本身当做参数传给类方法的第一个参数（即便是对象来调用也会将类当作第一个参数传入），python为我们内置了函数classmethod来把类中的函数定义成类方法 123456789101112131415import settingsclass MySQL: def __init__(self,host,port): self.host=host self.port=port @classmethod def from_conf(cls): print(cls) return cls(settings.HOST,settings.PORT) print(MySQL.from_conf) #&lt;bound method MySQL.from_conf of &lt;class '__main__.MySQL'&gt;&gt;conn=MySQL.from_conf() conn.from_conf() #对象也可以调用，但是默认传的第一个参数仍然是类 非绑定方法在类内部用staticmethod装饰的函数即非绑定方法，就是普通函数 statimethod不与类或对象绑定，谁都可以调用，没有自动传值效果 123456789101112131415161718import hashlibimport timeclass MySQL: def __init__(self,host,port): self.id=self.create_id() self.host=host self.port=port @staticmethod def create_id(): #就是一个普通工具 m=hashlib.md5(str(time.time()).encode('utf-8')) return m.hexdigest() print(MySQL.create_id) #&lt;function MySQL.create_id at 0x0000000001E6B9D8&gt; #查看结果为普通函数conn=MySQL('127.0.0.1',3306)print(conn.create_id) #&lt;function MySQL.create_id at 0x00000000026FB9D8&gt; #查看结果为普通函数 classmethod与staticmethod的区别12345678910111213141516171819202122232425import settingsclass MySQL: def __init__(self,host,port): self.host=host self.port=port @staticmethod def from_conf(): return MySQL(settings.HOST,settings.PORT) # @classmethod #哪个类来调用,就将哪个类当做第一个参数传入 # def from_conf(cls): # return cls(settings.HOST,settings.PORT) def __str__(self): return '就不告诉你' class Mariadb(MySQL): def __str__(self): return '&lt;%s:%s&gt;' %(self.host,self.port) m=Mariadb.from_conf()print(m) #我们的意图是想触发Mariadb.__str__,但是结果触发了MySQL.__str__的执行，打印就不告诉你：]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>绑定方法</tag>
        <tag>非绑定方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python封装与property]]></title>
    <url>%2F2018%2F11%2F22%2Fpython%E5%B0%81%E8%A3%85%E4%B8%8Eproperty%2F</url>
    <content type="text"><![CDATA[封装封装可以理解为一个多功能的自助饮料机器，且机器是不透明密封的，只在下方开了不同的龙头，当顾客需要不同的饮料时，只需要去打开不同的龙头开关即可得到自己想要的饮料，但顾客不知道机器内部是产生不同的饮料的。在python中，封装可以是类，可以是函数。封装是将数据或属性隐藏在内部，不让外部看到。 在python中用双下划线开头的方式将属性隐藏起来（设置成私有的） 1234567891011121314#其实这仅仅这是一种变形操作且仅仅只在类定义阶段发生变形#类中所有双下划线开头的名称如__x都会在类定义时自动变形成：_类名__x的形式： class A: __N=0 #类的数据属性就应该是共享的,但是语法上是可以把类的数据属性设置成私有的如__N,会变形为_A__N def __init__(self): self.__X=10 #变形为self._A__X def __foo(self): #变形为_A__foo print('from A') def bar(self): self.__foo() #只有在类内部才可以通过__foo的形式访问到. #A._A__N是可以访问到的，#这种，在外部是无法通过__x这个名字访问到 这种变形需要注意的问题是： 1.这种机制也并没有真正意义上限制我们从外部直接访问属性，知道了类名和属性名就可以拼出名字：_类名__属性，然后就可以访问了，如a._A__N，即这种操作并不是严格意义上的限制外部访问，仅仅只是一种语法意义上的变形，主要用来限制外部的直接访问。 2.变形的过程只在类的定义时发生一次,在定义后的赋值操作，不会变形 3.在继承中，父类如果不想让子类覆盖自己的方法，可以将方法定义为私有的 例： 123456789101112class A: def fa(self): print('from A') def test(self): self.fa() class B(A): def fa(self): print('from B') b=B()b.test() 输出：form B 12345678910111213#把fa定义成私有的，即__faclass A: def __fa(self): #在定义时就变形为_A__fa print('from A') def test(self): self.__fa() #只会与自己所在的类为准,即调用_A__fa class B(A): def __fa(self): print('from B') b=B()b.test() 输出：form A 封装的真谛在于明确地区分内外，封装的属性可以直接在内部使用，而不能被外部直接使用，然而定义属性的目的终归是要用，外部要想用类隐藏的属性，需要我们为其开辟接口，让外部能够间接地用到我们隐藏起来的属性，那这么做的意义何在？？？ 1：封装数据：将数据隐藏起来这不是目的。隐藏起来然后对外提供操作该数据的接口，然后我们可以在接口附加上对该数据操作的限制，以此完成对数据属性操作的严格控制。 2：封装方法：目的是隔离复杂度 3: 了解 python并不会真的阻止你访问私有的属性，模块也遵循这种约定，如果模块名以单下划线开头，那么from module import *时不能被导入,但是你from module import _private_module依然是可以导入的 特性(property)什么是特性propertyproperty是一种特殊的属性，访问它时会执行一段功能（函数）然后返回值 1234567891011class People: def __init__(self,name,weight,height): self.name=name self.weight=weight self.height=height @property def bmi(self): return self.weight / (self.height**2) p1=People('egon',75,1.85)print(p1.bmi) 为什么要用property将一个类的函数定义成特性以后，对象再去使用的时候p1.bmi,根本无法察觉自己的bmi是执行了一个函数然后计算出来的，这种特性的使用方式遵循了统一访问的原则 被property装饰的属性会 优先于对象的属性被使用 而被property装饰的属性，如sex，分成三种： 1.property 2.sex.setter 3.sex.deleter 1234567891011121314151617181920212223242526class People: def __init__(self, name, sex): self.name = name self.sex = sex @property def sex(self): return self.__sex @sex.setter def sex(self, sex1): if not isinstance(sex1, int): raise TypeError('必须是数字') self.__sex = sex1 @sex.deleter def sex(self): del self.__sex p = People('ezc', 20)print(p.sex)p.sex = 15print(p.sex)del p.sexprint(p.sex) 在创建对象时self.sex会先去找有没有property，如果有会先去调用其下面的，所以self.__sex = sex1，实际上真正的值存在了__sex中，可以通过p._dict_查看，查询时也是，会先去寻找被property装饰的属性，修改和删除也同理]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>封装</tag>
        <tag>property</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python类]]></title>
    <url>%2F2018%2F11%2F22%2Fpython%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[创建和使用12345678class Dog(): def __init__(self,name,age): self.name=name; self.age=age; def sit(self): print(self.name.title()+" is now sitting") def roll_over(self): print(self.name.title()+" rolled over!") 方法__init__()是一个特殊的方法，相当于构造方法，每当创建新实例时，Python都会自动运行它__init__中的形参self必不可少，还必须位于其他形参的前面。创建实例时不用给self传递值后面的两个方法由于不需要额外的信息，因此只有一个形参self，变量都有前缀self，以self为前缀的变量可供类中的所有方法使用。self.name=name获取存储在形参name中的值，并将其存储到变量name中，然后该变量被关联到当前创建的实例。 根据类创建实例my_dog=Dog(‘stupy’,3)这里使用上面的Dog类创建了一个名为‘stupy’、年龄为3的my_dog实例访问属性my_dog.name获取名字，my_dog.age获取年龄 调用方法my_dog.sit() my_dog.roll_over() 给属性指定默认值比如上例默认为公狗，则在init()函数中创建一个性别属性并设置初始值，self.sex=’gong’ 修改属性的值1.直接修改属性的值接上例，使用句点表示法来直接访问并设置小狗的属性name。my_dog.name=’clever’ 2.通过方法修改属性的值相当于java中的set方法例： 123def update_name(self,newname): self.name=newnamemy_dog.update_name('wuwu') 这样就无需直接访问属性，而可以将值传递给一个方法，由它在内部进行更新 继承如下例： 1234567891011121314151617181920212223class Car(): def __init__(self, make, model, year): self.make = make self.model = model self.year = year self.odometer_reading = 0 def get_descriptive_name(self): long_name = str(self.year) + ' ' + self.make + ' ' + self.model return long_name.title() def read_odometer(self): print("This car has " + str(self.odometer_reading) + " miles on it.") def update_odometer(self, mileage): if mileage &gt;= self.odometer_reading: self.odometer_reading = mileage else: print("You can't roll back an odometer!") def increment_odometer(self, miles): self.odometer_reading += miles class ElectricCar(Car): def __init__(self, make, model, year): super().__init__(make, model, year) my_tesla = ElectricCar('tesla', 'model s', 2016) print(my_tesla.get_descriptive_name()) 定义子类时，在括号里指定父类的名称。super()帮助Python将父类和子类关联起来，调用父类的方法__init__()，让ElectricCar实例包含父类的所有属性。上面ElectricCar实例的行为与Car实例一样，现在定义电动汽车特有的属性和方法在__init__函数內定义一个电动汽车特有的属性，self.battery_size=70编写一个打印电瓶描述的方法 123def describe_battery(self): print("This car has a " + str(self.battery_size) + "-kWh battery.") 1.继承顺序在Java和C#中子类只能继承一个父类，而Python中子类可以同时继承多个父类，如A(B,C,D) 如果继承关系为非菱形结构，则会按照先找B这一条分支，然后再找C这一条分支，最后找D这一条分支的顺序直到找到我们想要的属性 如果继承关系为菱形结构，那么属性的查找方式有两种，分别是：深度优先和广度优先 1234567891011121314151617181920212223242526272829303132class A(object): def test(self): print('from A') class B(A): def test(self): print('from B') class C(A): def test(self): print('from C') class D(B): def test(self): print('from D') class E(C): def test(self): print('from E') class F(D,E): # def test(self): # print('from F') passf1=F()f1.test()print(F.__mro__) #只有新式才有这个属性可以查看线性列表，经典类没有这个属性 #新式类继承顺序:F-&gt;D-&gt;B-&gt;E-&gt;C-&gt;A#经典类继承顺序:F-&gt;D-&gt;B-&gt;A-&gt;E-&gt;C#python3中统一都是新式类#pyhon2中才分新式类与经典类 2 继承原理(python如何实现的继承)python到底是如何实现继承的，对于你定义的每一个类，python会计算出一个方法解析顺序(MRO)列表，这个MRO列表就是一个简单的所有基类的线性顺序列表，例如 12&gt;&gt;&gt; F.mro() #等同于F.__mro__[&lt;class '__main__.F'&gt;, &lt;class '__main__.D'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.E'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;] 为了实现继承,python会在MRO列表上从左到右开始查找基类,直到找到第一个匹配这个属性的类为止。而这个MRO列表的构造是通过一个C3线性化算法来实现的。我们不去深究这个算法的数学原理,它实际上就是合并所有父类的MRO列表并遵循如下三条准则:1.子类会先于父类被检查2.多个父类会根据它们在列表中的顺序被检查 3.如果对下一个类存在两个合法的选择,选择第一个父类 3.子类中调用父类的方法方法一：指名道姓，即父类名.父类方法() 12345678910111213141516171819202122class Vehicle: #定义交通工具类 Country='China' def __init__(self,name,speed,load,power): self.name=name self.speed=speed self.load=load self.power=power def run(self): print('开动啦...') class Subway(Vehicle): #地铁 def __init__(self,name,speed,load,power,line): Vehicle.__init__(self,name,speed,load,power) self.line=line def run(self): print('地铁%s号线欢迎您' %self.line) Vehicle.run(self) line13=Subway('中国地铁','180m/s','1000人/箱','电',13)line13.run() 方法二：super()，推荐用这种方法 1234567891011121314151617181920212223242526class Vehicle: #定义交通工具类 Country='China' def __init__(self,name,speed,load,power): self.name=name self.speed=speed self.load=load self.power=power def run(self): print('开动啦...') class Subway(Vehicle): #地铁 def __init__(self,name,speed,load,power,line): #super(Subway,self) 就相当于实例本身 在python3中super()等同于super(Subway,self) super().__init__(name,speed,load,power) self.line=line def run(self): print('地铁%s号线欢迎您' %self.line) super(Subway,self).run() class Mobike(Vehicle):#摩拜单车 pass line13=Subway('中国地铁','180m/s','1000人/箱','电',13)line13.run() 派生在子类中重新定义父类的方法，运行时将忽略父类中的方法，转而运行子类中重新定义的方法。 在子类中，新建的重名的函数属性，在编辑函数内功能的时候，有可能需要重用父类中重名的那个函数功能，应该是用调用普通函数的方式，即：类名.func()，此时就与调用普通函数无异了，因此即便是self参数也要为其传值 多态与多态性多态多态指的是一类事物有多种形态 动物有多种形态：人，狗，猪 多态性多态性是指在不考虑实例类型的情况下使用实例 12在面向对象方法中一般是这样表述多态性：向不同的对象发送同一条消息（！！！obj.func():是调用了obj的方法func，又称为向obj发送了一条消息func），不同的对象在接收时会产生不同的行为（即方法）。也就是说，每个对象可以用自己的方式去响应共同的消息。所谓消息，就是调用函数，不同的行为就是指不同的实现，即执行不同的函数。比如：老师.下课铃响了（），学生.下课铃响了()，老师执行的是下班操作，学生执行的是放学操作，虽然二者消息一样，但是执行的效果不同 多态性分为静态多态性和动态多态性 静态多态性：如任何类型都可以用运算符+进行运算 动态多态性：如下 12345678910111213peo=People()dog=Dog()pig=Pig() #peo、dog、pig都是动物,只要是动物肯定有talk方法#于是我们可以不用考虑它们三者的具体是什么类型,而直接使用peo.talk()dog.talk()pig.talk() #更进一步,我们可以定义一个统一的接口来使用def func(obj): #obj这个参数没有类型限制，可以传入不同类型的值 obj.talk() #调用的逻辑都一样，执行的结果不一样 为什么要用多态性（多态性的好处）： 1.增加了程序的灵活性 以不变应万变，不论对象千变万化，使用者都是同一种形式去调用，如func(animal) 2.增加了程序额可扩展性 通过继承animal类创建了一个新的类，使用者无需更改自己的代码，还是用func(animal)去调用 123456789class Cat(Animal): #属于动物的另外一种形态：猫 def talk(self): print('say miao') def func(animal): #对于使用者来说，自己的代码根本无需改动 animal.talk() cat1=Cat() #实例出一只猫func(cat1) #甚至连调用方式也无需改变，就能调用猫的talk功能 接口接口提取了一群类共同的函数，可以把接口当做一个函数的集合。 然后让子类去实现接口中的函数。 这么做的意义在于归一化，什么叫归一化，就是只要是基于同一个接口实现的类，那么所有的这些类产生的对象在使用时，从用法上来说都一样。 归一化的好处在于： 归一化让使用者无需关心对象的类是什么，只需要的知道这些对象都具备某些功能就可以了，这极大地降低了使用者的使用难度。 归一化使得高层的外部使用者可以不加区分的处理所有接口兼容的对象集合 在python中根本就没有一个叫做interface的关键字，如果非要去模仿接口的概念 可以借助第三方模块： http://pypi.python.org/pypi/zope.interface twisted的twisted\internet\interface.py里使用zope.interface 文档https://zopeinterface.readthedocs.io/en/latest/ 设计模式：https://github.com/faif/python-patterns 也可以使用继承： 继承的两种用途 一：继承基类的方法，并且做出自己的改变或者扩展（代码重用）：实践中，继承的这种用途意义并不很大，甚至常常是有害的。因为它使得子类与基类出现强耦合。 二：声明某个子类兼容于某基类，定义一个接口类（模仿java的Interface），接口类中定义了一些接口名（就是函数名）且并未实现接口的功能，子类继承接口类，并且实现接口中的功能 抽象类1 什么是抽象类与java一样，python也有抽象类的概念但是同样需要借助模块实现，抽象类本质也是类，只是加了装饰器的类，它的特殊之处在于只能被继承，不能被实例化， 2 为什么要有抽象类如果说类是从一堆对象中抽取相同的内容而来的，那么抽象类就是从一堆类中抽取相同的内容而来的，内容包括数据属性和函数属性。 比如我们有香蕉的类，有苹果的类，有桃子的类，从这些类抽取相同的内容就是水果这个抽象的类，你吃水果时，要么是吃一个具体的香蕉，要么是吃一个具体的桃子。。。。。。你永远无法吃到一个叫做水果的东西。 从设计角度去看，如果类是从现实对象抽象而来的，那么抽象类就是基于类抽象而来的。 从实现角度来看，抽象类与普通类的不同之处在于：抽象类中只能有抽象方法（没有实现功能），该类不能被实例化，只能被继承，且子类必须实现抽象方法。这一点与接口有点类似，但其实是不同的，即将揭晓答案 3 在python中实现抽象类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import abc #利用abc模块实现抽象类 class All_file(metaclass=abc.ABCMeta): all_type='file' @abc.abstractmethod #定义抽象方法，无需实现功能 def read(self): '子类必须定义读功能' pass @abc.abstractmethod #定义抽象方法，无需实现功能 def write(self): '子类必须定义写功能' pass # class Txt(All_file):# pass## t1=Txt() #报错,子类没有定义抽象方法 class Txt(All_file): #子类继承抽象类，但是必须定义read和write方法 def read(self): print('文本数据的读取方法') def write(self): print('文本数据的读取方法') class Sata(All_file): #子类继承抽象类，但是必须定义read和write方法 def read(self): print('硬盘数据的读取方法') def write(self): print('硬盘数据的读取方法') class Process(All_file): #子类继承抽象类，但是必须定义read和write方法 def read(self): print('进程数据的读取方法') def write(self): print('进程数据的读取方法') wenbenwenjian=Txt() yingpanwenjian=Sata() jinchengwenjian=Process() #这样大家都是被归一化了,也就是一切皆文件的思想wenbenwenjian.read()yingpanwenjian.write()jinchengwenjian.read() print(wenbenwenjian.all_type)print(yingpanwenjian.all_type)print(jinchengwenjian.all_type)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python的递归与二分法]]></title>
    <url>%2F2018%2F11%2F21%2Fpython%E7%9A%84%E9%80%92%E5%BD%92%E4%B8%8E%E4%BA%8C%E5%88%86%E6%B3%95%2F</url>
    <content type="text"><![CDATA[递归递归:在调用一个函数的过程中，直接或间接地调用了函数本身这个就叫递归 1.必须有个明确的结束条件 2.每次进入更深一层递归时，问题规模相比上次递归应有所减少 3.递归效率不高，递归层次过多会导致栈溢出（在计算机中，函数调用是通过栈(stack)这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，就栈就会减少一层栈帧。由于栈的大小不是无限的，递归调用的次数过多，则会导致栈溢出） 实例： 123456789101112131415def age(n): if n == 1: return 18 else: return age(n-1)+2 print(age(5))# age(5)=age(4)+2 第一次进入# age(4)=age(3)+2 第二次进入# age(3)=age(2)+2 第三次进入# age(2)=age(1)+2 第四次进入# age(1)=18 第五次进入，最后判断终止条件# age(n)=age(n-1)+2 #n&gt;1 递归终止条件# age(1)=18 #n=1 等于终止条件 二分法每次拿中间的值与想要的值比较 例： 1234567891011121314151617181920212223name = &#123;12, 32, 23, 45, 123, 4654, 1231, 1, 2, 212, 56, 9, 34, 99, 30&#125;name_sor = sorted(name) #把列表内容按升序排列 def second_find(x, li): mid_index = int(len(li) / 2) if len(li) &gt; 1: if x &gt; li[mid_index]: l1 = li[mid_index:] second_find(x,l1) elif x &lt;li[mid_index]: l2 = li[:mid_index] second_find(x,l2) else: print('恭喜你找到了') elif len(li) == 1: if li[0] == x: print("恭喜你找到了") else: print("gun!") second_find(32, name_sor)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python内置函数]]></title>
    <url>%2F2018%2F11%2F21%2Fpython%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[内置函数以下是Python3版本所有的内置函数： abs()绝对值 all()传进一个可迭代对象，如果对象为空，比如[],’ ‘等，则返回False，如果不为空，则需要全部对象为Ture，才返回Ture 1print(all([None,0,' ',1])) 输出结果：False any()传进一个可迭代对象,如果对象为空，比如[],’ ‘等，则返回False,如果不为空，只要可迭代对象next出来的值任何一个为Ture，就返回Ture 1print(any([None,0,' ',1])) 输出结果：True sum()传进一个可迭代对象，进行求和计算 bin()返回一个整数 int 或者长整数 long int 的二进制表示 bool()以下情况都为False： [] 空列表 {} 空字典，空集合 () 空元祖 ‘ ‘ 空字符串 0 bytes()将一个字符串转换成字节形式 1print(bytes('helloworld', encoding='utf-8')) callable()判断函数是否可被调用 chr()用一个范围在 range（256）内的（就是0～255）整数作参数，返回一个对应ascii字符 dir()查看下面的方法 例： print(dir(sum)) 查看sum下面的方法 divmod()传进去两个数，得到整除加余数，多用于分页 enumerate()可迭代,并加上序列例： 12for i in emumerate(['a','b','c']) print(i) 输出结果： 123(0,'a')(1,'b')(2,'c') eval()函数可将字符串转换为代码执行，并返回一个或多个值 hash()一种算法，如果字符串改变，hash值也会改变，且不能逆推 hex()十进制转十六进制 otc()十进制转八进制 id()返回对象的内存地址,判断身份 pow()方法返回 xy（x的y次方） 的值 reverse()函数用于反向列表中元素 lambda()匿名函数:是指一类无需定义标识符（函数名）的函数或子程序。lambda 函数可以接收任意多个参数 (包括可选参数) 并且返回单个表达式的值 例1:定义一个lambda表达式，求三个数的和 12345678f = lambda x,y,z:x + y + zprint f(1,2,3)print f(4,5,6)输出：615 例2:用lambda表达式求n的阶乘 1234n = 5print reduce(lambda x,y:x*y,range(1,n+1))输出：120 round()方法返回浮点数x的四舍五入值,但实际为四舍六入五留双 round(10.5) 离偶数10近，所以结果为10 round(11.5) 离偶数12近，所以结果为12 max()求最大值 例：求字典中values的最大值，但返回的key 12money =&#123;'wzc': 5000, 'lsy': 500, 'hsy': 7000&#125;print(max(money, key=lambda s: money[s])) min()求最小值 zip()函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。 如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同 1234a = [1,2,3]b = [4,5,6]c = [4,5,6,7,8]zipped = zip(a,b) 打包为元组的列表 [(1, 4), (2, 5), (3, 6)] 1zipped = zip(a,c) 元素个数与最短的列表一致 [(1, 4), (2, 5), (3, 6)] sorted()排序，返回值是列表，默认升序 123sor = [2, 4, 6, 1, 34, 3]print(sorted(sor)) # 升序print(sorted(sor, reverse=True)) # 降序 实例：把人员按工资的高低排列 12money =&#123;'wzc': 5000, 'lsy': 500, 'hsy': 7000&#125;print(sorted(money, key=lambda x: money[x])) map()会根据提供的函数对指定序列做映射。它接收一个函数 f 和一个 list，并通过把函数 f 依次作用在 list 的每个元素上，得到一个map迭代器 并返回 实例1： 将列表中的值平方： 123x = [1, 4, 3, 2, 9, 6]l = map(lambda x1: x1**2, x)print(list(l)) 注意:Pyhton2返回列表，Python3 返回迭代器对象,我看网上很多人的博客写的都是Python2的返回结果 实例2：拼接 123x = [1, 4, 3, 2, 9, 6]l = map(lambda x1: str(x1) + 'apple', x)print(list(l)) reduce()函数会对参数序列中元素进行累积 在 Python3 中，reduce() 函数已经被从全局名字空间里移除了，它现在被放置在 fucntools 模块里，如果想要使用它，则需要通过引入 functools 模块来调用 reduce() 函数： 12from functools import reducereduce(lambda x, y: x+y, [1,2,3,4,5]) filter()函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。 该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判，然后返回 True 或 False，最后将返回 True 的元素放到新列表中。 注意: Pyhton2返回列表，Python3 返回迭代器对象 实例1： 123fe = [34, 23, 12, 56, 34, 34, 324]le = filter(lambda x: x &gt; 20, fe)print(list(le) 实例2： 123money =&#123;'wzc': 5000, 'lsy': 500, 'hsy': 7000&#125;li = filter(lambda x1: money[x1] &gt; 1000, money)print(list(li))]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>内置函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python生成器表达式]]></title>
    <url>%2F2018%2F11%2F20%2Fpython%E7%94%9F%E6%88%90%E5%99%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[生成器表达式相比列表表达式，将[]换成了()，返回对象不是一个列表，而是一个生成器，相比列表更加省内存 实例1： 列表表达式写法： 12l = ['apple%s' % i for i in range(10000)]print(l) 生成器表达式写法： 123g = ('apple%s' % i for i in range(10000))for i in g: print(i) 实例2: 一般写法： 12345678910res = []with open('test1.txt') as f: for line in f: l = line.split(',') d = &#123;&#125; d['name'] = l[0] d['price'] = l[1] d['count'] = l[2] res.append(d) print(d) 生成器表达式写法： 12345with open('test1.txt') as f: res = (line.split(',') for line in f) dic_g = (&#123;'name': i[0], 'price': i[1], 'count': i[2]&#125; for i in res) apple_dic = next(dic_g) #只有调用next才会往外拿一个,大大节省内存 print(apple_dic)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>生成器表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python列表生成式]]></title>
    <url>%2F2018%2F11%2F20%2Fpython%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[列表生成式会将所有的结果全部计算出来，把结果存放到内存中，如果列表中数据比较多，就会占用过多的内存空间，可能会导致MemoryError内存错误或者导致程序在运行时出现卡顿的情况 实例1： 在数字0-99中，取大于50的数，分为拼接在apple字符串后面，并存到一个列表中 一般的写法： 12345messi = []for i in range(100): if i &gt; 50: messi.append("apple%s" % i)print(messi) 列表生成式的写法： 123l = ["apple%s" % i for i in range(100) if i &gt; 50] # 'apple%s' %i 这句话在列表中，所以不用append命令写入列表中print(l) 实例2： 将一个列表中的每一个元素与一个字符串的每一个字符拼接，并保存到一个列表中 一般的写法： 123456789x1 = [1, 2, 3, 4]s = 'month'x2 = []for num in x1: for s1 in s: if num &gt; 2: t = (num, s1) x2.append(t)print(x2) 列表生成式的写法: 1234x1 = [1, 2, 3, 4]s = "month"le = [(num, s1) for num in x1 if num &gt; 2 for s1 in s]print(le)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>列表生成式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python协程函数]]></title>
    <url>%2F2018%2F11%2F19%2Fpython%E5%8D%8F%E7%A8%8B%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[协程函数从语法上来看，协程和生成器类似，都是定义体中包含yield关键字的函数。yield在协程中的用法： 在协程中yield通常出现在表达式的右边，例如：datum = yield,可以产出值，也可以不产出–如果yield关键字后面没有表达式，那么生成器产出None. 协程可能从调用方接受数据，调用方是通过send(datum)的方式把数据提供给协程使用，而不是next(…)函数，通常调用方会把值推送给协程。 协程可以把控制器让给中心调度程序，从而激活其他的协程 所以总体上在协程中把yield看做是控制流程的方式 实例： 123456789101112131415def menu(x): print("welcome %s to shaxian restaurant" % x) men_list = [] while True: print(men_list) food = yield men_list print("%s start to eat %s" % (x, food)) men_list.append(food) g = menu('张三')next(g)g.send('包子') # 将'包子'传给yield ，然后赋值给了food，然后从上次暂停的位置接着执行代码，直到又到下一个yieldg.send('饺子')g.send('牛肉面') g.send与next(g)的区别是： 1.如果函数内yield是表达式形式，那么必须先next(g) 2.二者的共同之处都是可以让函数在上一次暂停的位置继续运行，不一样的地方在于send在触发下一次代码的执行时，会顺便给yield传一个值 如果不想写next的初始化，而直接调用send，可以选择加个装饰器 12345678910111213141516171819202122232425def happy(fuc): def f1(*args, **kwargs): res = fuc(*args, **kwargs) next(res) #让函数调用时自动初始化next return res return f1 @happydef menu(x): print("welcome %s to shaxian restaurant" % x) men_list = [] while True: print(men_list) food = yield men_list print("%s start to eat %s" % (x, food)) men_list.append(food) g = menu('张三') g.send('包子') # 将'包子'传给yield ，然后赋值给了food，然后从上次暂停的位置接着执行代码，直到又到下一个yieldg.send('饺子')g.send('牛肉面')]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>协程函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python生成器]]></title>
    <url>%2F2018%2F11%2F19%2Fpython%E7%94%9F%E6%88%90%E5%99%A8%2F</url>
    <content type="text"><![CDATA[生成器生成器就是一个函数，这个函数内包含yield这个关键字 生成器与return的区别： return只能返回一次函数就结束，而生成器可以返回多次值 生成器函数包含一个或者多个yield 当调用生成器函数时，函数将返回一个对象，但是不会立刻向下执行，yield会保存一个状态，下一次运行会在这个位置接着往下运行，直到碰到下一个yield 像__iter__()和__next__()方法等是自动实现的，所以我们可以通过next()方法对对象进行迭代 一旦函数被yield，函数会暂停，控制权返回调用者 1234567891011def pr(x): print("start games") while x &gt; 0: yield x x -= 1 print("game over") game = pr(5) #此时game就是一个迭代器for i in game: print(i) 输出结果为： 1234567start games54321game over]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>生成器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python迭代器]]></title>
    <url>%2F2018%2F11%2F18%2Fpython%E8%BF%AD%E4%BB%A3%E5%99%A8%2F</url>
    <content type="text"><![CDATA[迭代器迭代器是一个可以记住遍历的位置的对象。 迭代器有两个基本的方法：iter() 和 next()。 使用对象内置的__iter__()方法生成迭代器 1it = name.__iter__() 使用内置工厂函数生成迭代器 1it = iter(name) 迭代器通过其内建的 iter.next() 方法，或通过 Python 内建的 next() 来迭代下一个元素，直到最后触发 StopIteration异常后表示迭代结束。 实例： 1234567name = &#123;'张三': 24, '李四': 25, '王五': 20&#125;it = iter(name)while True: try: print(next(it)) except StopIteration: break 输出为三个key的值 而for循环，本质就是调用了迭代器 for x in name 把name变成了一个迭代器，然后调用next方法，而且不用写 except StopIteration 作用优点1.提供一种不依赖索引的取值方式，这样就可以遍历那些没有索引的可迭代对象(字典，集合，文件) 2.迭代器与列表比较，迭代性是惰性计算，更省内存 缺点1.永远无法获取迭代器的长度，使用不如列表索引灵活，比如要获取第三个，则必须要一个个next 2.一次性，只能往后取，无法倒着取]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>迭代器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python装饰器]]></title>
    <url>%2F2018%2F11%2F18%2Fpython%E8%A3%85%E9%A5%B0%E5%99%A8%2F</url>
    <content type="text"><![CDATA[python装饰器就是用于在不改变原函数代码的情况下拓展新功能的一种函数，这个函数的特殊之处在于它的返回值也是一个函数，使用python装饰器的好处就是在不用更改原函数的代码前提下给函数增加新的功能。 装饰器分为有参和无参两种 无参123456789101112131415161718192021import timedef happy(func): def f1(*args, **kwargs): start_time = time.time() func(*args, **kwargs) end_time = time.time() print('run time is %s' % (end_time-start_time)) return f1 @happy #auto=happy(auto)def auto(name, password): print(name, password) @happydef shadow(): time.sleep(3) print("hello_world") shadow()auto('wzc', '123456') auto函数为原函数，我们需要对其进行功能扩展 因为原函数可能有形参或者没有，因此我们将函数定义为 def f1(*args, **kwargs)，这样不管是有参还是无参，都可以接收，不会报错 这里的happy函数就是最原始的装饰器，把auto当做了一个参数传了进去 auto=happy(auto) 然后返回值也是一个函数，返回一个f1，相当于auto=f1 其中作为参数的这个函数auto就在返回函数f1的内部执行。在函数auto前面加上@happy，auto函数就相当于被注入了计时功能，现在只要调用auto，它就已经变身为“新的功能更多”的函数了。 有参有参装饰器与无参装饰器的区别就是在外面多加一个嵌套函数，实现闭包功能 12345678910111213141516171819import time def mom(x='blee'): def happy(func): def f1(*args, **kwargs): print(x) start_time = time.time() func(*args, **kwargs) end_time = time.time() print('run time is %s' % (end_time-start_time)) return f1 return happy @mom('red')def auto(name, password): print(name, password) auto('wzc', '123456') 在原函数前面写@装饰器名，并加入参数 @mom(‘red’) 这时候我们先看mom(‘red’)，传回一个函数happy，等同于 @happy 接下来就和上面一样，这样就实现了有参装饰器]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>装饰器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python函数]]></title>
    <url>%2F2018%2F11%2F17%2Fpython%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[内置函数比如print,len,max等，后面有详细介绍的文章 自定义函数函数定义1234def 函数名():'写注释，描述信息'函数体return 返回值可以是任意类型，不写return，则默认返回None 无参函数通常情况不需要return值 12def fly():函数体 有参函数123def fly(a,b):函数体return a+b 调用函数有参 money=fly(1,2) #定义一个变量来接收return的值 无参 fly() #无参函数不写return，则默认返回None 函数的参数介绍从形参的角度分析位置参数：必须传值的参数 123def fly(x,y): print(x) print(y) 默认参数 123def fly(x,y=1): print(x) print(y) fly(1) #output : 1 1 fly(1,4) #output : 1 4 默认参数要注意的问题：默认参数必须放到位置参数的后面,def fly(x=1,y)则会报错 特殊的两种参数 * args 接收所有除了正常传参的位置传参，保存为元祖 **kwagrs 接收所有除了正常传参的关键字传参，保存为字典 例1： 1234567def fly(x, y=1, *args, **kwargs): print(x) print(y) print(args) print(kwargs) fly(1,y=78,a=1,b=2) 输出结果： 1234178()&#123;'a': 1, 'b': 2&#125; 例2： 1234567def fly(x, y=1, *args, **kwargs): print(x) print(y) print(args) print(kwargs) fly(1,20,300,78,w=1,l=2) 输出结果： 1234120(300, 78)&#123;'w': 1, 'l': 2&#125; 从实参的角度分析：第一种按位置传参 1fly(1,4) 第二种按关键字传参 12fly(x=1,y=2)fly(y=1,x=2) 第三种混着用 1fly(1,y=2) 如果写成fly(1,x=1)则会报错，因为参数只能赋值一次 如果写成fly(x=1,2)则会报错，因为按位置传值必须在按关键字传值前面 以上两条是混合实参的原则，不能违反 特殊的实参写法 1fly(*(12,16,14,15,18),**&#123;"ni":"fuck","sad":"many"&#125;) 上面的写法相当于： fly(12,16,14,15,18,ni=fuck,sad=many) 名称空间名称空间分为： 内部名称空间 全局名称空间 内置名称空间 搜索顺讯为：内置 全局 内部 闭包：内部函数包含对外部作用域而不是对全局作用域的名字的引用 下面是一个闭包例子： 123456789def f3(): x = 1 def f4(): print(x) return f4 x = 1000f4 = f3()f4() 输出结果：1 不管在哪调用内置函数，变量一定是由内向外搜索]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python文件操作]]></title>
    <url>%2F2018%2F11%2F17%2Fpython%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[流程1.打开文件 open() 2.操作文件 read write 3.关闭文件 close() 在window系统上 默认的编码是gbk 用open()打开时，window系统会使用默认的gbk编码，所以如果打开的文件是别的编码保存，则需要手动指定编码，例如打开utf-8保存的文件时 1f = open("test",encoding="utf-8") 而在linux系统上 默认的编码是utf-8 操作方法读整个文件的内容 1f.read() 读文件前5个字符的内容 1f.read(5) 如果再来一次 f.read(5),则读接下来的5个字符，read的内容取决于光标的位置 读一行 1f.readline() 一行一行打印，并移除空白 12for i in f: print(i.strip()) 写入模式1f = open("d://test1.txt", mode="w", encoding="utf-8") 当文件不存在时，会自动创建 这个模式只能写，不能读 覆盖的写 1f.write(hello\nworld) 多行一起写 1f.write(['11111\n','222222\n']) 追加模式跟w模式一样也是只能写，但是是追加的写 1f=open("d://test1.txt",mode="a",encoding="utf-8") 光标移动seek()的三种模式： （1）f.seek(p,0) 移动当文件第p个字节处，绝对位置 （2）f.seek(p,1) 移动到相对于当前位置之后的p个字节 （3）f.seek(p,2) 移动到相对文章尾之后的p个字节 seek是按字节移动 可读可写模式1.可读内容，写则是追加的写 1f=open("d://test1.txt",mode="r+",encoding="utf-8") 2.写的时候会把原来的内容覆盖,想读取内容，需要seek调整光标位置 1f=open("d://test1.txt",mode="w+",encoding="utf-8") 3.初始光标在最后，要读，则需要将光标调到初始位置，seek(0)，要写不管光标位置在哪，都是追加的写入 1f=open("d://test1.txt",mode="a+",encoding="utf-8") 新的方法可以避免忘记写close() 1with open("d://test1.txt", encoding="utf-8") as f 导入sys模块 123import syssys.stdout.write(s)sys.stdout.flush()]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python文件操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基础二]]></title>
    <url>%2F2018%2F11%2F16%2Fpython%E5%9F%BA%E7%A1%80%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[运算符算数运算 运算符 描述 实例 + 加 - 两个对象相加 a+b输出结果 30 - 减 - 得到负数 或是一个数减去另一个数 a-b输出结果 -10 * 乘 - 两个数相乘或是返回一个被重复若干次的字符串 a*b输出结果 200 / 除 - x除以y b/a 输出结果 2 % 取模 - 返回除法的余数 b%a输出结果 0 ** 幂 - 返回x的y次幂 a**b为10的20次方，输出结果10000000000000000000 // 取整除 - 返回商的整数部分 9//2输出结果4, 9.0//2.0输出结果4.0 比较运算 运算符 描述 实例 == 等于 - 比较对象是否相等 (a==b)返回False != 不等于 - 比较两个对象是否不相等 (a!=b)返回True &lt;&gt; 不等于 - 比较两个对象是否不相等 (a&lt;&gt;b)返回True。这个运算符类似!= &gt; 大于 - 返回x是否大于y (a&gt;b)返回False &lt; 小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊变量True和False等价，注意这些变量名的大写 (a&lt;b)返回True &gt;= 大于等于 - 返回x是否大于y (a&gt;=b)返回False &lt;= 小 于等于 - 返回x是否小于y (a&lt;=b)返回True 赋值运算 运算符 描述 实例 = 简单的赋值运算符 c=a+b将a+b的运算结果赋值为c += 加法赋值运算符 c+=a等效于c=c+a -= 减法赋值运算符 c-=a等效于c=c-a *= 乘法赋值运算符 等效于c=c*a /= 除法赋值运算符 c/=a等效于c=c/a %= 取模赋值运算符 c%=a等效于c=c%a **= 幂赋值运算符 等效于c=c**a //= 取整除赋值运算符 c//=a等效于c=c//1 逻辑运算 运算符 描述 实例 and 布尔”与” - 如果x为False，x and y返回False，否则它返回y的计算值 (a and b)返回True or 布尔”或” - 如果x是True，它返回True，否则它返回y的计算值 (a or b)返回True not 布尔”非” - 如果x为True，返回False。如果x为False，它返回True not(a and b)返回False 如果and 和 or 同时存在，则or将整体分成两部分看 成员运算 运算符 描述 实例 in 如果在指定的序列中找到值返回True，否则返回False x在y序列中，如果x在y序列中返回True not in 如果在指定的序列中没有找到值返回True，否则返回False x不在y序列中，如果x不在y序列中返回True 三元运算1result =值1 if 条件 else 值2 如果条件为真：result =值1 如果条件为假 ：result =值2 123a = 3b = 7c = a if a&lt;b else b 如果a小于b则把a的值赋给c，相反则把b的值赋给c 身份运算 运算符 描述 实例 is is是判断两个标识是不是引用自一个对象 x is y，如果id(x)等于id(y)，is返回结果1 not is is not是判断两个标识是不是引用自不同对象 x is not y，如果id(x)不等于id(y)，is返回结果1 位运算 运算符 描述 实例 &amp; 按位与运算符 (a&amp;b)输出结果12，二进制解释：0000 1100 丨 按位或运算符 (a丨b)输出结果61，二进制解释：0011 1101 ^ 按位异或运算符 (a^b)输出结果49，二进制解释：0011 0001 ~ 按位取反运算符 (~a)输出结果-61，二进制解释：1100 0011，在一个有符号二进制数的补码形式 &lt;&lt; 左移动运算符 a&lt;&lt;2输出结果240，二进制解释：1111 0000 &gt;&gt; 右移动运算符 a&gt;&gt;2输出结果15，二进制解释：0000 1111 运算符优先级 运算符 描述 ** 指数(最高优先级) ~ + - 按位翻转，一元加号和减号(最后两个方法名为+@和-@) * / % // 乘，除，取模和取整除 + - 加法减法 &gt;&gt; &lt;&lt; 右移，左移运算 &amp; 位’AND’ ^ 丨 位运算符 &lt;= &lt;&gt; &gt;= 比较运算符 &lt;&gt; == != 等于运算符 = %= /= //= -= += *= **= 赋值运算符 is is not 身份运算符 in not in 成员运算符 not or and 逻辑运算符 bytes类型Python3中内置类型bytes和str用法及byte和string之间各种编码转换Python 3最重要的新特性大概要算是对文本和二进制数据作了更为清晰的区分。文本总是Unicode，由str类型表示，二进制数据则由bytes类型表示。Python 3不会以任意隐式的方式混用str和bytes，正是这使得两者的区分特别清晰。你不能拼接字符串和字节包，也无法在字节包里搜索字符串（反之亦然），也不能将字符串传入参数为字节包的函数（反之亦然）. 1234msg = "我爱北京天安门"print(msg)print(msg.encode(encoding="utf-8"))print(msg.encode(encoding="utf-8").decode(encoding="utf-8")) 执行结果： 123我爱北京天安门b'\xe6\x88\x91\xe7\x88\xb1\xe5\x8c\x97\xe4\xba\xac\xe5\xa4\xa9\xe5\xae\x89\xe9\x97\xa8'我爱北京天安门 格式化%s 字符串 例： 123456789101112131415161718192021string="hello"#%s打印时结果是helloprint "string=%s" % string # output: string=hello#%2s意思是字符串长度为2，当原字符串的长度超过2时，按原长度打印，所以%2s的打印结果还是helloprint "string=%2s" % string # output: string=hello#%7s意思是字符串长度为7，当原字符串的长度小于7时，在原字符串左侧补空格，#所以%7s的打印结果是 helloprint "string=%7s" % string # output: string= hello#%-7s意思是字符串长度为7，当原字符串的长度小于7时，在原字符串右侧补空格，#所以%-7s的打印结果是 helloprint "string=%-7s!" % string # output: string=hello !#%.2s意思是截取字符串的前2个字符，所以%.2s的打印结果是heprint "string=%.2s" % string # output: string=he#%.7s意思是截取字符串的前7个字符，当原字符串长度小于7时，即是字符串本身，#所以%.7s的打印结果是helloprint "string=%.7s" % string # output: string=hello#%a.bs这种格式是上面两种格式的综合，首先根据小数点后面的数b截取字符串，#当截取的字符串长度小于a时，还需要在其左侧补空格print "string=%7.2s" % string # output: string= heprint "string=%2.7s" % string # output: string=helloprint "string=%10.7s" % string # output: string= hello %d 整数 %f 浮点数 编码 在python3中不需要申明编码 从英文意思上看，encode和decode分别指编码和解码。在python中，Unicode类型是作为编码的基础类型，即： 12decode encodestr ---------&gt; str(Unicode) ---------&gt; str 12345678910111213141516171819&gt;&gt;&gt; u = '中文' # 指定字符串类型对象u &gt;&gt;&gt; str1 = u.encode('gb2312') # 以gb2312编码对u进行编码，获得bytes类型对象&gt;&gt;&gt; print(str1)b'\xd6\xd0\xce\xc4' &gt;&gt;&gt; str2 = u.encode('gbk') # 以gbk编码对u进行编码，获得bytes类型对象&gt;&gt;&gt; print(str2)b'\xd6\xd0\xce\xc4'&gt;&gt;&gt; str3 = u.encode('utf-8') # 以utf-8编码对u进行编码，获得bytes类型对象&gt;&gt;&gt; print(str3)b'\xe4\xb8\xad\xe6\x96\x87' &gt;&gt;&gt; u1 = str1.decode('gb2312') # 以gb2312编码对字符串str进行解码，获得字符串类型对象&gt;&gt;&gt; print('u1')'中文' &gt;&gt;&gt; u2 = str1.decode('utf-8') # 报错，因为str1是gb2312编码的UnicodeDecodeError: 'utf-8' codec can't decode byte 0xd6 in position 0: invalid continuation byte 其他break 跳出本层循环 continue 跳出本次循环 1234567for i in range(10): print(i) if i ==5: breakelse: print("done")print("done2") 只有正常结束for循环才会执行else的命令，所以done不会被输出 判断是否为数字 isdigit() 取嵌套列表的值 name = [12,23,34,[34,55]] 取55的值 ：name[3][1]]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>运算符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基础一]]></title>
    <url>%2F2018%2F11%2F16%2Fpython%E5%9F%BA%E7%A1%80%E4%B8%80%2F</url>
    <content type="text"><![CDATA[数据类型数字整型 int 长整型 long 浮点型 float 复数 complex 字符str它只是人类可读的一种抽象表示形式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263name="helloworld" name.capitalize() #将字符串变成首字母大写，其他全部小写 name.casefold() #将字符串变成全部变小写 nam.lower() #将字符串变成全部变小写 name.upper() #将字符串变成全部变大写 name.swapcase() #大小写互换 name.center(50,'-') #将字符串长度变成50，且字符串居中,不够的由-填充，如果50后面不写，则默认空格填充 name.ljust(50,'-') #同上，字符串左对齐 name.rjust(50,'-') #同上，字符串右对齐 name.count('e') #查找整个字符串有几个e name.count('e',2,4) #从字符串的第3到4中找有几个e ,含头不含尾 name.startwith() #以..什么开头 name.endwith() #以..什么结尾 name.expandtabs(10) #定义\t的长度 name.find('h') #查找h的位置 name.index('h') #返回h的索引值 name.find('h',2,6) #在3到6之间找第一个h的位置，返回的是整个字符串的位置，找不到-1 name.format() #format的用法是： name=“hello&#123;0&#125;,fuck&#123;1&#125;” name.format('world',144) # output: helloworld,fuck144 “-”.join(["fuck","u","every","day"]) # output:fuck-u-every-day 将列表的内容用指定的字符串串起来，变成一个字符串 name.lstrip() #从左边开始删指定的字符串 name.rstrip() #从右边开始删指定的字符串 name.replace('he','she') #把he替换成she name.replace('he','she',1) #把he替换成she,只替换一次 name.strip() #移除空白 len(name) #判断 name.index("f") #以0开始，索引 name[0:8] #从第1个切到第8个 取头不取尾(切得最后一个不取) name[-6:] #从倒数第5个切到最后一个，因为-1在尾部，取不到，直接不写 name[2::2] #从第3个开始，隔2个取一个 布尔型boolbool，从Python2.3开始Python中添加了布尔类型。布尔类型有两种True和False。对于没有nozero方法的对象默认是True。 bool运算： 以下情况都为False [] 空列表 {} 空字典 空集合 () 空元祖 ‘’ 空字符串 0 数字0 list 列表list [] name=[“萨德”,”委屈”,”多行”,”太容易”,”电风扇”] name[0] 取第一个的值 name.index(“多行”) 查询多行的位置 得到结果 2 name.count(“太容易”) 查询太容易在列表中数量 name.append(“付出”) 追加 name.insert(4,”陈涛”) 把陈涛插到4的位置 name.pop(4) 删除第四个 ()内不写则默认删除最后一个 name.remove(“陈涛”) 删除成涛 del name[0] 删除第一个 name[name.index(“陈涛”)]=”水” 修改陈涛为水 dict 字典字典(dictionary)是除列表之外python中最灵活的内置数据结构类型。列表是有序的对象结合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。 字典由键和对应的值组成。字典也被称作关联数组或哈希表。基本语法如下： 1dict = &#123;'Alice': '2341', 'Beth': '9102', 'Cecil': '3258'&#125;; 也可如此创建字典： 12dict1 = &#123; 'abc': 456 &#125;;dict2 = &#123; 'abc': 123, 98.6: 37 &#125;; 可以字典中加字典，嵌套 key必须是唯一的 实例：name = {1 : [’fuck‘], 2 : [‘fuck’], 3: {’name‘:’d‘}, 34 : [‘wzc’,’hsy’] } 增name[34].append(“love”) 在key为34中添加值love name[”nice“]=”whatever“ 在name中新插入key为nice,value为whatever的键/值对 删name.pop(34) 删除key为34的键/值对 del name[34] 删除key为34的键/值对 改name[34][0]=’’love’’ 将key为34内的第一个值改为love name[24]=name.pop(34) 将key名为34的改成24，值不变 查name.get(34) 查找key为34的值，没有则返回None name[34] 查找key为34的值，没有则报错 113 in name 判断字典中是否有key为113的键/值对 name.keys() 查找字典中所有的key name.values() 查找字典中所有的值 循环for i in name: print( i ,name[i] ) 更新name.update(name1) 将name1的键值对合并到name中，如果两者之间有相同名字的key，则取name1中的值 set 集合集合与字典的区别是没有key值 特点：天然去重，无序 12345678910111213141516171819202122232425262728linux = &#123;"alex", "jack", "rain", "lizhi", "sb", "lizhi"&#125;python = &#123;"sb", "alex", "mack", "rachel"&#125; print(linux.intersection(python)) # 交集print(linux &amp; python) # 交集print(linux.difference(python)) # 差集 linux中有而python中没有print(linux - python) # 差集 linux中有而python中没有print(linux.union(python)) # 并集print(linux | python) # 并集print(linux.symmetric_difference(python)) # 对称 互相不在的都打印print(linux ^ python) # 对称 互相不在的都打印 linux.add() #增加 linux.clear() #把linux集合中内容删光 linux.update(python) #把python合并到linux集合中 linux.discard("alex") #把linux中的alex删除，元素不存在不会报错 linux.remove('alex') #把linux中的alex删除，元素不存在会报错 linux.pop() #随机删除一个 linux.issubset(python) #判断linux是不是python的子集 linux.issuperset(python) #判断linux是不是python的父集 linux.isdisjoint(python) #如果两个集合没有任何关联，则返回Ture tuple 元祖元组类型在很多操作上都跟列表一样，许多用在列表上的例子在元组上照样能跑，我们有一节内容专门讲解元组类型。它们的主要不同在于元组是不可变的，或者说是只读的，所以那些用于更新列表的操作，比如用切片操作来更新一部分元素的操作，就不能用于元组类型 12345678CPython&gt;&gt;&gt; a = ('a','123',['a',123])&gt;&gt;&gt; a('a', '123', ['a', 123])&gt;&gt;&gt; type(a)&lt;class 'tuple'&gt;&gt;&gt;&gt; tu = tuple('abcde')&gt;&gt;&gt; tu('a', 'b', 'c', 'd', 'e') 列表与字典的一个methodname=[21,23,454[34,123]] h=name.copy() 当改变h[0],h[1],h[2]这些值时，name中的不变 但改变h[3]时 h[3][0]=56 name中也会变 同理 n1={12:”asda”,24:”asdasd”,33:[78,34]} n2=n1.copy() 更改n1[12]的值，n2不变 更改 n1[33][0]的值，n2中也会变 转换类型int(x [,base ]) 将x转换为一个整数 long(x [,base ]) 将x转换为一个长整数 float(x ) 将x转换到一个浮点数 complex(real [,imag ]) 创建一个复数 str(x ) 将对象 x 转换为字符串 repr(x ) 将对象 x 转换为表达式字符串 eval(str ) 用来计算在字符串中的有效Python表达式,并返回一个对象 tuple(s ) 将序列 s 转换为一个元组 list(s ) 将序列 s 转换为一个列表 chr(x ) 将一个整数转换为一个字符 unichr(x ) 将一个整数转换为Unicode字符 ord(x ) 将一个字符转换为它的整数值 hex(x ) 将一个整数转换为一个十六进制字符串 oct(x ) 将一个整数转换为一个八进制字符串 编码utf -8 英文1个字节 中文3个字节 gbk 中文2个字节]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LINUX -nginx服务安装]]></title>
    <url>%2F2018%2F11%2F15%2FLINUX-nginx%E6%9C%8D%E5%8A%A1%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[了解Nginxnginx会以daemon的方式在后台运行。后台进程包含一个master进程和多个worker进程。 master进程：主要用来管理worker进程，包含：接收来自外界的信号，向各worker进程发送信号，监控worker进程的运行状态，当worker进程退出后(异常情况下)，会自动重新启动新的worker进程 worker进程：处理基本的网络事件，各进程互相之间是独立的。worker进程的个数，一般与机器cpu核数一致. Nginx 的进程模型从进程模型图可以看出，我们想要操作nginx，只需要与master通信即可。 master进程在接受信号是怎么做的呢？输入如下命令行 1kill -HUP pid 这个命令是优雅地重启nginx。当master进程收到信号后，因为是优雅地重启，所以服务器不会中断。而是重新加载配置文件，然后新开worker进程，再向旧的worker进程发送关闭指令。这种直接发送信号给master进程的操作方式已经显得有些老了，在0.8版本后，引入了一系列命令行参数。如 1nginx -s reload 这是一个重新加载配置的命令。在执行命令时，它会向master进程发送信号，同样也是启动一个新的worker进程，再关闭掉旧的worker进程。 worker 进程又是怎么做的?? 首先，在master进程里，比方说一个80端口的http服务，会建立好需要listen的sokcet(listenfd),然后再fork出多个worker进程。在新的请求到来时，所有worker进程的listenfd变为可读，然后开始抢锁，抢到互斥锁的那个进程注册listenfd读事件，在读事件里调用accept接受该连接,开始读取请求，解析请求，处理请求，产生数据后，再返回给客户端。一个请求，完全由worker进程来处理，而且只在一个worker进程中处理。 好处：独立进程，不需要加锁，所以省掉了锁带来的开销。其次，worker进程间互相之间不会影响。 nginx事件模型对于一个基本的web服务器来说，事件通常有三种类型，网络事件、信号、定时器。 网络事件 nginx采用了异步非阻塞的方式来处理请求，可以同时处理成千上万个请求。 请求的完整过程：请求过来，建立连接，然后再接收数据，接收数据后，再发送数据。具体到系统底层，就是读写事件，而当读写事件没有准备好时，必然不可操作。 网络事件模型 说明 阻塞式 事件没准备好，等。在等待中，cpu会让出去。 那么，会造成，网络事件一多，大家都在等，cpu都让出去了但是没人用，cpu使用率都不高,还谈高并发？？？ 尤其是单线程的worker了，更不合适。 非阻塞式 事件没准备好，马上返回EAGAIN，然后间断性再次访问，直到事件准备完成。 好处是确实可以做更多其他的事情，但开销也增加了。 异步非阻塞 对于事件，它是阻塞的。但是，它不是盲目的等待，而是设定了一段超时时间。 在超时时间内事件准备好了，就返回 以epoll(一个异步非阻塞机制的函数)为例： 1 当事件没准备好时，放到epoll里面；2 事件准备好了，就去读写；3 当读写返回EAGAIN时，将它再次加入到epoll里面；4 线程只有一个，所以只能处理一个请求。但可以在请求里切换，再多的并发数，zhi会占用更多的内存而已； 所以说，worker数等于cpu数的原因。就是因为如此，反而事更多的worker数，只会导致cpu资源的竞争，从而带来不必要的上下文切换。 信号 信号会中断掉程序当前的运行，在改变状态后，继续执行。如果是系统调用，则可能会导致系统调用的失败，需要重入。关于信号的处理，大家可以学习一些专业书籍，这里不多说。对于nginx来说，如果nginx正在等待事件（epoll_wait时），如果程序收到信号，在信号处理函数处理完后，epoll_wait会返回错误，然后程序可再次进入epoll_wait调用。 Nginx定时器 由于epoll_wait等函数在调用的时候是可以设置一个超时时间的，所以nginx借助这个超时时间来实现定时器。nginx里面的定时器事件是放在一颗维护定时器的红黑树里面，每次在进入epoll_wait前，先从该红黑树里面拿到所有定时器事件的最小时间，在计算出epoll_wait的超时时间后进入epoll_wait。所以，当没有事件产生，也没有中断信号时，epoll_wait会超时，也就是说，定时器事件到了。这时，nginx会检查所有的超时事件，将他们的状态设置为超时，然后再去处理网络事件。由此可以看出，当我们写nginx代码时，在处理网络事件的回调函数时，通常做的第一个事情就是判断超时，然后再去处理网络事件。 Nginx事件处理伪代码 12345678910111213141516171819202122while (true) &#123; for t in run_tasks: t.handler(); update_time(&amp;now); timeout = ETERNITY; for t in wait_tasks: /* sorted already */ if (t.time &lt;= now) &#123; t.timeout_handler(); &#125; else &#123; timeout = t.time - now; break; &#125; nevents = poll_function(events, timeout); for i in nevents: task t; if (events[i].type == READ) &#123; t.handler = read_handler; &#125; else &#123; /* events[i].type == WRITE */ t.handler = write_handler; &#125; run_tasks_add(t);&#125; Connection在nginx中connection就是对tcp连接的封装，其中包括连接的socket，读事件，写事件 安装一、安装编译工具及库文件1yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel 二、首先要安装 PCREPCRE 作用是让 Nginx 支持 Rewrite 功能。 1、下载 PCRE 安装包，下载地址： http://downloads.sourceforge.net/project/pcre/pcre/8.35/pcre-8.35.tar.gz 12[root@bogon src]# cd /usr/local/src/[root@bogon src]# wget http://downloads.sourceforge.net/project/pcre/pcre/8.35/pcre-8.35.tar.gz 2、解压安装包: 1[root@bogon src]# tar zxvf pcre-8.35.tar.gz 3、进入安装包目录 1[root@bogon src]# cd pcre-8.35 4、编译安装 12[root@bogon pcre-8.35]# ./configure[root@bogon pcre-8.35]# make &amp;&amp; make install 5、查看pcre版本 1[root@bogon pcre-8.35]# pcre-config --version 三、安装 Nginx1、下载 Nginx，下载地址：http://nginx.org/download/nginx-1.6.2.tar.gz 12[root@bogon src]# cd /usr/local/src/[root@bogon src]# wget http://nginx.org/download/nginx-1.6.2.tar.gz 2、解压安装包 1[root@bogon src]# tar zxvf nginx-1.6.2.tar.gz 3、进入安装包目录 1[root@bogon src]# cd nginx-1.6.2 4、编译安装 123[root@bogon nginx-1.6.2]# ./configure --prefix=/usr/local/webserver/nginx --with-http_stub_status_module --with-http_ssl_module --with-pcre=/usr/local/src/pcre-8.35[root@bogon nginx-1.6.2]# make[root@bogon nginx-1.6.2]# make install 5、查看nginx版本 1[root@bogon nginx-1.6.2]# /usr/local/webserver/nginx/sbin/nginx -v 到此，nginx安装完成。 Nginx 配置创建 Nginx 运行使用的用户 www： 12[root@bogon conf]# /usr/sbin/groupadd www [root@bogon conf]# /usr/sbin/useradd -g www www 配置nginx.conf ，将/usr/local/webserver/nginx/conf/nginx.conf替换为以下内容 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576[root@bogon conf]# cat /usr/local/webserver/nginx/conf/nginx.confuser www www;worker_processes 2; #设置值和CPU核心数一致error_log /usr/local/webserver/nginx/logs/nginx_error.log crit; #日志位置和日志级别pid /usr/local/webserver/nginx/nginx.pid;#Specifies the value for maximum file descriptors that can be opened by this process.worker_rlimit_nofile 65535;events&#123; use epoll; worker_connections 65535;&#125;http&#123; include mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] "$request" ' '$status $body_bytes_sent "$http_referer" ' '"$http_user_agent" $http_x_forwarded_for'; #charset gb2312; server_names_hash_bucket_size 128; client_header_buffer_size 32k; large_client_header_buffers 4 32k; client_max_body_size 8m; sendfile on; tcp_nopush on; keepalive_timeout 60; tcp_nodelay on; fastcgi_connect_timeout 300; fastcgi_send_timeout 300; fastcgi_read_timeout 300; fastcgi_buffer_size 64k; fastcgi_buffers 4 64k; fastcgi_busy_buffers_size 128k; fastcgi_temp_file_write_size 128k; gzip on; gzip_min_length 1k; gzip_buffers 4 16k; gzip_http_version 1.0; gzip_comp_level 2; gzip_types text/plain application/x-javascript text/css application/xml; gzip_vary on; #limit_zone crawler $binary_remote_addr 10m; #下面是server虚拟主机的配置 server &#123; listen 80;#监听端口 server_name localhost;#域名 index index.html index.htm index.php; root /usr/local/webserver/nginx/html;#站点目录 location ~ .*\.(php|php5)?$ &#123; #fastcgi_pass unix:/tmp/php-cgi.sock; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; include fastcgi.conf; &#125; location ~ .*\.(gif|jpg|jpeg|png|bmp|swf|ico)$ &#123; expires 30d; # access_log off; &#125; location ~ .*\.(js|css)?$ &#123; expires 15d; # access_log off; &#125; access_log off; &#125;&#125; 配置文件详解 123456789101112131415161718192021222324252627282930313233343536373839########### 每个指令必须有分号结束。##################user administrator administrators; #配置用户或者组，默认为nobody nobody。#worker_processes 2; #允许生成的进程数，默认为1#pid /nginx/pid/nginx.pid; #指定nginx进程运行文件存放地址error_log log/error.log debug; #制定日志路径，级别。这个设置可以放入全局块，http块，server块，级别以此为：debug|info|notice|warn|error|crit|alert|emergevents &#123; accept_mutex on; #设置网路连接序列化，防止惊群现象发生，默认为on multi_accept on; #设置一个进程是否同时接受多个网络连接，默认为off #use epoll; #事件驱动模型，select|poll|kqueue|epoll|resig|/dev/poll|eventport worker_connections 1024; #最大连接数，默认为512&#125;http &#123; include mime.types; #文件扩展名与文件类型映射表 default_type application/octet-stream; #默认文件类型，默认为text/plain #access_log off; #取消服务日志 log_format myFormat '$remote_addr–$remote_user [$time_local] $request $status $body_bytes_sent $http_referer $http_user_agent $http_x_forwarded_for'; #自定义格式 access_log log/access.log myFormat; #combined为日志格式的默认值 sendfile on; #允许sendfile方式传输文件，默认为off，可以在http块，server块，location块。 sendfile_max_chunk 100k; #每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。 keepalive_timeout 65; #连接超时时间，默认为75s，可以在http，server，location块。 upstream mysvr &#123; server 127.0.0.1:7878; server 192.168.10.121:3333 backup; #热备 &#125; error_page 404 https://www.baidu.com; #错误页 server &#123; keepalive_requests 120; #单连接请求上限次数。 listen 4545; #监听端口 server_name 127.0.0.1; #监听地址 location ~*^.+$ &#123; #请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。 #root path; #根目录 #index vv.txt; #设置默认页 proxy_pass http://mysvr; #请求转向mysvr 定义的服务器列表 deny 127.0.0.1; #拒绝的ip allow 172.18.5.54; #允许的ip &#125; &#125;&#125; 检查配置文件nginx.conf的正确性命令： 1[root@bogon conf]# /usr/local/webserver/nginx/sbin/nginx -t 修改完conf文件，则应重启nginx软件(不推荐) systemctl restart nginx 一般重新加载nginx软件 systemctl reload nginx 然后关闭防火墙 systemctl stop firewalld 开机启动nginx systemctl enable nginx 关闭开机启动nginx systemctl disable nginx 防火墙同理]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LINUX命令三]]></title>
    <url>%2F2018%2F11%2F12%2FLINUX%E5%91%BD%E4%BB%A4%E4%B8%89%2F</url>
    <content type="text"><![CDATA[网络相关配置ifconfig 查看ip信息 远程复制 scp /etc/h.txt 192.168.1.1:/tmp 配置ssh（之后访问无需密码）： ssh-keygen ssh-copy-id -i 192.168.1.16 赋值变量 x=2 调用x echo $x 取消变量 unset x 设置别名 alias x=‘ls /’ 将命令得到的结果赋值到变量 x=$(ls) 搜索文件 ls [a-z][0-9].txt []代表在中间取一个值, a-z代表aAbBcC…..z不包含Z ls [!0-9],txt 查找不以数字开头的文件 执行历史命令 ！638 查看上条命令执行是否成功 echo $? 成功则为0 注释 || 前面命令成功，则后面不执行 ；只有前面命令失败后面才执行 &amp;&amp; 只有前面的命令执行成功才会执行后面的命令 \ 转义符号 ? 匹配一个任意字符 例： ls ???.txt 固化命令在登录时就加载出命令 在/etc/bashrc 文件中添加想要的命令 grep命令grep -A 2 ‘fuck’ /etc/passwd 显示查询结果及后两行 grep -B 2 ‘fuck’ /etc/passwd 显示查询结果及前两行 grep -C 2 ‘fuck’ /etc/passwd 显示查询结果及前后两行 grep -c ‘fuck’ /etc/passwd 显示查询行数 grep -i ‘fuck’ /etc/passwd 无视大小写查询 grep -v ‘fuck’ /etc/passwd 取目标之外的剩余结果 grep -w ‘fuck’ /etc/passwd 单词匹配 grep -rl ‘fuck’ /etc/passwd 匹配文件内容中带fuck的文件路径 正则grep ‘^root’ 匹配以root开头的 grep ‘root$’ 匹配以root结尾的 grep ‘a.b’ .代表任意一个字符 grep ‘ab‘ 代表b有0个或者多个 grep ‘ab?’ 代表b有0个或者1个 egrep ‘ab+’ 必须用egrep +代表b有1个或者多个 egrep ‘ab{2}’ 2个b egrep ‘ab{2，4}’ 2到4个b egrep ‘ab{2，}’ 2个以上b egrep ‘[abc\ / -]’ 含abc/-中一个字符的 [a-z] 代表所有的小写字母 [A-Z] 代表所有的大写字母 [a-Z] 代表所有的大小写字母 注意点如果要匹配的是-本身，则必须放到最后[asd-] echo ^[^0-9] 匹配不是数字开头的 sed命令sed ‘3d’ 删除第三行 sed ‘1,4d’ 删除1-4行 sed ‘1;4d’ 删除第1行和第4行 sed ‘s/sb/fuck’ 把所有行的第一个sb换成fuck sed ‘s/sb/fuck/g’ 把所有行的所有sb换成fuck sed ‘3p’ 打印第三行 sed ‘3c 123456’ 把第三行改成123456 sed ‘3a 123’ 在第三行后插入123 sed ‘3i 123’ 在第三行前插入123 sed’/^root/d’ 加入正则法 sed -r ‘/^[0-9][a-Z]+sb$/ s/sb/SB/g’ r为扩展模式 sed -ri 多加一个i则是直接将文件内容改掉，而不是仅仅输入到终端 sed -r ‘s/^([a-Z]+)([^a-Z])([a-Z]+)([^a-Z])/\3\2\1\4/‘ 将第一个单词和第三个单词换位置 sed -r ‘s/ //g’ 将所有的空格去掉 sed -r ‘s/[0-9]//g’ 将所有的数字去掉 awk文本处理awk -F: ‘{print $1,$7}’ 打印以：为分隔符取第1段和第7段 (:后面加空格) awk -F: ‘{print $1,$NF}’ 打印以：为分隔符取第1段和最后一段 awk -F: ‘NR&lt;=3{print $1,NR}’ 打印前三行的第一段 awk -F: ‘NR&lt;=3{print NR,”—–”,$1}’ 打印出前三段 1——root 的样式 awk -F: ‘/log$/{print $1}’ 匹配有log的行，打印第1段 awk -F: ‘$1~/^r.*t$/{print $3}’ 匹配第一段中以r开头t结尾的行，并打印出这些行的第三段 awk -F: ‘$1==”root”{print $3,NR}’ 匹配第一段是root的行，并打印出这些行的第三段和行号 awk -v x=$count -F: ‘$3&gt;=x{print NR,$1}’ 匹配第三段大于参数x的行，打印行号和第一段 其他命令cat a.txt |sort |uniq 排序 去重 du -sh 统计文件大小 find /file -name “*.txt” 查找file文件夹中以txt结尾的文件 find /file -size +30M 查找file文件夹中大于30M的文件 find /file -size +10M -30M 查找file文件夹中大于10M小于30M的文件 变量linux 没有数据类型之分 set 显示所有变量 env 显示环境变量 变量关系操作test [] 括号里前后要空格 测试数值[ $x -gt $y ] 判断x的值大于y [ $x -ge $y ] 判断x大于等于y [ $x -lt $y ] 判断x小于y [ $x -le $y ] 判断x小于等于y [ $x -eq $y ] 判断x等于y [ $x -ne $y ] 判断x不等于y [ $x -gt $y -a $a -eq $b ] 判断x大于y并且a等于b [ $x -gt $y -o $a -eq $b ] 判断x大于y或者a等于b 测试文件状态-d 目录 -f 普通文件- -w 可写 -r 可读 -x 可执行 3.字符串测试 = 两字符串相等 != 两字符串不相等 -z 空串 -n 非空串 赋值运算符 ((x=x+1)) ——–((x+=1)) echo $((x-=2)) expr $x + $y echo “scale=2;20/100” | bc -l 保留两位小数 bc要先安装]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LINUX命令二]]></title>
    <url>%2F2018%2F11%2F11%2FLINUX%E5%91%BD%E4%BB%A4%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[打包压缩打包命令 tar -cvf /test.tar /a.txt /b.txt /c.txt 查看包内的内容 tar -tf /test.tar 解压包到当前目录 tar -xvf /test.tar 解压包到指定目录 tar -xvf /test.tar -C /try 压缩文件 gzip /test.tar (压缩快但大) 或者bzip2 /test.tar （压缩慢但小） 解压文件 tar -xf /test.tar.zp tar-xf /test.tar.bz2 打包并同时压缩文件tar -cvzf /test.tar.zp /a.txt /b.txt /c.txt 或 tar -cvjf /test.tar.bz2 /a.txt /b.txt /c.txt 如果要连同目录一起压缩则最后用/ 如果只想压缩目录下面的文件则/* vi查看并编辑文档 vim 按a 编辑 按 :wq 保存并退出 q！不保存 x 小写的x表示向后删除一个字符,也就是删除光标所在字符 nx n表示数字，表示向后删除每个字符，例如：10x表示删除包括光标在内的后面10个字符 dd 删除当前一行 ,就是截切 ndd删除n行（例如3dd删除3行） yy复制一行 nyy复制n行 p 粘贴到目标位置的下一行 P 粘贴到目标位置的上一行 u 撤销上一步操作 ctrl+r 返回前一步 gg 光标移动到文件的第一行 G 光标移动到文件的最后一行 nG 光标移动到文件的第n行 dgg 删除光标所在行到第一行数据 dG 删除光标所在行到最后一行数据 磁盘分区/dev fdisk -l /dev/sda 查看磁盘信息 fdisk /dev/sdb 进入磁盘分区 p 输出目前磁盘分区信息 n 分区 分为p主分区 e扩展分区 d 删除分区 给分区装装指定系统 mkfs.xfs /dev/sdb1 挂载一个目录 mount /dev/sdb1 /test 卸除挂载目录 umount /dev/sdb1 一个分区挂载两个目录时，则两个目录同时指向该分区，即同步 df 查看磁盘分区信息 df-Th 创建软连接相当于创建快捷方式ln -s /test/a.txt /sb/a.txt 前面是被创建的软连接 内存查看内存信息 swapon -s 增加内存区 mkswap /dev/sdb2 swapon -a /dev/sdb2 删除内存区swapoff /dev/sdb2 查看内存 free 进程firefox &amp; 后台运行程序 ps aux 查看全部进程 ps aux|grep fire 查找带fire的进程 pgrep firefox 查找firefox进程号 kill -9 3315 强制杀死进程(3315代表进程编号) pkill -9 firefox 指定名称的杀死进程 软件安装二进制软件安装 rpm -ivh /vsf-3.0.2-9.e17.x86_64.rpm覆盖安装 rpm -ivh /vsf-3.0.2-9.e17.x86_64.rpm –force 查看系统中所有安装的rpm包 rpm -qa 查看指定的包 rpm -qa|grep vsf 查看rpm包安装在哪 rpm -ql vsf 查看rmp包详细信息 rpm -qi vsf 查看文件是由那个包产生 rpm -qf /test/b1.txt 删除rmp包 rmp -e vsf 使用yum安装和卸载软件，有个前提是yum安装的软件包都是rpm格式的 yum update 升级系统 yum install ～ 安装指定软件包 yum update ～ 升级指定软件包 yum remove ～ 卸载指定软件 yum grouplist 查看系统中已经安装的和可用的软件组，可用的可以安装 yum groupinstall ～安装上一个命令显示的可用的软件组中的一个 源代码安装python安装 python官网下载file源代码 安装环境 查看group列表 yum grouplist 安装组包 yum groupinstall ‘开发工具’ -y 解压文件 tar -xvf pytho-3.7.0.tgz cd到解压好的文件目录，更改源码包安装路径 ./configure –prefix=/usr/local/python3.7 编码 make 安装 make install（安装时会出现下面两种错误 1. 需要安装zlib包 yum install zlib* 2.ModuleNotFoundError: No module named ‘_ctypes’ 解决方法：3.7版本需要一个新的包libffi-devel，安装此包之后再次进行编译安装即可 yum install libffi-* 把python3.7加到path环境中 更改profile文件 vim /etc/profile 在文件的最后面加上 PATH=$PATH:/usr/local/python3.7/bin export PATH netstat -tunapl 查看网络状态]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LINUX命令一]]></title>
    <url>%2F2018%2F11%2F11%2FLINUX%E5%91%BD%E4%BB%A4%E4%B8%80%2F</url>
    <content type="text"><![CDATA[快捷键：ctrl+c 取消命令 ctrl+l 清屏 命令：更换用户 su - 或sudo su 关机 init 0 重启 init 6 立即关机 shutdown -h now 查询当前用户 who am i 查看当前日期 date 修改当前日期 date -s “2012-01-02 14:00:00”（必须切换到root用户） 查看今天日历 cal 查看某天 cal 日月年（cal 3 4 2012） 改密码 passwd 查看文件下的子文件 ls 查看文件夹下的子文件详细信息 ls -l (简写ll) 查看文件的详细信息 ls -dl(简写ll -d) 查看文件夹下的所有文件包括隐藏文件 ls-a 切换目录 cd 退到上级目录 cd ,, 返回到上一次的目录 cd - 查看当前目录 pwd 递归建文件夹 mkdir -p 改名/移动 mv /a/b1 /a/b2(把a文件下的b1改成b2) mv /a/b1 /z/(把b1移动到z文件下) 文件复制顺便改名 cp /a/b1 /a/b2 文件夹的复制 cp -rf /a/b /c 删除文件夹 rm 删除文件夹下的所有子文件 rm -rf (不建议使用，最好用mv /a /tmp/ 移动到临时文件，还可以还原） ,如果文件带特殊符号，则加上“”即可删除 创建文件 touch a.txt 查看内容 cat 百分比查看 more 分页查看 less 查看前三行 head - n3 查看后三行 tail -n3 监控文件 tail -f 覆盖内容 echo 内容 &gt; 新增内容 echo 内容 &gt;&gt; 查看历史命令 history 使用第57行的历史命令 !57 直接修改密码 echo 123456 | passwd –stdin Messiless 用户信息文件 /etc/passwd 用户密码文件 /etc/shadow 用户组 /etc/group 用户组密码 /etc/gshadow 创建hsy用户 useradd hsy 完全删除hsy用户 userdel -r hsy 第一段代表文件权限信息，第一个数字是-代表普通文件，d则是目录 ，后面的一堆分3个3个来看，rwx代表属主的权限（可读可执行可写） r-x代表属组的权限（可读可执行） r-x代表其他用户的权限（可读可执行） 在jack组中附加一个tom用户 usermod -G jack tom 手动创建一个用户的流程 /etc/passwd /etc/shadow /etc/group /etc/gshaow mkdir /home/hsy cp -r /etc/skel/.[!.]* /home/hsy chown -R hsy.hsy /home/hsy touch /var/spool/mail/hsy chown -R hsy.mail /var/spool/mail/hsy 更换文件权限： 方法一：chmod u=rw,g=r,o=rx /a.txt 方法二：chmod 744 /a.txt (r=4,w=2,x=1) 如果要在一个目录下创建删除重命名文件，则该用户需要同时有wx权限 如果要修改一个目录下文件的内容，则需要文件的w权限，和前面目录的x权限]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pycharm永久激活]]></title>
    <url>%2F2018%2F11%2F03%2Fpycharm%E6%B0%B8%E4%B9%85%E6%BF%80%E6%B4%BB%2F</url>
    <content type="text"><![CDATA[刚开始接触Python，首先要解决的就是Python开发环境的搭建。目前比较好用的Python开发工具是PyCharm，但是这哥们儿有个毛病，你要么花钱购买正版软件，要么就只让你试用一个月。这哪儿行？身为猿军中的一员怎么能让他们这些小伎俩阻碍了我们继续前进的步伐。所以我在度娘的引导下，一步步实现了PyCharm的永久使用 1.未注册刚打开PyCharm是这个熊样子 这明摆着就是说，你要么有自己的JetBrains账户、要么用激活码激活、或者选择最后一个，在网上找一系列的服务地址激活（但就我本人尝试，目前网上这个服务地址只能实现短期使用，过了日期后还得激活，我刚开始也是这么搞的，谁知今天又要我激活，着实头疼） 2.选择另一个方式激活2.1 下载 JetbrainsCrack-2.6.10-release-enc.jar 2.2 将下载的jar包放置在安装PyCharm目录的bin文件夹下面，覆盖掉原来的文件，并打开后缀名为vmoptions的两个文件 2.3 打开后缀名为vmoptions的文件后，分别在文件内容的后面添加 -javaagent:C:\Program Files\JetBrains\PyCharm 2018.2\bin\JetbrainsCrack-2.6.10-release-enc.jar 红色字体部分是自己PyCharm安装目录下的bin文件目录。 2.4 整好上面的部分后，重启PyCharm，如果出现本文第一张图的样子，选择Activation code，将下面的激活码填入其中，点击Active即可 1NPXHBQLDBG-eyJsaWNlbnNlSWQiOiJOUFhIQlFMREJHIiwibGljZW5zZWVOYW1lIjoi5rC45LmF5r+A5rS7IGlkZWEubWVkZW1pbmcuY29tIiwiYXNzaWduZWVOYW1lIjoiIiwiYXNzaWduZWVFbWFpbCI6IiIsImxpY2Vuc2VSZXN0cmljdGlvbiI6IiIsImNoZWNrQ29uY3VycmVudFVzZSI6ZmFsc2UsInByb2R1Y3RzIjpbeyJjb2RlIjoiSUkiLCJwYWlkVXBUbyI6IjIwMjAtMDItMjcifSx7ImNvZGUiOiJBQyIsInBhaWRVcFRvIjoiMjAyMC0wMi0yNyJ9LHsiY29kZSI6IkRQTiIsInBhaWRVcFRvIjoiMjAyMC0wMi0yNyJ9LHsiY29kZSI6IlBTIiwicGFpZFVwVG8iOiIyMDIwLTAyLTI3In0seyJjb2RlIjoiR08iLCJwYWlkVXBUbyI6IjIwMjAtMDItMjcifSx7ImNvZGUiOiJETSIsInBhaWRVcFRvIjoiMjAyMC0wMi0yNyJ9LHsiY29kZSI6IkNMIiwicGFpZFVwVG8iOiIyMDIwLTAyLTI3In0seyJjb2RlIjoiUlMwIiwicGFpZFVwVG8iOiIyMDIwLTAyLTI3In0seyJjb2RlIjoiUkMiLCJwYWlkVXBUbyI6IjIwMjAtMDItMjcifSx7ImNvZGUiOiJSRCIsInBhaWRVcFRvIjoiMjAyMC0wMi0yNyJ9LHsiY29kZSI6IlBDIiwicGFpZFVwVG8iOiIyMDIwLTAyLTI3In0seyJjb2RlIjoiUk0iLCJwYWlkVXBUbyI6IjIwMjAtMDItMjcifSx7ImNvZGUiOiJXUyIsInBhaWRVcFRvIjoiMjAyMC0wMi0yNyJ9LHsiY29kZSI6IkRCIiwicGFpZFVwVG8iOiIyMDIwLTAyLTI3In0seyJjb2RlIjoiREMiLCJwYWlkVXBUbyI6IjIwMjAtMDItMjcifSx7ImNvZGUiOiJSU1UiLCJwYWlkVXBUbyI6IjIwMjAtMDItMjcifV0sImhhc2giOiIxNjQ1MjY3Ni8wIiwiZ3JhY2VQZXJpb2REYXlzIjo3LCJhdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlLCJpc0F1dG9Qcm9sb25nYXRlZCI6ZmFsc2V9-EUjFu84N/OsZQiCnYXYpiEkKgzCO78hiGl96RiH2d23cQuGTlpjtoc5mmLo3W3Dy4mO9XSeS/d99VSr6jmWGPMjv5dGBGywWe21Nj17saWN4qZl3/KvUsLFw/HB4Kh53VDvtNdBYq+vt0A8hdxuXKH1APQdjUQC43GXxTksmAQY+vz4zsQmSNkq8aL4SNSMMA6uXSlhaxzbF+fGW+zA5HG82C+LEei9Se3/728qI1jZ76gEM5wC6fmdiR2mVI2b0cpALMxtLtF17ea5K+UsqCwZUleh+QWBSANHOlzJvotfXeFV514Se1kJBGfcNxs4lDi6icsbSM+D0DbmUDcMNfA==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQAF8uc+YJOHHwOFcPzmbjcxNDuGoOUIP+2h1R75Lecswb7ru2LWWSUMtXVKQzChLNPn/72W0k+oI056tgiwuG7M49LXp4zQVlQnFmWU1wwGvVhq5R63Rpjx1zjGUhcXgayu7+9zMUW596Lbomsg8qVve6euqsrFicYkIIuUu4zYPndJwfe0YkS5nY72SHnNdbPhEnN8wcB2Kz+OIG0lih3yz5EqFhld03bGp222ZQCIghCTVL6QBNadGsiN/lWLl4JdR3lJkZzlpFdiHijoVRdWeSWqM4y0t23c92HXKrgppoSV18XMxrWVdoSM3nuMHwxGhFyde05OdDtLpCv+jlWf5REAHHA201pAU6bJSZINyHDUTB+Beo28rRXSwSh3OUIvYwKNVeoBY+KwOJ7WnuTCUq1meE6GkKc4D/cXmgpOyW/1SmBz3XjVIi/zprZ0zf3qH5mkphtg6ksjKgKjmx1cXfZAAX6wcDBNaCL+Ortep1Dh8xDUbqbBVNBL4jbiL3i3xsfNiyJgaZ5sX7i8tmStEpLbPwvHcByuf59qJhV/bZOl8KqJBETCDJcY6O2aqhTUy+9x93ThKs1GKrRPePrWPluud7ttlgtRveit/pcBrnQcXOl1rHq7ByB8CFAxNotRUYL9IF5n3wJOgkPojMy6jetQA5Ogc8Sm7RG6vg1yow== 3.看看有没有激活打开PyCharm后，点击顶部操作按钮“help”，选择“Register”，如下图： 点击“Register”后，就可以看见注册情况了]]></content>
      <categories>
        <category>pycharm</category>
      </categories>
      <tags>
        <tag>pycharm激活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo的next主题详细配置]]></title>
    <url>%2F2018%2F11%2F02%2Fhexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E8%AF%A6%E7%BB%86%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 为了描述方便，在以下说明中，将前者称为站点配置文件， 后者称为主题配置文件。 以下所有终端执行的命令都在你的Hexo根目录下 基本信息配置打开 站点配置文件 ，找到Site模块 123456title: 标题subtitle: 副标题description: 描述author: 作者language: 语言（简体中文是zh-Hans）timezone: 网站时区（Hexo 默认使用您电脑的时区，不用写） 关于 站点配置文件 中的其他配置可参考站点配置 菜单设置菜单包括：首页、归档、分类、标签、关于等等 我们刚开始默认的菜单只有首页和归档两个，不能够满足我们的要求，所以需要添加菜单，打开 主题配置文件 找到Menu Settings 看看你需要哪个菜单就把哪个取消注释打开就行了； 关于后面的格式，以archives: /archives/ || archive为例： || 之前的/archives/表示标题“归档”，关于标题的格式可以去themes/next/languages/zh-Hans.yml中参考或修改 ||之后的archive表示图标，可以去Font Awesome中查看或修改，Next主题所有的图标都来自Font Awesome Next主题样式设置我们百里挑一选择了Next主题，不过Next主题还有4种风格供我们选择，打开 主题配置文件 找到Scheme Settings 12345# Schemes# scheme: Muse# scheme: Mist# scheme: Piscesscheme: Gemini 4种风格大同小异，本人用的是Gemini风格，你们可以选择自己喜欢的风格 侧栏设置开启侧边栏社交链接1234567891011# Social linkssocial: GitHub: https://github.com/hydcoder Weibo: https://weibo.com/3180967953/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo # 等等social_icons: enable: true # Icon Mappings. GitHub: github Weibo: weibo 开启打赏功能123reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！wechatpay: 你的微信收款码链接alipay: 你的支付宝收款码链接 开启友情链接1234links_title: Linkslinks: MacTalk: http://macshuo.com/ Title: http://example.com/ 开启订阅微信公众号1234wechat_subscriber:enabled: trueqcode: /uploads/wechat-qcode.jpgdescription: 欢迎您扫一扫上面的微信公众号，订阅我的博客！ 头像设置打开 主题配置文件 找到Sidebar Avatar字段 12# Sidebar Avataravatar: /images/header.jpg 这是头像的路径，只需把你的头像命名为header.jpg（随便命名）放入themes/next/source/images中，将avatar的路径名改成你的头像名就OK啦！ 设置侧边栏设置圆形可旋转头像 找到生成的Hexo目录\themes\next\source\css_common\components\sidebar下的sidebar-author.styl，将里面的css样式内容全部替换为： 123456789101112131415161718192021222324252627282930313233.site-author-image &#123; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; border-radius: 50%; -webkit-border-radius: 50%; -moz-border-radius: 50%; transition: 1.4s all;&#125;.site-author-image:hover &#123; -webkit-transform: rotate(360deg); -moz-transform: rotate(360deg); -ms-transform: rotate(360deg); -transform: rotate(360deg);&#125;.site-author-name &#123; margin: $site-author-name-margin; text-align: $site-author-name-align; color: $site-author-name-color; font-weight: $site-author-name-weight;&#125;.site-description &#123; margin-top: $site-description-margin-top; text-align: $site-description-align; font-size: $site-description-font-size; color: $site-description-color;&#125; 设置首页不显示全文(只显示预览)打开主题配置文件_config.yml，ctrl + F搜索找到”auto_excerpt”，可以看见 12345# Automatically Excerpt. Not recommand.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt:enable: falselength: 150 把enable改为对应的false改为true，length就是预览显示的文字长度，你可以根据你的需要进行更改，然后重新部署，再进主页，你就发现你首页的文章多了一个阅读全文的按钮。 添加动态背景先上张图 打开生成的Hexo目录\themes\next/layout/_layout.swig文件，在 &lt; head&gt;中的添加代码 123&#123;% if theme.canvas_nest %&#125;&lt;script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"&gt;&lt;/script&gt;&#123;% endif %&#125; 打开主题配置文件，搜索canvas_nest，将其改成true 1canvas_nest: true 什么？线条太多了？没事，来看看怎么让线条变少点 在上一步修改的主题配置文件中，把刚才的那些代码改成下面这样： 1234&#123;% if theme.canvas_nest %&#125;&lt;script type="text/javascript"color="0,0,255" opacity='0.7' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"&gt;&lt;/script&gt;&#123;% e 配置项说明 color ：线条颜色, 默认: ‘0,0,0’；三个数字分别为(R,G,B) opacity: 线条透明度（0~1）, 默认: 0.5 count: 线条的总数量, 默认: 150 zIndex: 背景的z-index属性，css属性用于控制所在层的位置, 默认: -1 分类和标签设置这里主要说的是在编写文章的时候，怎么给文章设置标签和分类。 首先通过hexo n &quot;name&quot;命令来新建一个页面，在source/_posts目录下找到刚才新建的name.md文件，用Typora或者notepad++t打开(推荐Typora) 1234title: namedate: 2014-08-05 11:15:00 tags: --- 页面默认就是长这样的，可以编辑标题、日期、标签和内容，但是没有分类的选项。我们可以手动加入categories:项,但是下次创建新的页面的时候还是没有，所以我们直接打开scaffolds/post.md文件，在tages:上面加入categories:,保存后，重新执行hexo n ‘name’命令，会发现新建的页面里有categories:项了。 scaffolds目录下，是新建页面的模板，执行新建命令时，是根据这里的模板页来完成的，所以可以在这里根据你自己的需求添加一些默认值。 设置分类列表在我们编辑文章的时候，直接在categories:项填写属于哪个分类，但如果分类是中文的时候，路径也会包含中文。 比如分类我们设置的是： 1categories: 开车 那在生成页面后，分类列表就会出现开车这个选项，他的访问路径是： 1*/categories/开车 我们都知道，有时候中文路径可能会出现一些奇奇怪怪的问题，所以我们需要路径名和分类名分别设置。 打开站点配置文件_config.yml，找到如下位置做更改： 1234567# Category &amp; Tagdefault_category: uncategorizedcategory_map: 开车: drive 生活: life 其他: othertag_map: 在这里category_map:是设置分类的地方，每行一个分类，冒号前面是分类名称，后面是访问路径。可以提前在这里设置好一些分类，当编辑的文章填写了对应的分类名时，就会自动的按照对应的路径来访问。 设置标签在编辑文章的时候，tags:后面是设置标签的地方，如果有多个标签的话，可以用下面两种办法来设置： 第一种： 1tages: [标签1,标签2,...标签n] 第二种： 12345 tages: - 标签1- 标签2...- 标签n 添加文章更新时间修改（博客主目录）/themes/next/layout/_macro/post.swig 文件，在&lt;span class=&quot;post-time&quot;&gt;...&lt;/span&gt;标签后添加 12345678&#123;%if post.updated and post.updated &gt; post.date%&#125; &lt;span class="post-updated"&gt; &amp;nbsp; | &amp;nbsp; &#123;&#123; __('post.updated') &#125;&#125; &lt;time itemprop="dateUpdated" datetime="&#123;&#123; moment(post.updated).format() &#125;&#125;" content="&#123;&#123; date(post.updated, config.date_format) &#125;&#125;"&gt; &#123;&#123; date(post.updated, config.date_format) &#125;&#125; &lt;/time&gt; &lt;/span&gt;&#123;% endif %&#125; 根据博客配置文件中的 language 参数修改对应的语言配置文件（博客主目录）/themes/next/languages/zh_Hans.yml 12post: updated: 更新于 修改主题配置文件（博客主目录）/themes/next/_config.yml，增加一行 1display_updated: true 或者写文章的时候可以直接在文章开头设置更新时间，没有这参数的话将会显示md文件的修改日期 1updated: 2018-01-01 12:00:00 添加搜索功能安装 hexo-generator-searchdb 插件 1$ npm install hexo-generator-searchdb --save 打开 站点配置文件 找到Extensions在下面添加 123456# 搜索search: path: search.xml field: post format: html limit: 10000 3、打开 主题配置文件 找到Local search，将enable设置为true 添加阅读全文按钮因为在你的博客主页会有多篇文章，如果你想让你的文章只显示一部分，多余的可以点击阅读全文来查看，那么你需要在你的文章中添加 1&lt;!--more--&gt; 其后面的部分就不会显示了，只能点击阅读全文才能看 修改文章内链接文本样式打开文件 themes/next/source/css/_common/components/post/post.styl，在末尾添加 12345678910.post-body p a &#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125; 其中选择 .post-body 是为了不影响标题，选择 p 是为了不影响首页“阅读全文”的显示样式,颜色可以自己定义。 设置网站缩略图标从网上看了很多设置方法都是说把favicon.ico放到站点目录的source目录下就可以了，可是我试了好多遍，并不行 我的设置方法是这样的：把你的图片（png或jpg格式，不是favicon.ico）放在themes/next/source/images里，然后打开 主题配置文件 找到favicon，将small、medium、apple_touch_icon三个字段的值都设置成/images/图片名.jpg就可以了，其他字段都注释掉。 设置文章字体的颜色、大小 如果想设置某一句的颜色或大小，只需用html语法写出来就行了 1234接下来就是见证奇迹的时刻&lt;font color="#FF0000"&gt; 我可以设置这一句的颜色哈哈 &lt;/font&gt; &lt;font size=6&gt; 我还可以设置这一句的大小嘻嘻 &lt;/font&gt; &lt;font size=5 color="#FF0000"&gt; 我甚至可以设置这一句的颜色和大小呵呵&lt;/font&gt; 设置文字居中1&lt;center&gt;这一行需要居中&lt;/center&gt; 添加评论系统目前国内比较有名的多说、网易云跟帖评论系统都已停止服务了，国外的Disqus评论系统还得需要翻墙，所以不推荐使用，剩下的还有搜狐畅言、友言、来必力等。本来想使用畅言的，结果注册完之后还得要求备案，我只想说F开头的那个单词，果断放弃。后来选择了友言 1、进入友言官网注册、登录步骤我就不介绍了2、登录完成之后，点击获取代码，你会发现出来了一段代码，里面有你的uid=12345673、打开 主题配置文件 找到youyan_uid将值设置为上面的uid就可以了 添加站点访问计数站点访问计数有名的就是不蒜子，使用起来非常方便1、安装脚本打开 themes/next/layout/_partial/footer.swig，将下面这段代码添加到里面 12345678910&lt;div&gt;&lt;script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt;&lt;span id="busuanzi_container_site_pv" style='display:none'&gt; 本站总访问量 &lt;span id="busuanzi_value_site_pv"&gt;&lt;/span&gt; 次 &lt;span class="post-meta-divider"&gt;|&lt;/span&gt;&lt;/span&gt;&lt;span id="busuanzi_container_site_uv" style='display:none'&gt; 有&lt;span id="busuanzi_value_site_uv"&gt;&lt;/span&gt;人看过我的博客啦&lt;/span&gt;&lt;/div&gt; 添加的位置如下图，可自行根据个人喜好更换位置 2、以上只是显示站点的访问次数，如果想显示每篇文章的访问次数，打开 themes/next/layout/_macro/post.swig，在第一行增加is_pv字段 1&#123;% macro render(post, is_index, is_pv, post_extra_class) %&#125; 然后将这段代码插入到里面 1234&#123;% if is_pv %&#125; &lt;span class="post-meta-divider"&gt;|&lt;/span&gt; &lt;span id="busuanzi_value_page_pv"&gt;&lt;/span&gt;次阅读&#123;% endif %&#125; 插入的位置 然后再打开 themes/next/layout/post.swig，这个文件是文章的模板，给render方法传入参数（对应刚才添加的is_pv字段） 最后再打开 themes/next/layout/index.swig，这个文件是首页的模板，给render方法传入参数（对应刚才添加的is_pv字段） OK！设置完毕 去掉文章目录标题的自动编号我们自己写文章的时候一般都会自己带上标题编号，但是默认的主题会给我们带上编号，很是别扭，如何去掉呢？打开主题配置文件，找到 123456789# Table Of Contents in the Sidebartoc: enable: true # Automatically add list number to toc. number: true # If true, all words will placed on next lines if header width longer then sidebar width. wrap: false 将number改为false即可 自定义样式 引用需加入custom.styl的代码 文件位置：~/blog/themes/next/source/css/_custom/custom.styl 123456789// 自定义的引用样式blockquote.question &#123; color: #555; border-left: 4px solid rgb(16, 152, 173); background-color: rgb(227, 242, 253); border-top-right-radius: 3px; border-bottom-right-radius: 3px; margin-bottom: 20px;&#125; 文字颜色改color的值 背景色改background-color的值 边框颜色和粗细改border-left的值 效果： 内容 使用方法： 1&lt;blockquote class="question"&gt;内容&lt;/blockquote&gt; 修改hexo的主题nexT中的Pisces主题宽度在source/css/_schemes/Picses/_layout.styl文件末尾添加如下代码 12345678910111213141516171819202122232425262728293031323334// 以下为新增代码！！header&#123; width: 90% !important; &#125;header.post-header &#123; width: auto !important;&#125;.container .main-inner &#123; width: 90%; &#125;.content-wrap &#123; width: calc(100% - 260px); &#125;.header &#123; +tablet() &#123; width: auto !important; &#125; +mobile() &#123; width: auto !important; &#125;&#125;.container .main-inner &#123; +tablet() &#123; width: auto !important; &#125; +mobile() &#123; width: auto !important; &#125;&#125;.content-wrap &#123; +tablet() &#123; width: 100% !important; &#125; +mobile() &#123; width: 100% !important; &#125;&#125; 更多还有其他更多的主题配置，请查看主题配置 还有其他更多的插件，请查看Hexo插件]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>next主题配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何更换hexo博客主题]]></title>
    <url>%2F2018%2F11%2F01%2F%E5%A6%82%E4%BD%95%E6%9B%B4%E6%8D%A2hexo%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%2F</url>
    <content type="text"><![CDATA[在成功用github+hexo搭建好个人博客之后，原生的主题一般不大讨喜。在此，简单介绍一下如何找一个自己喜欢的主题并运用到自己的博客中： 挑个好看的主题hexo官方：Themes 知乎话题：有哪些好看的 Hexo 主题？ 下载用git bash，进入到博客的本地目录中 然后使用clone的方法将想要的主题下载下来。（我选用的是NexT主题） 1$ git clone https://github.com/theme-next/hexo-theme-next themes/next 修改配置文件，安装git克隆完成后，打开当前目录下的“_config.yml”配置文件。 找到theme的配置选项，一般在文件的最后。之后，将theme选项配置为我们新下载好的next主题即可。（“：”冒号之后空格不可少） 调试，发布回到git bash，输入调试命令： 1hexo server --debug 在浏览器中输入localhost:4000查看 在本地查看无误之后，输入生成和发布命令,就可已将新主题发布到自己的博客网站上了 12hexo ghexo d 如出现缓存引起的异常，可以在生成命令前执行清除缓存命令 1hexo clean 完成做完这些之后，就可以打开你的博客网站，查看新更换的主题效果了。]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>hexo更换主题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用hexo+github搭建属于自己的博客]]></title>
    <url>%2F2018%2F11%2F01%2F%E4%BD%BF%E7%94%A8hexo-github%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[一、注册GitHub账号（已经有GitHub账号的请忽略这一步）先在Github注册一个账号:https://github.com/ 新建项目，项目必须要遵守格式：账户名.github.io，不然接下来会有很多麻烦。并且需要勾选Initialize this repository with a README 在建好的项目右侧有个settings按钮，点击它，向下拉到GitHub Pages，你会看到那边有个网址，访问它，你将会发现该项目已经被部署到网络上，能够通过外网来访问它。 二、环境搭建下载Node.js安装文件现在电脑基本都是64位的，我就放64位的下载地址：https://nodejs.org/dist/v8.9.4/node-v8.9.4-x64.msi 或者自行到官网下载最新版本： https://nodejs.org 安装Git：Git下载包（64位） Git下载包（32位） 完成之后到桌面空白处单击鼠标右键，选择Git Bash Here进入bash窗口输入命令 node -v 和 npm -v 验证安装是否成功,成功界面如下 三、Hexo安装Hexo简介Hexo是什么呢？也许引用Hexo官方文档里面的说明是再好不过了： 1Hexo is a fast, simple and powerful blog framework. You write posts in Markdown (or other languages) and Hexo generates static files with a beautiful theme in seconds. 1Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装Git下载地址：https://git-scm.com/download，按照默认傻瓜式安装就好了 补充一句，如果你已经安装了Git，你可以通过Git本身获得最新的开发版本： 1$ git clone https://github.com/git/git 完成之后到桌面空白处单击鼠标右键，如果有出现Git Bash Here选项则证明已经安装成功 下载Hexo在桌面空白处单击鼠标右键，选择Git Bash Here进入bash窗口，在自己认为合适的地方创个文件夹，我是在D盘建了一个blog文件夹。然后通过命令行进入到该文件夹里面 再输入命令 npm install -g hexo 下载Hexo 1$ npm install -g hexo 等待完成之后，输入命令 hexo -v 验证安装是否成功 初始化输入hexo init，初始化该文件夹 输入npm install，安装所需要的组件 输入hexo g，首次体验Hexo 输入hexo s，开启服务器，访问该网址，正式体验Hexo 问题：假如页面一直无法跳转，那么可能4000端口被占用了。此时我们ctrl+c停止服务器，接着输入hexo server -p 端口号来改变端口号 那么出现如下图就成功了 四、将Hexo与Github page联系起来安装插件打开git bash，进入hexo根文件夹，输入npm install hexo-deployer-git --save 命令安装插件 配置SSH设置全局配置user.name 和user.email（如果是第一次的话） 12git config –-global user.name “shuaibi” //(“”的账号是刚才Github里面自己注册的账号) git config –-global user.email “okjbk.gmail.com” //(""的邮箱是你自己注册的邮箱) 输入cd ~/.ssh，检查是否有.ssh的文件夹 输入ssh-keygen -t rsa -C &quot;ojbk.gmail.com&quot;(&quot;&quot;中间写你直接设置的邮箱)，连续三个回车，生成密钥，最后得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\Users\Administrator.ssh）。 输入eval &quot;$(ssh-agent -s)&quot;，添加密钥到ssh-agent 再输入ssh-add ~/.ssh/id_rsa，添加生成的SSH key到ssh-agent 登录Github，点击头像下的settings，添加ssh 新建一个new ssh key，将id_rsa.pub文件里的内容复制上去 回到git bash 输入ssh -T git@github.com，测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明成功了 问题: 假如ssh-key配置失败，那么只要以下步骤就能完全解决 首先，清除所有的key-pairssh-add -Drm -r ~/.ssh删除你在github中的public-key 重新生成ssh密钥对ssh-keygen -t rsa -C “xxx@xxx.com“ 接下来正常操作在github上添加公钥public-key:1、首先在你的终端运行 xclip -sel c ~/.ssh/id_rsa.pub将公钥内容复制到剪切板2、在github上添加公钥时，直接复制即可3、保存 测试： 在终端 ssh -T git@github.com 配置配置Deployment，在根文件夹中，找到_config.yml文件，修改repo值（在末尾） 1234deploy: type: git repository: git@github.com:RobotNo42/RobotNo42.github.io.git branch: master repo值是你在github项目里的ssh（右下角） 部署用git bash部署hexo到github hexo server 或者 hexo s hexo generate 或者 hexo g hexo deploy 或者 hexo d 看到这样的进程，代表成功部署hexo到github 等待10分钟左右，打开用户名.github.io,会出现如下界面（代表成功搭建博客）： 五、绑定自己域名申请域名自己去阿里云或者腾讯云等网站购买域名 解析域名添加如下的解析得到域名之后，到控制台进行解析控制台-&gt;域名-&gt;域名列表-&gt;解析 在腾讯云控制台，设置主机记录www，记录类型为A，记录值是IP185.199.111.153。其中185.199.111.153是Github Pages服务器指定的IP地址，访问该IP地址即表示访问Github Pages。 在阿里云控制台，设置主机记录@，记录类型为CNAME，记录值是robotno42.github.io。表示将http://messilessblog.com这个主域名映射robotno42.github.io 如何知道知道的 Github Pages IP在命令提示符中输入ping -4 robotno42.github.io 配置 在博客的source文件夹下建立一个CNAME的文件 内容写入你的域名信息，比如我这里是messilessblog.com 打开博客下的_config.yml文件 123456# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: https://messilessblog.comroot: /permalink: :year/:month/:day/:title/permalink_defaults: 将url后面改成自己的域名地址，注意！不这样做每次提交github那边都要重新设置自定义域名 Github 设置进入博客-&gt;点击Setting，找到 Custom domain 添加域名后保存即可]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>hexo+github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python面试题汇总]]></title>
    <url>%2F2018%2F10%2F06%2Fpython%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[Python基础 1、文件操作 1.1、有一个jsonline格式的文件file.txt大小约为10K 1.2、补充缺失的代码？ 2、模块与包 2.1输入日期，判断这一天是这一年的第几天？ 2.2打乱一个排好序的list对象 alist？ 3、数据类型 3.1、现有字典 d={‘a’:24，‘g’:52，‘i’:12，‘k’:33}请按value值进行 3.2、字典推导式？ 3.3、请反转字符串“aStr”? 3.4、将字符串”k:1|k1:2|k2:3|k3:4”，处理成字典：{k:1， k1:2， … 3.5、请按alist中元素的age由大到小排序 3.6下面代码的输出结果将是什么？ 3.7、写一个列表生成式，产生一个公差为11的等差数列 3.8、给定两个列表，怎么找出他们相同的元素和不同的元素? 3.9、请写出一段Python代码实现删除一个list里面的重复元素? 3.10、给定两个list A ,B，请用找出 A ,B中相同与不同的元素 4、企业面试题 4.1、Python新式类和经典类的区别？ 4.2、python中内置的数据结构有几种？ 4.3、Python如何实现单例模式？请写出两种实现方法 4.4、反转一个整数，例如-123–&gt;-321,Python语言实现 4.5、设计实现遍历目录与子目录，抓取.pyc文件 4.6、一行代码实现1-100之和 4.7、Python-遍历列表时删除元素的正确做法 4.8、字符串的操作题目 4.9、可变类型和不可变类型 4.10、is和==有什么区别？ 4.11、求出列表所有奇数并构造新列表 4.12、用一行python代码写出1+2+3+10248 4.13、Python中变量的作用域？（变量查找顺序） 4.14、字符串”123″转换成123，不使用内置api，例如int（） 4.15、Given an array of integers 4.16、python代码实现删除一个list里面的重复元素 4.17、统计一个文本中单词频次最高的10个单词？ 4.18、请写出一个函数满足以下条件 4.19、使用单一的列表生成式来产生一个新的列表 4.20、用一行代码生成[1,4,9,16,25,36,49,64,81,100] 4.21、输入某年某月某日，判断这一天是这一年的第几天？ 4.22、两个有序列表，l1,l2，对这两个列表进行合并不可使用extend 4.23、给定一个任意长度数组，实现一个函数 4.23、写一个函数找出一个整数数组中，第二大的数 4.24、阅读一下代码他们的输出结果是什么？ 4.25、统计一段字符串中字符出现的次数 4.26、super函数的具体用法和场景 二、Python高级 1、元类 1.1、Python中类方法、类实例方法、静态方法有何区别？ 1.2、super函数的具体用法和场景？ 1.3、历一个object的所有属性，并print每一个属性名？ 1.4、写一个类，并让它尽可能多的支持操作符？ 1.5、介绍Cpython，Pypy Cpython Numba各有什优缺点 1.6、请描述抽象类和接口类的区别和联系？ 1.7、Python中如何动态获取和设置对象的属性？ 2、内存管理与垃圾回收机制 2.1、哪些操作会导致Python内存溢出，怎么处理？ 2.2、关于 Python内存管理,下列说法错误的是(B) 2.3、Python的内存管理机制及调优手段？ 2.4、内存泄露是什么？如何避免？ 3、函数 3.1、python常见的列表推导式？ 3.2、简述read、readline、readlines的区别？ 3.3、什么是Hash（散列函数）？ 3.4、python函数重载机制？ 3.5、写一个函数找出一个整数数组中，第二大的数 3.6、手写一个判断时间的装饰器 3.7、使用Python内置的filter()方法来过滤？ 3.8、编写函数的4个原则 3.9、函数调用参数的传递方式是值传递还是引用传递？ 3.10、如何在function里面设置一个全局变量 3.11、对缺省参数的理解 ？ 3.12、Mysql怎么限制IP访问？ 3.13、带参数的装饰器? 3.14、为什么函数名字可以当做参数用? 3.15、Python中pass语句的作用是什么？ 3.16、有这样一段代码，print c会输出什么，为什么？ 3.17、交换两个变量的值？ 3.18、map函数和reduce函数？ 3.19、回调函数，如何通信的? 3.20、Python主要的内置数据类型都有哪些？ print dir( ‘a ’) 的输出？ 3.21、map(lambda x:xx，[y for y in range(3)])的输出？ 3.22、 hasattr() getattr() setattr() 函数使用详解？ 3.23、一句话解决阶乘函数？ 3.24、什么是lambda函数？ 有什么好处？ 3.25、递归函数停止的条件？ 3.26、下面这段代码的输出结果将是什么？请解释。 3.27、什么是lambda函数？它有什么好处？写一个匿名函数求两个数的 4、设计模式 4.1、对设计模式的理解，简述你了解的设计模式？ 4.2、请手写一个单例 4.3、单例模式的应用场景有哪些？ 4.4、Python 如何实现单例模式？请写出两种实现方法？ 4.5、对装饰器的理解 ，并写出一个计时器记录方法执行性能的装饰器？ 4.6、解释一下什么是闭包? 4.7、函数装饰器有什么作用？ 4.8、生成器、迭代器的区别？ 4.9 X是什么类型？ 4.10、请用“一行代码”实现将1-N的整数列表以3为单位分组 4.11、Python中yield的用法？ 5、面向对象 5.1、Python中的可变对象和不可变对象？ 5.2、 5.3、Python的魔法方法 5.4、面向对象中怎么实现只读属性? 5.5、谈谈你对面向对象的理解？ 6、正则表达式 6.1、请写出一段代码用正则匹配出ip？ 6.2、a = “abbbccc”，用正则匹配为abccc,不管有多少b，就出现一次？ 6.3、Python字符串查找和替换？ 6.4、 用Python匹配HTML g tag的时候，&lt;.&gt; 和 &lt;.*?&gt; 有什么区别 6.5、正则表达式贪婪与非贪婪模式的区别？ 6.6、写出开头匹配字母和下划线，末尾是数字的正则表达式？ 6.7、正则表达式操作 6.8、请匹配出变量A 中的json字符串。 6.9、怎么过滤评论中的表情？ 6.10、简述Python里面search和match的区别 6.11、请写出匹配ip的Python正则表达式 6.12、Python里match与search的区别？ 7、系统编程 7.1、 进程总结 7.2、 谈谈你对多进程，多线程，以及协程的理解，项目是否用？ 7.3、 Python异步使用场景有那些？ 7.4、 多线程共同操作同一个数据互斥锁同步？ 7.5、 什么是多线程竞争？ 7.6、 请介绍一下Python的线程同步？ 7.7、 解释一下什么是锁，有哪几种锁? 7.8、 什么是死锁呢？ 7.9、 多线程交互访问数据，如果访问到了就不访问了 7.10、什么是线程安全，什么是互斥锁？ 7.11、说说下面几个概念：同步，异步，阻塞，非阻塞? 7.12、什么是僵尸进程和孤儿进程？怎么避免僵尸进程? 7.13、Python中的进程与线程的使用场景? 7.14、线程是并发还是并行，进程是并发还是并行？ 7.15、并行（parallel）和并发（concurrency）？ 7.16、IO密集型和CPU密集型区别？ 7.17 python asyncio的原理？ 8、网络编程 8.1、怎么实现强行关闭客户端和服务器之间的连接? 8.2、简述TCP和UDP的区别以及优缺点? 8.3、简述浏览器通过WSGI请求动态资源的过程? 8.4、描述用浏览器访问www.baidu.com的过程 8.5、Post和Get请求的区别? 8.6、cookie 和session 的区别？ 8.7、列出你知道的HTTP协议的状态码，说出表示什么意思？ 8.8、请简单说一下三次握手和四次挥手？ 8.9、说一下什么是tcp的2MSL？ 8.10、为什么客户端在TIME-WAIT状态必须等待2MSL的时间？ 8.11、说说HTTP和HTTPS区别？ 8.12、谈一下HTTP协议以及协议头部中表示数据类型的字段？ 8.13、HTTP请求方法都有什么？ 8.14、使用Socket套接字需要传入哪些参数 ？ 8.15、HTTP常见请求头？ 8.16、七层模型？ 8.17、url的形式？ 三、Web 1、Flask 1.1、对Flask蓝图(Blueprint)的理解？ 1.2、Flask和Django路由映射的区别？ Django 2.1、什么是wsgi,uwsgi,uWSGI？ 2.2、CORS和CSRF的区别？ 2.3、Session、Cookie、JWT的理解 2.4、简述Django请求生命周期 2.5、Django 、Flask、Tornado的对比 2.6、用的restframework完成api发送时间时区 2.7、nginx,tomcat,apache 都是什么? 2.8、请给出你熟悉关系数据库范式有那些，有什么作用 2.9、简述QQ登陆过程 2.10、post和get 的区别？ 2.11、项目中日志的作用 2.12、django中间件的使用？ 2.13、谈一下你对uWSGI和 nginx的理解？ 2.14、Python中三大框架各自的应用场景？ 2.15、Django中哪里用到了线程?哪里用到了协程?哪里用到了进程？ 2.16、有用过Django REST framework 吗？ 2.17、对cookie与session的了解？他们能单独用吗？ 爬虫 1.1、试列出至少三种目前流行的大型数据库 1.2、列举您使用过的Python网络爬虫所用到的网络数据包? 1.3、列举您使用过的Python网络爬虫所用到的解析数据包？ 1.4、爬取数据后使用哪个数据库存储数据的，为什么？ 1.5、你用过的爬虫框架或者模块有哪些？优缺点？ 1.6、写爬虫是用多进程好？还是多线程好？ 1.7、常见的反爬虫和应对方法？ 1.8、解析网页的解析器使用最多的是哪几个? 1.9、需要登录的网页，如何解决同时限制ip，cookie,session 1.10、验证码的解决? 1.11、使用最多的数据库，对他们的理解？ 1.12、编写过哪些爬虫中间件？ 1.13、“极验”滑动验证码如何破解？ 1.14、爬虫多久爬一次，爬下来的数据是怎么存储？ 1.15、cookie过期的处理问题？ 1.16、动态加载又对及时性要求很高怎么处理？ 1.17、HTTPS有什么优点和缺点？ 1.18、HTTPS是如何实现安全传输数据的？ 1.19、TTL，MSL，RTT各是什么？ 1.20、谈一谈你对Selenium和PhantomJS了解 1.21、平常怎么使用代理的 ？ 1.22、存放在数据库(redis、mysql等)。 1.23、怎么监控爬虫的状态? 1.24、描述下scrapy框架运行的机制？ 1.25、谈谈你对Scrapy的理解？ 1.26、怎么样让 scrapy 框架发送一个 post 请求（具体写出来） 1.27、怎么监控爬虫的状态 ？ 1.28、怎么判断网站是否更新？ 1.29、图片、视频爬取怎么绕过防盗连接 1.30、你爬出来的数据量大概有多大？大概多长时间爬一次？ 1.31、用什么数据库存爬下来的数据？部署是你做的吗？怎么部署？ 1.32、增量爬取 1.33、爬取下来的数据如何去重，说一下scrapy的具体的算法依据。 1.34、Scrapy的优缺点? 1.35、怎么设置爬取深度？ 1.36、scrapy和scrapy-redis有什么区别？为什么选择redis数据库？ 1.37、分布式爬虫主要解决什么问题？ 1.38、什么是分布式存储？ 1.39、你所知道的分布式爬虫方案有哪些？ 1.40、scrapy-redis，有做过其他的分布式爬虫吗？ 五、数据库 1、MySQL 1.1、主键 超键 候选键 外键 1.2、视图的作用，视图可以更改么？ 1.3、drop,delete与truncate的区别 1.4、索引的工作原理及其种类 1.5、连接的种类 1.6、数据库优化的思路 1.7、存储过程与触发器的区别 1.8、悲观锁和乐观锁是什么？ 1.9、你常用的mysql引擎有哪些?各引擎间有什么区别? 2、Redis 2.1、Redis宕机怎么解决? 2.2、redis和mecached的区别，以及使用场景 2.3、Redis集群方案该怎么做?都有哪些方案? 2.4、Redis回收进程是如何工作的 3、MongoDB 3.1、MongoDB中对多条记录做更新操作命令是什么？ 3.2、MongoDB如何才会拓展到多个shard里？ 六、测试 1、编写测试计划的目的是 2、对关键词触发模块进行测试 3、其他常用笔试题目网址汇总 4、测试人员在软件开发过程中的任务是什么 5、一条软件Bug记录都包含了哪些内容？ 6、简述黑盒测试和白盒测试的优缺点 7、请列出你所知道的软件测试种类，至少5项。 8、Alpha测试与Beta测试的区别是什么？ 9、举例说明什么是Bug？一个bug report应包含什么关键字？ 数据结构 1.1、数组中出现次数超过一半的数字-Python版 1.2、求100以内的质数 1.3、无重复字符的最长子串-Python实现 1.4、通过2个5/6升得水壶从池塘得到3升水 1.5、什么是MD5加密，有什么特点？ 1.6、什么是对称加密和非对称加密 1.7、冒泡排序的思想？ 1.8、快速排序的思想？ 1.9、如何判断单向链表中是否有环？ 1.10、你知道哪些排序算法（一般是通过问题考算法） 1.11、斐波那契数列 1.12、如何翻转一个单链表？ 1.13、青蛙跳台阶问题 1.14、两数之和 Two Sum 1.15、搜索旋转排序数组 Search in Rotated Sorted Array 1.16、Python实现一个Stack的数据结构 1.17、写一个二分查找 1.18、set 用 in 时间复杂度是多少，为什么？ 1.19、列表中有n个正整数范围在[0，1000]，进行排序； 1.20、面向对象编程中有组合和继承的方法实现新的类 八、人工智能 1.1、找出1G的文件中高频词 1.2、一个大约有一万行的文本文件统计高频词 1.3、怎么在海量数据中找出重复次数最多的一个？ 1.4、判断数据是否在大量数据中 Python基础1.1 有一个jsonline格式的文件file.txt 大小约为10K1234567def get_lines(): with open('file.txt','rb') as f: return f.readlines()if __name__ == '__main__': for e in get_lines(): process(e) #处理每一行数据 现在要处理一个大小为10G的文件，但是内存只有4G，如果在只修改get_lines 函数而其他代码保持不变的情况下，应该如何实现？需要考虑的问题都有那些？ 1234def get_lines(): with open('file.txt','rb') as f: for i in f: yield i Pandaaaa906提供的方法 123456789101112131415from mmap import mmapdef get_lines(fp): with open(fp,"r+") as f: m = mmap(f.fileno(), 0) tmp = 0 for i, char in enumerate(m): if char==b"\n": yield m[tmp:i+1].decode() tmp = i+1if __name__=="__main__": for i in get_lines("fp_some_huge_file"): print(i) 要考虑的问题有：内存只有4G无法一次性读入10G文件，需要分批读入分批读入数据要记录每次读入数据的位置。分批每次读取数据的大小，太小会在读取操作花费过多时间。https://stackoverflow.com/questions/30294146/python-fastest-way-to-process-large-file 1.2 补充缺失的代码12345678910111213def print_directory_contents(sPath):"""这个函数接收文件夹的名称作为输入参数返回该文件夹中文件的路径以及其包含文件夹中文件的路径"""import osfor s_child in os.listdir(s_path): s_child_path = os.path.join(s_path, s_child) if os.path.isdir(s_child_path): print_directory_contents(s_child_path) else: print(s_child_path) 模块与包2.1 输入日期， 判断这一天是这一年的第几天？12345678import datetimedef dayofyear(): year = input("请输入年份: ") month = input("请输入月份: ") day = input("请输入天: ") date1 = datetime.date(year=int(year),month=int(month),day=int(day)) date2 = datetime.date(year=int(year),month=1,day=1) return (date1-date2).days+1 2.2 打乱一个排好序的list对象alist？1234import randomalist = [1,2,3,4,5]random.shuffle(alist)print(alist) 数据类型3.1 现有字典 d= {‘a’:24,’g’:52,’i’:12,’k’:33}请按value值进行排序?1sorted(d.items(),key=lambda x:x[1]) 3.2 字典推导式1d = &#123;key:value for (key,value) in iterable&#125; 3.3 请反转字符串 “aStr”?1print("aStr"[::-1]) 3.4 将字符串 “k:1 |k1:2|k2:3|k3:4”，处理成字典 {k:1,k1:2,…}1234567str1 = "k:1|k1:2|k2:3|k3:4"def str2dict(str1): dict1 = &#123;&#125; for iterms in str1.split('|'): key,value = iterms.split(':') dict1[key] = value return dict1 3.5 请按alist中元素的age由大到小排序123alist = [&#123;'name':'a','age':20&#125;,&#123;'name':'b','age':30&#125;,&#123;'name':'c','age':25&#125;]def sort_by_age(list1): return sorted(alist,key=lambda x:x['age'],reverse=True) 3.6 下面代码的输出结果将是什么？12list = ['a','b','c','d','e']print(list[10:]) 代码将输出[],不会产生IndexError错误，就像所期望的那样，尝试用超出成员的个数的index来获取某个列表的成员。例如，尝试获取list[10]和之后的成员，会导致IndexError。然而，尝试获取列表的切片，开始的index超过了成员个数不会产生IndexError，而是仅仅返回一个空列表。这成为特别让人恶心的疑难杂症，因为运行的时候没有错误产生，导致Bug很难被追踪到。 3.7 写一个列表生成式，产生一个公差为11的等差数列1print([x*11 for x in range(10)]) 3.8 给定两个列表，怎么找出他们相同的元素和不同的元素？123456list1 = [1,2,3]list2 = [3,4,5]set1 = set(list1)set2 = set(list2)print(set1 &amp; set2)print(set1 ^ set2) 3.9 请写出一段python代码实现删除list里面的重复元素？123l1 = ['b','c','d','c','a','a']l2 = list(set(l1))print(l2) 用list类的sort方法: 1234l1 = ['b','c','d','c','a','a']l2 = list(set(l1))l2.sort(key=l1.index)print(l2) 也可以这样写: 123l1 = ['b','c','d','c','a','a']l2 = sorted(set(l1),key=l1.index)print(l2) 也可以用遍历： 123456l1 = ['b','c','d','c','a','a']l2 = []for i in l1: if not i in l2: l2.append(i)print(l2) 3.10 给定两个list A，B ,请用找出A，B中相同与不同的元素12A,B 中相同元素： print(set(A)&amp;set(B))A,B 中不同元素: print(set(A)^set(B)) 企业面试题4.1 python新式类和经典类的区别？a. 在python里凡是继承了object的类，都是新式类b. Python3里只有新式类c. Python2里面继承object的是新式类，没有写父类的是经典类d. 经典类目前在Python里基本没有应用 4.2 python中内置的数据结构有几种？a. 整型 int、 长整型 long、浮点型 float、 复数 complexb. 字符串 str、 列表list、 元祖tuplec. 字典 dict 、 集合 set 4.3 python如何实现单例模式?请写出两种实现方式?第一种方法:使用装饰器 12345678910111213def singleton(cls): instances = &#123;&#125; def wrapper(*args, **kwargs): if cls not in instances: instances[cls] = cls(*args, **kwargs) return instances[cls] return wrapper@singletonclass Foo(object): passfoo1 = Foo()foo2 = Foo()print foo1 is foo2 #True 第二种方法：使用基类New 是真正创建实例对象的方法，所以重写基类的new 方法，以此保证创建对象的时候只生成一个实例 12345678910111213class Singleton(object): def __new__(cls,*args,**kwargs): if not hasattr(cls,'_instance'): cls._instance = super(Singleton,cls).__new__(cls,*args,**kwargs) return cls._instance class Foo(Singleton): passfoo1 = Foo()foo2 = Foo()print foo1 is foo2 #True 第三种方法：元类，元类是用于创建类对象的类，类对象创建实例对象时一定要调用call方法，因此在调用call时候保证始终只创建一个实例即可，type是python的元类 12345class Singleton(type): def __call__(cls,*args,**kwargs): if not hasattr(cls,'_instance'): cls._instance = super(Singleton,cls).__call__(*args,**kwargs) return cls._instance 123456class Foo(object): __metaclass__ = Singletonfoo1 = Foo()foo2 = Foo()print foo1 is foo2 #True 4.4 反转一个整数，例如-123 –&gt; -3211234567891011121314151617class Solution(object): def reverse(self,x): if -10&lt;x&lt;10: return x str_x = str(x) if str_x[0] !="-": str_x = str_x[::-1] x = int(str_x) else: str_x = str_x[1:][::-1] x = int(str_x) x = -x return x if -2147483648&lt;x&lt;2147483647 else 0if __name__ == '__main__': s = Solution() reverse_int = s.reverse(-120) print(reverse_int) 4.5 设计实现遍历目录与子目录，抓取.pyc文件第一种方法： 12345678910111213import osdef get_files(dir,suffix): res = [] for root,dirs,files in os.walk(dir): for filename in files: name,suf = os.path.splitext(filename) if suf == suffix: res.append(os.path.join(root,filename)) print(res)get_files("./",'.pyc') 第二种方法： 1234567891011121314151617181920import osdef pick(obj): try: if obj.[-4:] == ".pyc": print(obj) except: return None def scan_path(ph): file_list = os.listdir(ph) for obj in file_list: if os.path.isfile(obj): pick(obj) elif os.path.isdir(obj): scan_path(obj) if __name__=='__main__': path = input('输入目录') scan_path(path) 第三种方法 12345678910from glob import iglobdef func(fp, postfix): for i in iglob(f"&#123;fp&#125;/**/*&#123;postfix&#125;", recursive=True): print(i)if __name__ == "__main__": postfix = ".pyc" func("K:\Python_script", postfix) 4.6 一行代码实现1-100之和12count = sum(range(0,101))print(count) Python高级3 函数3.6 手写一个判断时间的装饰器1234567891011121314151617181920212223242526272829import datetimeclass TimeException(Exception): def __init__(self, exception_info): super().__init__() self.info = exception_info def __str__(self): return self.infodef timecheck(func): def wrapper(*args, **kwargs): if datetime.datetime.now().year == 2019: func(*args, **kwargs) else: raise TimeException("函数已过时") return wrapper@timecheckdef test(name): print("Hello &#123;&#125;, 2019 Happy".format(name))if __name__ == "__main__": test("backbp") 3.7 使用Python内置的filter()方法来过滤？1[x for x in filter(lambda x: x % 2 == 0, range(10))] 4设计模式4.1 对设计模式的理解，简述你了解的设计模式？设计模式是经过总结，优化的，对我们经常会碰到的一些编程问题的可重用解决方案。一个设计模式并不像一个类或一个库那样能够直接作用于我们的代码，反之，设计模式更为高级，它是一种必须在特定情形下实现的一种方法模板。常见的是工厂模式和单例模式 4.2 请手写一个单例123456789#python2class A(object): __instance = None def __new__(cls,*args,**kwargs): if cls.__instance is None: cls.__instance = objecet.__new__(cls) return cls.__instance else: return cls.__instance 4.3 单例模式的应用场景有那些？单例模式应用的场景一般发现在以下条件下：资源共享的情况下，避免由于资源操作时导致的性能或损耗等，如日志文件，应用配置。控制资源的情况下，方便资源之间的互相通信。如线程池等，1,网站的计数器 2,应用配置 3.多线程池 4数据库配置 数据库连接池 5.应用程序的日志应用… 4.5 对装饰器的理解，并写出一个计时器记录方法执行性能的装饰器？装饰器本质上是一个python函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象。 12345678910111213141516import timefrom functools import wrapsdef timeit(func): @wraps(func) def wrapper(*args, **kwargs): start = time.clock() ret = func(*args, **kwargs) end = time.clock() print('used:',end-start) return ret return wrapper@timeitdef foo(): print('in foo()'foo()) 4.6 解释以下什么是闭包？在函数内部再定义一个函数，并且这个函数用到了外边函数的变量，那么将这个函数以及用到的一些变量称之为闭包。 4.7 函数装饰器有什么作用？装饰器本质上是一个python函数或类，它可以在让其他函数在不需要做任何代码的变动的前提下增加额外的功能。装饰器的返回值也是一个函数的对象，它经常用于有切面需求的场景。比如：插入日志，性能测试，事务处理，缓存。权限的校验等场景，有了装饰器就可以抽离出大量的与函数功能本身无关的雷同代码并发并继续使用。详细参考：https://manjusaka.itscoder.com/2018/02/23/something-about-decorator/ 4.8 生成器，迭代器的区别？迭代器是遵循迭代协议的对象。用户可以使用 iter() 以从任何序列得到迭代器（如 list, tuple, dictionary, set 等）。另一个方法则是创建一个另一种形式的迭代器 —— generator 。要获取下一个元素，则使用成员函数 next()（Python 2）或函数 next() function （Python 3） 。当没有元素时，则引发 StopIteration 此例外。若要实现自己的迭代器，则只要实现 next()（Python 2）或 __next__()（ Python 3） 生成器（Generator），只是在需要返回数据的时候使用yield语句。每次next()被调用时，生成器会返回它脱离的位置（它记忆语句最后一次执行的位置和所有的数据值） 区别： 生成器能做到迭代器能做的所有事，而且因为自动创建iter()和next()方法，生成器显得特别简洁，而且生成器也是高效的，使用生成器表达式取代列表解析可以同时节省内存。除了创建和保存程序状态的自动方法，当发生器终结时，还会自动抛出StopIteration异常。官方介绍：https://docs.python.org/3/tutorial/classes.html#iterators 4.9 X是什么类型?12X= (i for i in range(10))X是 generator类型 4.10 请用一行代码 实现将1-N 的整数列表以3为单位分组12N =100print ([[x for x in range(1,100)] [i:i+3] for i in range(0,100,3)]) 4.11 Python中yield的用法》yield就是保存当前程序执行状态。你用for循环的时候，每次取一个元素的时候就会计算一次。用yield的函数叫generator,和iterator一样，它的好处是不用一次计算所有元素，而是用一次算一次，可以节省很多空间，generator每次计算需要上一次计算结果，所以用yield,否则一return，上次计算结果就没了 4.20 用一行代码生成[1,4,9,16,25,36,49,64,81,100]1print([x*x for x in range(1, 11)]) 7系统编程7.1 进程总结进程：程序运行在操作系统上的一个实例，就称之为进程。进程需要相应的系统资源：内存、时间片、pid。创建进程：首先要导入multiprocessing中的Process：创建一个Process对象;创建Process对象时，可以传递参数; 123p = Process(target=XXX,args=(tuple,),kwargs=&#123;key:value&#125;)target = XXX 指定的任务函数，不用加(),args=(tuple,)kwargs=&#123;key:value&#125;给任务函数传递的参数 使用start()启动进程结束进程给子进程指定函数传递参数Demo 123456789101112131415161718import osfrom mulitprocessing import Processimport timedef pro_func(name,age,**kwargs): for i in range(5): print("子进程正在运行中，name=%s,age=%d,pid=%d"%(name,age,os.getpid())) print(kwargs) time.sleep(0.2)if __name__ =="__main__": #创建Process对象 p = Process(target=pro_func,args=('小明',18),kwargs=&#123;'m':20&#125;) #启动进程 p.start() time.sleep(1) #1秒钟之后，立刻结束子进程 p.terminate() p.join() 注意：进程间不共享全局变量进程之间的通信-Queue在初始化Queue()对象时（例如q=Queue(),若在括号中没有指定最大可接受的消息数量，获数量为负值时，那么就代表可接受的消息数量没有上限一直到内存尽头）Queue.qsize():返回当前队列包含的消息数量Queue.empty():如果队列为空，返回True，反之FalseQueue.full():如果队列满了，返回True,反之FalseQueue.get([block[,timeout]]):获取队列中的一条消息，然后将其从队列中移除，block默认值为True。如果block使用默认值，且没有设置timeout（单位秒),消息队列如果为空，此时程序将被阻塞（停在读中状态），直到消息队列读到消息为止，如果设置了timeout，则会等待timeout秒，若还没读取到任何消息，则抛出“Queue.Empty”异常：Queue.get_nowait()相当于Queue.get(False)Queue.put(item,[block[,timeout]]):将item消息写入队列，block默认值为True;如果block使用默认值，且没有设置timeout（单位秒），消息队列如果已经没有空间可写入，此时程序将被阻塞（停在写入状态），直到从消息队列腾出空间为止，如果设置了timeout，则会等待timeout秒，若还没空间，则抛出”Queue.Full”异常如果block值为False，消息队列如果没有空间可写入，则会立刻抛出”Queue.Full”异常;Queue.put_nowait(item):相当Queue.put(item,False)进程间通信Demo: 1234567891011121314151617181920212223242526272829303132from multiprocessing import Process.Queueimport os,time,random#写数据进程执行的代码：def write(q): for value in ['A','B','C']: print("Put %s to queue...",%value) q.put(value) time.sleep(random.random())#读数据进程执行的代码def read(q): while True: if not q.empty(): value = q.get(True) print("Get %s from queue.",%value) time.sleep(random.random()) else: breakif __name__=='__main__': #父进程创建Queue，并传给各个子进程 q = Queue() pw = Process(target=write,args=(q,)) pr = Process(target=read,args=(q,)) #启动子进程pw ，写入： pw.start() #等待pw结束 pw.join() #启动子进程pr，读取： pr.start() pr.join() #pr 进程里是死循环，无法等待其结束，只能强行终止: print('') print('所有数据都写入并且读完') 1进程池Pool 12345678910111213141516171819#coding:utf-8from multiprocessing import Poolimport os,time,randomdef worker(msg): t_start = time.time() print("%s 开始执行，进程号为%d"%(msg,os.getpid())) # random.random()随机生成0-1之间的浮点数 time.sleep(random.random()*2) t_stop = time.time() print(msg,"执行完毕，耗时%0.2f”%（t_stop-t_start))po = Pool(3)#定义一个进程池，最大进程数3for i in range(0,10): po.apply_async(worker,(i,))print("---start----")po.close()po.join()print("----end----") 进程池中使用Queue如果要使用Pool创建进程，就需要使用multiprocessing.Manager()中的Queue(),而不是multiprocessing.Queue(),否则会得到如下的错误信息：RuntimeError： Queue objects should only be shared between processs through inheritance 123456789101112131415161718192021from multiprocessing import Manager,Poolimport os,time,randomdef reader(q): print("reader 启动(%s),父进程为（%s)"%(os.getpid(),os.getpid())) for i in range(q.qsize()): print("reader 从Queue获取到消息:%s"%q.get(True))def writer(q): print("writer 启动（%s),父进程为(%s)"%(os.getpid(),os.getpid())) for i ini "itcast": q.put(i)if __name__ == "__main__": print("(%s)start"%os.getpid()) q = Manager().Queue()#使用Manager中的Queue po = Pool() po.apply_async(wrtier,(q,)) time.sleep(1) po.apply_async(reader,(q,)) po.close() po.join() print("(%s)End"%os.getpid()) 7.2 谈谈你对多进程，多线程，以及协程的理解，项目是否用？这个问题被问的概念相当之大，进程：一个运行的程序（代码）就是一个进程，没有运行的代码叫程序，进程是系统资源分配的最小单位，进程拥有自己独立的内存空间，所有进程间数据不共享，开销大。线程: cpu调度执行的最小单位，也叫执行路径，不能独立存在，依赖进程存在，一个进程至少有一个线程，叫主线程，而多个线程共享内存（数据共享，共享全局变量),从而极大地提高了程序的运行效率。协程: 是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操中栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。 7.3 Python异常使用场景有那些？异步的使用场景:1、 不涉及共享资源，获对共享资源只读，即非互斥操作2、 没有时序上的严格关系3、 不需要原子操作，或可以通过其他方式控制原子性4、 常用于IO操作等耗时操作，因为比较影响客户体验和使用性能5、 不影响主线程逻辑 7.4 多线程共同操作同一个数据互斥锁同步？1234567891011121314151617181920import threadingimport timeclass MyThread(threading.Thread): def run(self): global num time.sleep(1) if mutex.acquire(1): num +=1 msg = self.name + 'set num to ' +str(num) print msg mutex.release()num = 0mutex = threading.Lock()def test(): for i in range(5): t = MyThread() t.start()if __name__=="__main__": test() 7.5 什么是多线程竞争？线程是非独立的，同一个进程里线程是数据共享的，当各个线程访问数据资源时会出现竞争状态即：数据几乎同步会被多个线程占用，造成数据混乱，即所谓的线程不安全那么怎么解决多线程竞争问题？—锁锁的好处： 确保了某段关键代码（共享数据资源）只能由一个线程从头到尾完整地执行能解决多线程资源竞争下的原子操作问题。锁的坏处： 阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了锁的致命问题: 死锁 7.6 请介绍一下Python的线程同步？ 一、 setDaemon(False)当一个进程启动之后，会默认产生一个主线程，因为线程是程序执行的最小单位，当设置多线程时，主线程会创建多个子线程，在Python中，默认情况下就是setDaemon(False),主线程执行完自己的任务以后，就退出了，此时子线程会继续执行自己的任务，直到自己的任务结束。例子 1234567891011121314151617import threading import timedef thread(): time.sleep(2) print('---子线程结束---')def main(): t1 = threading.Thread(target=thread) t1.start() print('---主线程--结束')if __name__ =='__main__': main()#执行结果---主线程--结束---子线程结束--- 二、 setDaemon（True)当我们使用setDaemon(True)时，这是子线程为守护线程，主线程一旦执行结束，则全部子线程被强制终止例子 123456789101112131415import threadingimport timedef thread(): time.sleep(2) print(’---子线程结束---')def main(): t1 = threading.Thread(target=thread) t1.setDaemon(True)#设置子线程守护主线程 t1.start() print('---主线程结束---')if __name__ =='__main__': main()#执行结果---主线程结束--- #只有主线程结束，子线程来不及执行就被强制结束 三、 join（线程同步)join 所完成的工作就是线程同步，即主线程任务结束以后，进入堵塞状态，一直等待所有的子线程结束以后，主线程再终止。当设置守护线程时，含义是主线程对于子线程等待timeout的时间将会杀死该子线程，最后退出程序，所以说，如果有10个子线程，全部的等待时间就是每个timeout的累加和，简单的来说，就是给每个子线程一个timeou的时间，让他去执行，时间一到，不管任务有没有完成，直接杀死。没有设置守护线程时，主线程将会等待timeout的累加和这样的一段时间，时间一到，主线程结束，但是并没有杀死子线程，子线程依然可以继续执行，直到子线程全部结束，程序退出。例子 123456789101112131415161718import threadingimport timedef thread(): time.sleep(2) print('---子线程结束---')def main(): t1 = threading.Thread(target=thread) t1.setDaemon(True) t1.start() t1.join(timeout=1)#1 线程同步，主线程堵塞1s 然后主线程结束，子线程继续执行 #2 如果不设置timeout参数就等子线程结束主线程再结束 #3 如果设置了setDaemon=True和timeout=1主线程等待1s后会强制杀死子线程，然后主线程结束 print('---主线程结束---')if __name__=='__main___': main() 7.7 解释以下什么是锁，有哪几种锁？锁(Lock)是python提供的对线程控制的对象。有互斥锁，可重入锁，死锁。 7.8 什么是死锁？若干子线程在系统资源竞争时，都在等待对方对某部分资源解除占用状态，结果是谁也不愿先解锁，互相干等着，程序无法执行下去，这就是死锁。GIL锁 全局解释器锁（只在cython里才有）作用： 限制多线程同时执行，保证同一时间只有一个线程执行，所以cython里的多线程其实是伪多线程！所以python里常常使用协程技术来代替多线程，协程是一种更轻量级的线程。进程和线程的切换时由系统决定，而协程由我们程序员自己决定，而模块gevent下切换是遇到了耗时操作时才会切换三者的关系：进程里有线程，线程里有协程。 7.9 多线程交互访问数据，如果访问到了就不访问了？怎么避免重读？创建一个已访问数据列表，用于存储已经访问过的数据，并加上互斥锁，在多线程访问数据的时候先查看数据是否在已访问的列表中，若已存在就直接跳过。 7.10 什么是线程安全，什么是互斥锁？每个对象都对应于一个可称为’互斥锁‘的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象。同一进程中的多线程之间是共享系统资源的，多个线程同时对一个对象进行操作，一个线程操作尚未结束，另一线程已经对其进行操作，导致最终结果出现错误，此时需要对被操作对象添加互斥锁，保证每个线程对该对象的操作都得到正确的结果。 7.11说说下面几个概念：同步，异步，阻塞，非阻塞？同步： 多个任务之间有先后顺序执行，一个执行完下个才能执行。异步： 多个任务之间没有先后顺序，可以同时执行，有时候一个任务可能要在必要的时候获取另一个同时执行的任务的结果，这个就叫回调！阻塞： 如果卡住了调用者，调用者不能继续往下执行，就是说调用者阻塞了。非阻塞： 如果不会卡住，可以继续执行，就是说非阻塞的。同步异步相对于多任务而言，阻塞非阻塞相对于代码执行而言。 7.12 什么是僵尸进程和孤儿进程？怎么避免僵尸进程？孤儿进程： 父进程退出，子进程还在运行的这些子进程都是孤儿进程，孤儿进程将被init 进程（进程号为1）所收养，并由init 进程对他们完成状态收集工作。僵尸进程： 进程使用fork 创建子进程，如果子进程退出，而父进程并没有调用wait 获waitpid 获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中的这些进程是僵尸进程。避免僵尸进程的方法：1.fork 两次用孙子进程去完成子进程的任务2.用wait()函数使父进程阻塞3.使用信号量，在signal handler 中调用waitpid,这样父进程不用阻塞 7.13 python中进程与线程的使用场景？多进程适合在CPU密集操作（cpu操作指令比较多，如位多的的浮点运算）。多线程适合在IO密性型操作（读写数据操作比多的的，比如爬虫） 7.14 线程是并发还是并行，进程是并发还是并行？线程是并发，进程是并行;进程之间互相独立，是系统分配资源的最小单位，同一个线程中的所有线程共享资源。 7.15 并行(parallel)和并发（concurrency)?并行： 同一时刻多个任务同时在运行并发: 在同一时间间隔内多个任务都在运行，但是并不会在同一时刻同时运行，存在交替执行的情况。实现并行的库有： multiprocessing实现并发的库有: threading程序需要执行较多的读写、请求和回复任务的需要大量的IO操作，IO密集型操作使用并发更好。CPU运算量大的程序，使用并行会更好 7.16 IO密集型和CPU密集型区别？IO密集型： 系统运行，大部分的状况是CPU在等 I/O（硬盘/内存）的读/写CPU密集型： 大部分时间用来做计算，逻辑判断等CPU动作的程序称之CPU密集型。 7.17 python asyncio的原理？asyncio这个库就是使用python的yield这个可以打断保存当前函数的上下文的机制， 封装好了selector 摆脱掉了复杂的回调关系 三.Web1、Flask1.1 对Flask蓝图(Blueprint)的理解？蓝图的定义蓝图 /Blueprint 是Flask应用程序组件化的方法，可以在一个应用内或跨越多个项目共用蓝图。使用蓝图可以极大简化大型应用的开发难度，也为Flask扩展提供了一种在应用中注册服务的集中式机制。蓝图的应用场景：把一个应用分解为一个蓝图的集合。这对大型应用是理想的。一个项目可以实例化一个应用对象，初始化几个扩展，并注册一集合的蓝图。以URL前缀和/或子域名，在应用上注册一个蓝图。URL前缀/子域名中的参数即成为这个蓝图下的所有视图函数的共同的视图参数（默认情况下）在一个应用中用不同的URL规则多次注册一个蓝图。通过蓝图提供模板过滤器、静态文件、模板和其他功能。一个蓝图不一定要实现应用或视图函数。初始化一个Flask扩展时，在这些情况中注册一个蓝图。蓝图的缺点：不能在应用创建后撤销注册一个蓝图而不销毁整个应用对象。使用蓝图的三个步骤1.创建一个蓝图对象 1blue = Blueprint("blue",__name__) 2.在这个蓝图对象上进行操作，例如注册路由、指定静态文件夹、注册模板过滤器… 123@blue.route('/')def blue_index(): return "Welcome to my blueprint" 3.在应用对象上注册这个蓝图对象 1app.register_blueprint(blue,url_prefix="/blue") 1.2 Flask 和 Django 路由映射的区别？ 在django中，路由是浏览器访问服务器时，先访问的项目中的url，再由项目中的url找到应用中url，这些url是放在一个列表里，遵从从前往后匹配的规则。在flask中，路由是通过装饰器给每个视图函数提供的，而且根据请求方式的不同可以一个url用于不同的作用。 2、 Django2.1、什么是wsgi,uwsgi,uWSGI?WSGI:web服务器网关接口，是一套协议。用于接收用户请求并将请求进行初次封装，然后将请求交给web框架。实现wsgi协议的模块：wsgiref,本质上就是编写一socket服务端，用于接收用户请求（django)werkzeug,本质上就是编写一个socket服务端，用于接收用户请求(flask)uwsgi:与WSGI一样是一种通信协议，它是uWSGI服务器的独占协议，用于定义传输信息的类型。uWSGI:是一个web服务器，实现了WSGI的协议，uWSGI协议，http协议 2.2、 Django、Flask、Tornado的对比？1、 Django走的大而全的方向，开发效率高。它的MTV框架，自带的ORM,admin后台管理,自带的sqlite数据库和开发测试用的服务器，给开发者提高了超高的开发效率。重量级web框架，功能齐全，提供一站式解决的思路，能让开发者不用在选择上花费大量时间。自带ORM和模板引擎，支持jinja等非官方模板引擎。自带ORM使Django和关系型数据库耦合度高，如果要使用非关系型数据库，需要使用第三方库自带数据库管理app成熟，稳定，开发效率高，相对于Flask，Django的整体封闭性比较好，适合做企业级网站的开发。python web框架的先驱，第三方库丰富2、 Flask 是轻量级的框架，自由，灵活，可扩展性强，核心基于Werkzeug WSGI工具 和jinja2 模板引擎适用于做小网站以及web服务的API,开发大型网站无压力，但架构需要自己设计与关系型数据库的结合不弱于Django，而与非关系型数据库的结合远远优于Django3、 Tornado走的是少而精的方向，性能优越，它最出名的异步非阻塞的设计方式Tornado的两大核心模块：iostraem:对非阻塞的socket进行简单的封装ioloop: 对I/O 多路复用的封装,它实现一个单例 2.3 CORS 和 CSRF的区别？什么是CORS？CORS是一个W3C标准,全称是“跨域资源共享”(Cross-origin resoure sharing).它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而客服了AJAX只能同源使用的限制。什么是CSRF？CSRF主流防御方式是在后端生成表单的时候生成一串随机token,内置到表单里成为一个字段，同时，将此串token置入session中。每次表单提交到后端时都会检查这两个值是否一致，以此来判断此次表单提交是否是可信的，提交过一次之后，如果这个页面没有生成CSRF token,那么token将会被清空,如果有新的需求，那么token会被更新。攻击者可以伪造POST表单提交，但是他没有后端生成的内置于表单的token，session中没有token都无济于事。 2.4 Session,Cookie,JWT的理解为什么要使用会话管理众所周知，HTTP协议是一个无状态的协议，也就是说每个请求都是一个独立的请求，请求与请求之间并无关系。但在实际的应用场景，这种方式并不能满足我们的需求。举个大家都喜欢用的例子，把商品加入购物车，单独考虑这个请求，服务端并不知道这个商品是谁的，应该加入谁的购物车？因此这个请求的上下文环境实际上应该包含用户的相关信息，在每次用户发出请求时把这一小部分额外信息，也做为请求的一部分，这样服务端就可以根据上下文中的信息，针对具体的用户进行操作。所以这几种技术的出现都是对HTTP协议的一个补充，使得我们可以用HTTP协议+状态管理构建一个的面向用户的WEB应用。Session 和Cookie的区别 这里我想先谈谈session与cookies,因为这两个技术是做为开发最为常见的。那么session与cookies的区别是什么？个人认为session与cookies最核心区别在于额外信息由谁来维护。利用cookies来实现会话管理时，用户的相关信息或者其他我们想要保持在每个请求中的信息，都是放在cookies中,而cookies是由客户端来保存，每当客户端发出新请求时，就会稍带上cookies,服务端会根据其中的信息进行操作。 当利用session来进行会话管理时，客户端实际上只存了一个由服务端发送的session_id,而由这个session_id,可以在服务端还原出所需要的所有状态信息，从这里可以看出这部分信息是由服务端来维护的。 除此以外，session与cookies都有一些自己的缺点： cookies的安全性不好，攻击者可以通过获取本地cookies进行欺骗或者利用cookies进行CSRF攻击。使用cookies时,在多个域名下，会存在跨域问题。 session 在一定的时间里，需要存放在服务端，因此当拥有大量用户时，也会大幅度降低服务端的性能，当有多台机器时，如何共享session也会是一个问题.(redis集群)也就是说，用户第一个访问的时候是服务器A，而第二个请求被转发给了服务器B，那服务器B如何得知其状态。实际上，session与cookies是有联系的，比如我们可以把session_id存放在cookies中的。 JWT是如何工作的 首先用户发出登录请求，服务端根据用户的登录请求进行匹配，如果匹配成功，将相关的信息放入payload中，利用算法，加上服务端的密钥生成token，这里需要注意的是secret_key很重要，如果这个泄露的话，客户端就可以随机篡改发送的额外信息，它是信息完整性的保证。生成token后服务端将其返回给客户端，客户端可以在下次请求时，将token一起交给服务端，一般是说我们可以将其放在Authorization首部中，这样也就可以避免跨域问题。 2.5 简述Django请求生命周期一般是用户通过浏览器向我们的服务器发起一个请求(request),这个请求会去访问视图函数，如果不涉及到数据调用，那么这个时候视图函数返回一个模板也就是一个网页给用户）视图函数调用模型毛模型去数据库查找数据，然后逐级返回，视图函数把返回的数据填充到模板中空格中，最后返回网页给用户。1.wsgi ,请求封装后交给web框架（Flask，Django)2.中间件，对请求进行校验或在请求对象中添加其他相关数据，例如：csrf,request.session3.路由匹配 根据浏览器发送的不同url去匹配不同的视图函数4.视图函数，在视图函数中进行业务逻辑的处理，可能涉及到：orm，templates5.中间件，对响应的数据进行处理6.wsgi，将响应的内容发送给浏览器 2.6 用的restframework完成api发送时间时区当前的问题是用django的rest framework模块做一个get请求的发送时间以及时区信息的api 123456class getCurrenttime(APIView): def get(self,request): local_time = time.localtime() time_zone =settings.TIME_ZONE temp = &#123;'localtime':local_time,'timezone':time_zone&#125; return Response(temp) 2.7 nginx,tomcat,apach到都是什么？Nginx（engine x)是一个高性能的HTTP和反向代理服务器，也是 一个IMAP/POP3/SMTP服务器，工作在OSI七层，负载的实现方式：轮询，IP_HASH,fair,session_sticky.Apache HTTP Server是一个模块化的服务器，源于NCSAhttpd服务器Tomcat 服务器是一个免费的开放源代码的Web应用服务器，属于轻量级应用服务器，是开发和调试JSP程序的首选。 2.8 请给出你熟悉关系数据库范式有哪些，有什么作用？在进行数据库的设计时，所遵循的一些规范，只要按照设计规范进行设计，就能设计出没有数据冗余和数据维护异常的数据库结构。数据库的设计的规范有很多，通常来说我们在设是数据库时只要达到其中一些规范就可以了，这些规范又称之为数据库的三范式，一共有三条，也存在着其他范式，我们只要做到满足前三个范式的要求，就能设陈出符合我们的数据库了，我们也不能全部来按照范式的要求来做，还要考虑实际的业务使用情况，所以有时候也需要做一些违反范式的要求。1.数据库设计的第一范式(最基本)，基本上所有数据库的范式都是符合第一范式的，符合第一范式的表具有以下几个特点：数据库表中的所有字段都只具有单一属性，单一属性的列是由基本的数据类型（整型，浮点型，字符型等）所构成的设计出来的表都是简单的二比表2.数据库设计的第二范式(是在第一范式的基础上设计的)，要求一个表中只具有一个业务主键，也就是说符合第二范式的表中不能存在非主键列对只对部分主键的依赖关系3.数据库设计的第三范式，指每一个非主属性既不部分依赖与也不传递依赖于业务主键，也就是第二范式的基础上消除了非主属性对主键的传递依赖 2.9 简述QQ登陆过程qq登录，在我们的项目中分为了三个接口，第一个接口是请求qq服务器返回一个qq登录的界面;第二个接口是通过扫码或账号登陆进行验证，qq服务器返回给浏览器一个code和state,利用这个code通过本地服务器去向qq服务器获取access_token覆返回给本地服务器，凭借access_token再向qq服务器获取用户的openid(openid用户的唯一标识)第三个接口是判断用户是否是第一次qq登录，如果不是的话直接登录返回的jwt-token给用户，对没有绑定过本网站的用户，对openid进行加密生成token进行绑定 2.10 post 和 get的区别?1.GET是从服务器上获取数据，POST是向服务器传送数据2.在客户端，GET方式在通过URL提交数据，数据在URL中可以看到，POST方式，数据放置在HTML——HEADER内提交3.对于GET方式，服务器端用Request.QueryString获取变量的值，对于POST方式，服务器端用Request.Form获取提交的数据 2.11 项目中日志的作用一、日志相关概念1.日志是一种可以追踪某些软件运行时所发生事件的方法2.软件开发人员可以向他们的代码中调用日志记录相关的方法来表明发生了某些事情3.一个事件可以用一个包含可选变量数据的消息来描述4.此外，事件也有重要性的概念，这个重要性也可以被成为严重性级别(level)二、日志的作用1.通过log的分析，可以方便用户了解系统或软件、应用的运行情况;2.如果你的应用log足够丰富，可以分析以往用户的操作行为、类型喜好，地域分布或其他更多信息;3.如果一个应用的log同时也分了多个级别，那么可以很轻易地分析得到该应用的健康状况，及时发现问题并快速定位、解决问题，补救损失。4.简单来讲就是我们通过记录和分析日志可以了解一个系统或软件程序运行情况是否正常，也可以在应用程序出现故障时快速定位问题。不仅在开发中，在运维中日志也很重要，日志的作用也可以简单。总结为以下几点：1.程序调试2.了解软件程序运行情况，是否正常3,软件程序运行故障分析与问题定位4,如果应用的日志信息足够详细和丰富，还可以用来做用户行为分析 2.12 django中间件的使用？Django在中间件中预置了六个方法，这六个方法的区别在于不同的阶段执行，对输入或输出进行干预，方法如下：1.初始化：无需任何参数，服务器响应第一个请求的时候调用一次，用于确定是否启用当前中间件 12def __init__(): pass 2.处理请求前：在每个请求上调用，返回None或HttpResponse对象。 12def process_request(request): pass 3.处理视图前:在每个请求上调用，返回None或HttpResponse对象。 12def process_view(request,view_func,view_args,view_kwargs): pass 4.处理模板响应前：在每个请求上调用，返回实现了render方法的响应对象。 12def process_template_response(request,response): pass 5.处理响应后：所有响应返回浏览器之前被调用，在每个请求上调用，返回HttpResponse对象。 12def process_response(request,response): pass 6.异常处理：当视图抛出异常时调用，在每个请求上调用，返回一个HttpResponse对象。 12def process_exception(request,exception): pass 2.13 谈一下你对uWSGI和nginx的理解？1.uWSGI是一个Web服务器，它实现了WSGI协议、uwsgi、http等协议。Nginx中HttpUwsgiModule的作用是与uWSGI服务器进行交换。WSGI是一种Web服务器网关接口。它是一个Web服务器（如nginx，uWSGI等服务器）与web应用（如用Flask框架写的程序）通信的一种规范。要注意WSGI/uwsgi/uWSGI这三个概念的区分。WSGI是一种通信协议。uwsgi是一种线路协议而不是通信协议，在此常用于在uWSGI服务器与其他网络服务器的数据通信。uWSGI是实现了uwsgi和WSGI两种协议的Web服务器。nginx 是一个开源的高性能的HTTP服务器和反向代理：1.作为web服务器，它处理静态文件和索引文件效果非常高2.它的设计非常注重效率，最大支持5万个并发连接，但只占用很少的内存空间3.稳定性高，配置简洁。4.强大的反向代理和负载均衡功能，平衡集群中各个服务器的负载压力应用 2.14 Python中三大框架各自的应用场景？django:主要是用来搞快速开发的，他的亮点就是快速开发，节约成本，,如果要实现高并发的话，就要对django进行二次开发，比如把整个笨重的框架给拆掉自己写socket实现http的通信,底层用纯c,c++写提升效率，ORM框架给干掉，自己编写封装与数据库交互的框架,ORM虽然面向对象来操作数据库，但是它的效率很低，使用外键来联系表与表之间的查询;flask: 轻量级，主要是用来写接口的一个框架，实现前后端分离，提考开发效率，Flask本身相当于一个内核，其他几乎所有的功能都要用到扩展(邮件扩展Flask-Mail，用户认证Flask-Login),都需要用第三方的扩展来实现。比如可以用Flask-extension加入ORM、文件上传、身份验证等。Flask没有默认使用的数据库，你可以选择MySQL，也可以用NoSQL。其WSGI工具箱用Werkzeug(路由模块)，模板引擎则使用Jinja2,这两个也是Flask框架的核心。Tornado： Tornado是一种Web服务器软件的开源版本。Tornado和现在的主流Web服务器框架（包括大多数Python的框架）有着明显的区别：它是非阻塞式服务器，而且速度相当快。得利于其非阻塞的方式和对epoll的运用，Tornado每秒可以处理数以千计的连接因此Tornado是实时Web服务的一个理想框架 2.17 Django中哪里用到了线程？哪里用到了协程？哪里用到了进程？1.Django中耗时的任务用一个进程或者线程来执行，比如发邮件，使用celery.2.部署django项目是时候，配置文件中设置了进程和协程的相关配置。 2.18 有用过Django REST framework吗？Django REST framework是一个强大而灵活的Web API工具。使用RESTframework的理由有：Web browsable API对开发者有极大的好处包括OAuth1a和OAuth2的认证策略支持ORM和非ORM数据资源的序列化全程自定义开发–如果不想使用更加强大的功能，可仅仅使用常规的function-based views额外的文档和强大的社区支持 2.19 对cookies与session的了解？他们能单独用吗？Session采用的是在服务器端保持状态的方案，而Cookie采用的是在客户端保持状态的方案。但是禁用Cookie就不能得到Session。因为Session是用Session ID来确定当前对话所对应的服务器Session，而Session ID是通过Cookie来传递的，禁用Cookie相当于SessionID,也就得不到Session。]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
</search>
