<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python类]]></title>
    <url>%2F2019%2F02%2F27%2Fpython%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[创建和使用12345678class Dog(): def __init__(self,name,age): self.name=name; self.age=age; def sit(self): print(self.name.title()+" is now sitting") def roll_over(self): print(self.name.title()+" rolled over!") 方法__init__()是一个特殊的方法，相当于构造方法，每当创建新实例时，Python都会自动运行它__init__中的形参self必不可少，还必须位于其他形参的前面。创建实例时不用给self传递值后面的两个方法由于不需要额外的信息，因此只有一个形参self，变量都有前缀self，以self为前缀的变量可供类中的所有方法使用。self.name=name获取存储在形参name中的值，并将其存储到变量name中，然后该变量被关联到当前创建的实例。 根据类创建实例my_dog=Dog(‘stupy’,3)这里使用上面的Dog类创建了一个名为‘stupy’、年龄为3的my_dog实例访问属性my_dog.name获取名字，my_dog.age获取年龄 调用方法my_dog.sit() my_dog.roll_over() 给属性指定默认值比如上例默认为公狗，则在init()函数中创建一个性别属性并设置初始值，self.sex=’gong’ 修改属性的值1.直接修改属性的值接上例，使用句点表示法来直接访问并设置小狗的属性name。my_dog.name=’clever’ 2.通过方法修改属性的值相当于java中的set方法例： 123def update_name(self,newname): self.name=newnamemy_dog.update_name('wuwu') 这样就无需直接访问属性，而可以将值传递给一个方法，由它在内部进行更新 继承如下例： 1234567891011121314151617181920212223class Car(): def __init__(self, make, model, year): self.make = make self.model = model self.year = year self.odometer_reading = 0 def get_descriptive_name(self): long_name = str(self.year) + ' ' + self.make + ' ' + self.model return long_name.title() def read_odometer(self): print("This car has " + str(self.odometer_reading) + " miles on it.") def update_odometer(self, mileage): if mileage &gt;= self.odometer_reading: self.odometer_reading = mileage else: print("You can't roll back an odometer!") def increment_odometer(self, miles): self.odometer_reading += miles class ElectricCar(Car): def __init__(self, make, model, year): super().__init__(make, model, year) my_tesla = ElectricCar('tesla', 'model s', 2016) print(my_tesla.get_descriptive_name()) 定义子类时，在括号里指定父类的名称。super()帮助Python将父类和子类关联起来，调用父类的方法__init__()，让ElectricCar实例包含父类的所有属性。上面ElectricCar实例的行为与Car实例一样，现在定义电动汽车特有的属性和方法在__init__函数內定义一个电动汽车特有的属性，self.battery_size=70编写一个打印电瓶描述的方法 123def describe_battery(self): print("This car has a " + str(self.battery_size) + "-kWh battery.") 1.继承顺序在Java和C#中子类只能继承一个父类，而Python中子类可以同时继承多个父类，如A(B,C,D) 如果继承关系为非菱形结构，则会按照先找B这一条分支，然后再找C这一条分支，最后找D这一条分支的顺序直到找到我们想要的属性 如果继承关系为菱形结构，那么属性的查找方式有两种，分别是：深度优先和广度优先 1234567891011121314151617181920212223242526272829303132class A(object): def test(self): print('from A') class B(A): def test(self): print('from B') class C(A): def test(self): print('from C') class D(B): def test(self): print('from D') class E(C): def test(self): print('from E') class F(D,E): # def test(self): # print('from F') passf1=F()f1.test()print(F.__mro__) #只有新式才有这个属性可以查看线性列表，经典类没有这个属性 #新式类继承顺序:F-&gt;D-&gt;B-&gt;E-&gt;C-&gt;A#经典类继承顺序:F-&gt;D-&gt;B-&gt;A-&gt;E-&gt;C#python3中统一都是新式类#pyhon2中才分新式类与经典类 2 继承原理(python如何实现的继承)python到底是如何实现继承的，对于你定义的每一个类，python会计算出一个方法解析顺序(MRO)列表，这个MRO列表就是一个简单的所有基类的线性顺序列表，例如 12&gt;&gt;&gt; F.mro() #等同于F.__mro__[&lt;class '__main__.F'&gt;, &lt;class '__main__.D'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.E'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;] 为了实现继承,python会在MRO列表上从左到右开始查找基类,直到找到第一个匹配这个属性的类为止。而这个MRO列表的构造是通过一个C3线性化算法来实现的。我们不去深究这个算法的数学原理,它实际上就是合并所有父类的MRO列表并遵循如下三条准则:1.子类会先于父类被检查2.多个父类会根据它们在列表中的顺序被检查 3.如果对下一个类存在两个合法的选择,选择第一个父类 3.子类中调用父类的方法方法一：指名道姓，即父类名.父类方法() 12345678910111213141516171819202122class Vehicle: #定义交通工具类 Country='China' def __init__(self,name,speed,load,power): self.name=name self.speed=speed self.load=load self.power=power def run(self): print('开动啦...') class Subway(Vehicle): #地铁 def __init__(self,name,speed,load,power,line): Vehicle.__init__(self,name,speed,load,power) self.line=line def run(self): print('地铁%s号线欢迎您' %self.line) Vehicle.run(self) line13=Subway('中国地铁','180m/s','1000人/箱','电',13)line13.run() 方法二：super()，推荐用这种方法 1234567891011121314151617181920212223242526class Vehicle: #定义交通工具类 Country='China' def __init__(self,name,speed,load,power): self.name=name self.speed=speed self.load=load self.power=power def run(self): print('开动啦...') class Subway(Vehicle): #地铁 def __init__(self,name,speed,load,power,line): #super(Subway,self) 就相当于实例本身 在python3中super()等同于super(Subway,self) super().__init__(name,speed,load,power) self.line=line def run(self): print('地铁%s号线欢迎您' %self.line) super(Subway,self).run() class Mobike(Vehicle):#摩拜单车 pass line13=Subway('中国地铁','180m/s','1000人/箱','电',13)line13.run() 多态与多态性多态多态指的是一类事物有多种形态 动物有多种形态：人，狗，猪 多态性多态性是指在不考虑实例类型的情况下使用实例 12在面向对象方法中一般是这样表述多态性：向不同的对象发送同一条消息（！！！obj.func():是调用了obj的方法func，又称为向obj发送了一条消息func），不同的对象在接收时会产生不同的行为（即方法）。也就是说，每个对象可以用自己的方式去响应共同的消息。所谓消息，就是调用函数，不同的行为就是指不同的实现，即执行不同的函数。比如：老师.下课铃响了（），学生.下课铃响了()，老师执行的是下班操作，学生执行的是放学操作，虽然二者消息一样，但是执行的效果不同 多态性分为静态多态性和动态多态性 静态多态性：如任何类型都可以用运算符+进行运算 动态多态性：如下 12345678910111213peo=People()dog=Dog()pig=Pig() #peo、dog、pig都是动物,只要是动物肯定有talk方法#于是我们可以不用考虑它们三者的具体是什么类型,而直接使用peo.talk()dog.talk()pig.talk() #更进一步,我们可以定义一个统一的接口来使用def func(obj): #obj这个参数没有类型限制，可以传入不同类型的值 obj.talk() #调用的逻辑都一样，执行的结果不一样 为什么要用多态性（多态性的好处）： 1.增加了程序的灵活性 以不变应万变，不论对象千变万化，使用者都是同一种形式去调用，如func(animal) 2.增加了程序额可扩展性 通过继承animal类创建了一个新的类，使用者无需更改自己的代码，还是用func(animal)去调用 123456789class Cat(Animal): #属于动物的另外一种形态：猫 def talk(self): print('say miao') def func(animal): #对于使用者来说，自己的代码根本无需改动 animal.talk() cat1=Cat() #实例出一只猫func(cat1) #甚至连调用方式也无需改变，就能调用猫的talk功能 派生在子类中重新定义父类的方法，运行时将忽略父类中的方法，转而运行子类中重新定义的方法。 在子类中，新建的重名的函数属性，在编辑函数内功能的时候，有可能需要重用父类中重名的那个函数功能，应该是用调用普通函数的方式，即：类名.func()，此时就与调用普通函数无异了，因此即便是self参数也要为其传值 接口接口提取了一群类共同的函数，可以把接口当做一个函数的集合。 然后让子类去实现接口中的函数。 这么做的意义在于归一化，什么叫归一化，就是只要是基于同一个接口实现的类，那么所有的这些类产生的对象在使用时，从用法上来说都一样。 归一化的好处在于： 归一化让使用者无需关心对象的类是什么，只需要的知道这些对象都具备某些功能就可以了，这极大地降低了使用者的使用难度。 归一化使得高层的外部使用者可以不加区分的处理所有接口兼容的对象集合 在python中根本就没有一个叫做interface的关键字，如果非要去模仿接口的概念 可以借助第三方模块： http://pypi.python.org/pypi/zope.interface twisted的twisted\internet\interface.py里使用zope.interface 文档https://zopeinterface.readthedocs.io/en/latest/ 设计模式：https://github.com/faif/python-patterns 也可以使用继承： 继承的两种用途 一：继承基类的方法，并且做出自己的改变或者扩展（代码重用）：实践中，继承的这种用途意义并不很大，甚至常常是有害的。因为它使得子类与基类出现强耦合。 二：声明某个子类兼容于某基类，定义一个接口类（模仿java的Interface），接口类中定义了一些接口名（就是函数名）且并未实现接口的功能，子类继承接口类，并且实现接口中的功能 抽象类1 什么是抽象类与java一样，python也有抽象类的概念但是同样需要借助模块实现，抽象类本质也是类，只是加了装饰器的类，它的特殊之处在于只能被继承，不能被实例化， 2 为什么要有抽象类如果说类是从一堆对象中抽取相同的内容而来的，那么抽象类就是从一堆类中抽取相同的内容而来的，内容包括数据属性和函数属性。 比如我们有香蕉的类，有苹果的类，有桃子的类，从这些类抽取相同的内容就是水果这个抽象的类，你吃水果时，要么是吃一个具体的香蕉，要么是吃一个具体的桃子。。。。。。你永远无法吃到一个叫做水果的东西。 从设计角度去看，如果类是从现实对象抽象而来的，那么抽象类就是基于类抽象而来的。 从实现角度来看，抽象类与普通类的不同之处在于：抽象类中只能有抽象方法（没有实现功能），该类不能被实例化，只能被继承，且子类必须实现抽象方法。这一点与接口有点类似，但其实是不同的，即将揭晓答案 3 在python中实现抽象类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import abc #利用abc模块实现抽象类 class All_file(metaclass=abc.ABCMeta): all_type='file' @abc.abstractmethod #定义抽象方法，无需实现功能 def read(self): '子类必须定义读功能' pass @abc.abstractmethod #定义抽象方法，无需实现功能 def write(self): '子类必须定义写功能' pass # class Txt(All_file):# pass## t1=Txt() #报错,子类没有定义抽象方法 class Txt(All_file): #子类继承抽象类，但是必须定义read和write方法 def read(self): print('文本数据的读取方法') def write(self): print('文本数据的读取方法') class Sata(All_file): #子类继承抽象类，但是必须定义read和write方法 def read(self): print('硬盘数据的读取方法') def write(self): print('硬盘数据的读取方法') class Process(All_file): #子类继承抽象类，但是必须定义read和write方法 def read(self): print('进程数据的读取方法') def write(self): print('进程数据的读取方法') wenbenwenjian=Txt() yingpanwenjian=Sata() jinchengwenjian=Process() #这样大家都是被归一化了,也就是一切皆文件的思想wenbenwenjian.read()yingpanwenjian.write()jinchengwenjian.read() print(wenbenwenjian.all_type)print(yingpanwenjian.all_type)print(jinchengwenjian.all_type)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python的递归与二分法]]></title>
    <url>%2F2019%2F02%2F27%2Fpython%E7%9A%84%E9%80%92%E5%BD%92%E4%B8%8E%E4%BA%8C%E5%88%86%E6%B3%95%2F</url>
    <content type="text"><![CDATA[递归递归:在调用一个函数的过程中，直接或间接地调用了函数本身这个就叫递归 1.必须有个明确的结束条件 2.每次进入更深一层递归时，问题规模相比上次递归应有所减少 3.递归效率不高，递归层次过多会导致栈溢出（在计算机中，函数调用是通过栈(stack)这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，就栈就会减少一层栈帧。由于栈的大小不是无限的，递归调用的次数过多，则会导致栈溢出） 实例： 123456789101112131415def age(n): if n == 1: return 18 else: return age(n-1)+2 print(age(5))# age(5)=age(4)+2 第一次进入# age(4)=age(3)+2 第二次进入# age(3)=age(2)+2 第三次进入# age(2)=age(1)+2 第四次进入# age(1)=18 第五次进入，最后判断终止条件# age(n)=age(n-1)+2 #n&gt;1 递归终止条件# age(1)=18 #n=1 等于终止条件 二分法每次拿中间的值与想要的值比较 例： 1234567891011121314151617181920212223name = &#123;12, 32, 23, 45, 123, 4654, 1231, 1, 2, 212, 56, 9, 34, 99, 30&#125;name_sor = sorted(name) #把列表内容按升序排列 def second_find(x, li): mid_index = int(len(li) / 2) if len(li) &gt; 1: if x &gt; li[mid_index]: l1 = li[mid_index:] second_find(x,l1) elif x &lt;li[mid_index]: l2 = li[:mid_index] second_find(x,l2) else: print('恭喜你找到了') elif len(li) == 1: if li[0] == x: print("恭喜你找到了") else: print("gun!") second_find(32, name_sor)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python内置函数]]></title>
    <url>%2F2019%2F02%2F26%2Fpython%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[内置函数以下是Python3版本所有的内置函数： abs()绝对值 all()传进一个可迭代对象，如果对象为空，比如[],’ ‘等，则返回Ture，如果不为空，则需要全部对象为Ture，才返回Ture 1print(all([None,0,' ',1])) 输出结果：False any()传进一个可迭代对象,如果对象为空，比如[],’ ‘等，则返回False,如果不为空，只要可迭代对象next出来的值任何一个为Ture，就返回Ture 1print(any([None,0,' ',1])) 输出结果：True sum()传进一个可迭代对象，进行求和计算 bin()返回一个整数 int 或者长整数 long int 的二进制表示 bool()以下情况都为False： [] 空列表 {} 空字典，空集合 () 空元祖 ‘ ‘ 空字符串 0 bytes()将一个字符串转换成字节形式 1print(bytes('helloworld', encoding='utf-8')) callable()判断函数是否可被调用 chr()用一个范围在 range（256）内的（就是0～255）整数作参数，返回一个对应ascii字符 dir()查看下面的方法 例： print(dir(sum)) 查看sum下面的方法 divmod()传进去两个数，得到整除加余数，多用于分页 enumerate()可迭代,并加上序列例： 12for i in emumerate(['a','b','c']) print(i) 输出结果： 123(0,'a')(1,'b')(2,'c') eval()函数可将字符串转换为代码执行，并返回一个或多个值 hash()一种算法，如果字符串改变，hash值也会改变，且不能逆推 hex()十进制转十六进制 otc()十进制转八进制 id()返回对象的内存地址,判断身份 pow()方法返回 xy（x的y次方） 的值 reverse()函数用于反向列表中元素 lambda()匿名函数:是指一类无需定义标识符（函数名）的函数或子程序。lambda 函数可以接收任意多个参数 (包括可选参数) 并且返回单个表达式的值 例1:定义一个lambda表达式，求三个数的和 12345678f = lambda x,y,z:x + y + zprint f(1,2,3)print f(4,5,6)输出：615 例2:用lambda表达式求n的阶乘 1234n = 5print reduce(lambda x,y:x*y,range(1,n+1))输出：120 round()方法返回浮点数x的四舍五入值,但实际为四舍六入五留双 round(10.5) 离偶数10近，所以结果为10 round(11.5) 离偶数12近，所以结果为12 max()求最大值 例：求字典中values的最大值，但返回的key 12money =&#123;'wzc': 5000, 'lsy': 500, 'hsy': 7000&#125;print(max(money, key=lambda s: money[s])) min()求最小值 zip()函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。 如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同 1234a = [1,2,3]b = [4,5,6]c = [4,5,6,7,8]zipped = zip(a,b) 打包为元组的列表 [(1, 4), (2, 5), (3, 6)] 1zipped = zip(a,c) 元素个数与最短的列表一致 [(1, 4), (2, 5), (3, 6)] sorted()排序，返回值是列表，默认升序 123sor = [2, 4, 6, 1, 34, 3]print(sorted(sor)) # 升序print(sorted(sor, reverse=True)) # 降序 实例：把人员按工资的高低排列 12money =&#123;'wzc': 5000, 'lsy': 500, 'hsy': 7000&#125;print(sorted(money, key=lambda x: money[x])) map()会根据提供的函数对指定序列做映射。它接收一个函数 f 和一个 list，并通过把函数 f 依次作用在 list 的每个元素上，得到一个map迭代器 并返回 实例1： 将列表中的值平方： 123x = [1, 4, 3, 2, 9, 6]l = map(lambda x1: x1**2, x)print(list(l)) 注意:Pyhton2返回列表，Python3 返回迭代器对象,我看网上很多人的博客写的都是Python2的返回结果 实例2：拼接 123x = [1, 4, 3, 2, 9, 6]l = map(lambda x1: str(x1) + 'apple', x)print(list(l)) reduce()函数会对参数序列中元素进行累积 在 Python3 中，reduce() 函数已经被从全局名字空间里移除了，它现在被放置在 fucntools 模块里，如果想要使用它，则需要通过引入 functools 模块来调用 reduce() 函数： 12from functools import reducereduce(lambda x, y: x+y, [1,2,3,4,5]) filter()函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。 该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判，然后返回 True 或 False，最后将返回 True 的元素放到新列表中。 注意: Pyhton2返回列表，Python3 返回迭代器对象 实例1： 123fe = [34, 23, 12, 56, 34, 34, 324]le = filter(lambda x: x &gt; 20, fe)print(list(le) 实例2： 123money =&#123;'wzc': 5000, 'lsy': 500, 'hsy': 7000&#125;li = filter(lambda x1: money[x1] &gt; 1000, money)print(list(li))]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>内置函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡排序]]></title>
    <url>%2F2019%2F02%2F26%2F%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[冒泡排序的思想: 每次比较两个相邻的元素, 如果他们的顺序错误就把他们交换位置比如有五个数: 12, 35, 99, 18, 76, 从大到小排序, 对相邻的两位进行比较 第一趟: 第一次比较: 35, 12, 99, 18, 76 第二次比较: 35, 99, 12, 18, 76 第三次比较: 35, 99, 18, 12, 76 第四次比较: 35, 99, 18, 76, 12 经过第一趟比较后, 五个数中最小的数已经在最后面了, 接下来只比较前四个数, 依次类推 第二趟99, 35, 76, 18, 12 第三趟99, 76, 35, 18, 12 第四趟99, 76, 35, 18, 12比较完成 冒泡排序原理: 每一趟只能将一个数归位, 如果有n个数进行排序,只需将n-1个数归位, 也就是说要进行n-1趟操作(已经归位的数不用再比较)1234567891011def my_sort(num): l = len(num) for i in range(l-1): for j in range(l-1-i): if num[j] &lt; num[j+1]: num[j], num[j+1] = num[j+1], num[j]nums = [2,45,67,8,0,56]my_sort(nums)print(nums)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>冒泡排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python生成器表达式]]></title>
    <url>%2F2019%2F02%2F26%2Fpython%E7%94%9F%E6%88%90%E5%99%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[生成器表达式相比列表表达式，将[]换成了()，返回对象不是一个列表，而是一个生成器，相比列表更加省内存 实例1： 列表表达式写法： 12l = ['apple%s' % i for i in range(10000)]print(l) 生成器表达式写法： 123g = ('apple%s' % i for i in range(10000))for i in g: print(i) 实例2: 一般写法： 12345678910res = []with open('test1.txt') as f: for line in f: l = line.split(',') d = &#123;&#125; d['name'] = l[0] d['price'] = l[1] d['count'] = l[2] res.append(d) print(d) 生成器表达式写法： 12345with open('test1.txt') as f: res = (line.split(',') for line in f) dic_g = (&#123;'name': i[0], 'price': i[1], 'count': i[2]&#125; for i in res) apple_dic = next(dic_g) #只有调用next才会往外拿一个,大大节省内存 print(apple_dic)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>生成器表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python列表生成式]]></title>
    <url>%2F2019%2F02%2F26%2Fpython%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[列表生成式会将所有的结果全部计算出来，把结果存放到内存中，如果列表中数据比较多，就会占用过多的内存空间，可能会导致MemoryError内存错误或者导致程序在运行时出现卡顿的情况 实例1： 在数字0-99中，取大于50的数，分为拼接在apple字符串后面，并存到一个列表中 一般的写法： 12345messi = []for i in range(100): if i &gt; 50: messi.append("apple%s" % i)print(messi) 列表生成式的写法： 123l = ["apple%s" % i for i in range(100) if i &gt; 50] # 'apple%s' %i 这句话在列表中，所以不用append命令写入列表中print(l) 实例2： 将一个列表中的每一个元素与一个字符串的每一个字符拼接，并保存到一个列表中 一般的写法： 123456789x1 = [1, 2, 3, 4]s = 'month'x2 = []for num in x1: for s1 in s: if num &gt; 2: t = (num, s1) x2.append(t)print(x2) 列表生成式的写法: 1234x1 = [1, 2, 3, 4]s = "month"le = [(num, s1) for num in x1 if num &gt; 2 for s1 in s]print(le)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>列表生成式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python协程函数]]></title>
    <url>%2F2019%2F02%2F26%2Fpython%E5%8D%8F%E7%A8%8B%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[协程函数从语法上来看，协程和生成器类似，都是定义体中包含yield关键字的函数。yield在协程中的用法： 在协程中yield通常出现在表达式的右边，例如：datum = yield,可以产出值，也可以不产出–如果yield关键字后面没有表达式，那么生成器产出None. 协程可能从调用方接受数据，调用方是通过send(datum)的方式把数据提供给协程使用，而不是next(…)函数，通常调用方会把值推送给协程。 协程可以把控制器让给中心调度程序，从而激活其他的协程 所以总体上在协程中把yield看做是控制流程的方式 实例： 123456789101112131415def menu(x): print("welcome %s to shaxian restaurant" % x) men_list = [] while True: print(men_list) food = yield men_list print("%s start to eat %s" % (x, food)) men_list.append(food) g = menu('张三')next(g)g.send('包子') # 将'包子'传给yield ，然后赋值给了food，然后从上次暂停的位置接着执行代码，直到又到下一个yieldg.send('饺子')g.send('牛肉面') g.send与next(g)的区别是： 1.如果函数内yield是表达式形式，那么必须先next(g) 2.二者的共同之处都是可以让函数在上一次暂停的位置继续运行，不一样的地方在于send在触发下一次代码的执行时，会顺便给yield传一个值 如果不想写next的初始化，而直接调用send，可以选择加个装饰器 12345678910111213141516171819202122232425def happy(fuc): def f1(*args, **kwargs): res = fuc(*args, **kwargs) next(res) #让函数调用时自动初始化next return res return f1 @happydef menu(x): print("welcome %s to shaxian restaurant" % x) men_list = [] while True: print(men_list) food = yield men_list print("%s start to eat %s" % (x, food)) men_list.append(food) g = menu('张三') g.send('包子') # 将'包子'传给yield ，然后赋值给了food，然后从上次暂停的位置接着执行代码，直到又到下一个yieldg.send('饺子')g.send('牛肉面')]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>协程函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python生成器]]></title>
    <url>%2F2019%2F02%2F26%2Fpython%E7%94%9F%E6%88%90%E5%99%A8%2F</url>
    <content type="text"><![CDATA[生成器生成器就是一个函数，这个函数内包含yield这个关键字 生成器与return的区别： return只能返回一次函数就结束，而生成器可以返回多次值 生成器函数包含一个或者多个yield 当调用生成器函数时，函数将返回一个对象，但是不会立刻向下执行，yield会保存一个状态，下一次运行会在这个位置接着往下运行，直到碰到下一个yield 像__iter__()和__next__()方法等是自动实现的，所以我们可以通过next()方法对对象进行迭代 一旦函数被yield，函数会暂停，控制权返回调用者 1234567891011def pr(x): print("start games") while x &gt; 0: yield x x -= 1 print("game over") game = pr(5) #此时game就是一个迭代器for i in game: print(i) 输出结果为： 1234567start games54321game over]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>生成器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python迭代器]]></title>
    <url>%2F2019%2F02%2F26%2Fpython%E8%BF%AD%E4%BB%A3%E5%99%A8%2F</url>
    <content type="text"><![CDATA[迭代器迭代器是一个可以记住遍历的位置的对象。 迭代器有两个基本的方法：iter() 和 next()。 使用对象内置的__iter__()方法生成迭代器 1it = name.__iter__() 使用内置工厂函数生成迭代器 1it = iter(name) 迭代器通过其内建的 iter.next() 方法，或通过 Python 内建的 next() 来迭代下一个元素，直到最后触发 StopIteration异常后表示迭代结束。 实例： 1234567name = &#123;'张三': 24, '李四': 25, '王五': 20&#125;it = iter(name)while True: try: print(next(it)) except StopIteration: break 输出为三个key的值 而for循环，本质就是调用了迭代器 for x in name 把name变成了一个迭代器，然后调用next方法，而且不用写 except StopIteration 作用优点1.提供一种不依赖索引的取值方式，这样就可以遍历那些没有索引的可迭代对象(字典，集合，文件) 2.迭代器与列表比较，迭代性是惰性计算，更省内存 缺点1.永远无法获取迭代器的长度，使用不如列表索引灵活，比如要获取第三个，则必须要一个个next 2.一次性，只能往后取，无法倒着取]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>迭代器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python装饰器]]></title>
    <url>%2F2019%2F02%2F26%2Fpython%E8%A3%85%E9%A5%B0%E5%99%A8%2F</url>
    <content type="text"><![CDATA[python装饰器就是用于在不改变原函数代码的情况下拓展新功能的一种函数，这个函数的特殊之处在于它的返回值也是一个函数，使用python装饰器的好处就是在不用更改原函数的代码前提下给函数增加新的功能。 装饰器分为有参和无参两种 无参123456789101112131415161718192021import timedef happy(func): def f1(*args, **kwargs): start_time = time.time() func(*args, **kwargs) end_time = time.time() print('run time is %s' % (end_time-start_time)) return f1 @happy #auto=happy(auto)def auto(name, password): print(name, password) @happydef shadow(): time.sleep(3) print("hello_world") shadow()auto('wzc', '123456') auto函数为原函数，我们需要对其进行功能扩展 因为原函数可能有形参或者没有，因此我们将函数定义为 def f1(*args, **kwargs)，这样不管是有参还是无参，都可以接收，不会报错 这里的happy函数就是最原始的装饰器，把auto当做了一个参数传了进去 auto=happy(auto) 然后返回值也是一个函数，返回一个f1，相当于auto=f1 其中作为参数的这个函数auto就在返回函数f1的内部执行。在函数auto前面加上@happy，auto函数就相当于被注入了计时功能，现在只要调用auto，它就已经变身为“新的功能更多”的函数了。 有参有参装饰器与无参装饰器的区别就是在外面多加一个嵌套函数，实现闭包功能 12345678910111213141516171819import time def mom(x='blee'): def happy(func): def f1(*args, **kwargs): print(x) start_time = time.time() func(*args, **kwargs) end_time = time.time() print('run time is %s' % (end_time-start_time)) return f1 return happy @mom('red')def auto(name, password): print(name, password) auto('wzc', '123456') 在原函数前面写@装饰器名，并加入参数 @mom(‘red’) 这时候我们先看mom(‘red’)，传回一个函数happy，等同于 @happy 接下来就和上面一样，这样就实现了有参装饰器]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>装饰器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python函数]]></title>
    <url>%2F2019%2F02%2F26%2Fpython%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[内置函数比如print,len,max等，后面有详细介绍的文章 自定义函数函数定义1234def 函数名():'写注释，描述信息'函数体return 返回值可以是任意类型，不写return，则默认返回None 无参函数通常情况不需要return值 12def fly():函数体 有参函数123def fly(a,b):函数体return a+b 调用函数有参 money=fly(1,2) #定义一个变量来接收return的值 无参 fly() #无参函数不写return，则默认返回None 函数的参数介绍从形参的角度分析位置参数：必须传值的参数 123def fly(x,y): print(x) print(y) 默认参数 123def fly(x,y=1): print(x) print(y) fly(1) #output : 1 1 fly(1,4) #output : 1 4 默认参数要注意的问题：默认参数必须放到位置参数的后面,def fly(x=1,y)则会报错 特殊的两种参数 * args 接收所有除了正常传参的位置传参，保存为元祖 **kwagrs 接收所有除了正常传参的关键字传参，保存为字典 例1： 1234567def fly(x, y=1, *args, **kwargs): print(x) print(y) print(args) print(kwargs) fly(1,y=78,a=1,b=2) 输出结果： 1234178()&#123;'a': 1, 'b': 2&#125; 例2： 1234567def fly(x, y=1, *args, **kwargs): print(x) print(y) print(args) print(kwargs) fly(1,20,300,78,w=1,l=2) 输出结果： 1234120(300, 78)&#123;'w': 1, 'l': 2&#125; 从实参的角度分析：第一种按位置传参 1fly(1,4) 第二种按关键字传参 12fly(x=1,y=2)fly(y=1,x=2) 第三种混着用 1fly(1,y=2) 如果写成fly(1,x=1)则会报错，因为参数只能赋值一次 如果写成fly(x=1,2)则会报错，因为按位置传值必须在按关键字传值前面 以上两条是混合实参的原则，不能违反 特殊的实参写法 1fly(*(12,16,14,15,18),**&#123;"ni":"fuck","sad":"many"&#125;) 上面的写法相当于： fly(12,16,14,15,18,ni=fuck,sad=many) 名称空间名称空间分为： 内部名称空间 全局名称空间 内置名称空间 搜索顺讯为：内置 全局 内部 闭包：内部函数包含对外部作用域而不是对全局作用域的名字的引用 下面是一个闭包例子： 123456789def f3(): x = 1 def f4(): print(x) return f4 x = 1000f4 = f3()f4() 输出结果：1 不管在哪调用内置函数，变量一定是由内向外搜索]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python文件操作]]></title>
    <url>%2F2019%2F02%2F26%2Fpython%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[流程1.打开文件 open() 2.操作文件 read write 3.关闭文件 close() 在window系统上 默认的编码是gbk 用open()打开时，window系统会使用默认的gbk编码，所以如果打开的文件是别的编码保存，则需要手动指定编码，例如打开utf-8保存的文件时 1f = open("test",encoding="utf-8") 而在linux系统上 默认的编码是utf-8 操作方法读整个文件的内容 1f.read() 读文件前5个字符的内容 1f.read(5) 如果再来一次 f.read(5),则读接下来的5个字符，read的内容取决于光标的位置 读一行 1f.readline() 一行一行打印，并移除空白 12for i in f: print(i.strip()) 写入模式1f = open("d://test1.txt", mode="w", encoding="utf-8") 当文件不存在时，会自动创建 这个模式只能写，不能读 覆盖的写 1f.write(hello\nworld) 多行一起写 1f.write(['11111\n','222222\n']) 追加模式跟w模式一样也是只能写，但是是追加的写 1f=open("d://test1.txt",mode="a",encoding="utf-8") 光标移动seek()的三种模式： （1）f.seek(p,0) 移动当文件第p个字节处，绝对位置 （2）f.seek(p,1) 移动到相对于当前位置之后的p个字节 （3）f.seek(p,2) 移动到相对文章尾之后的p个字节 seek是按字节移动 可读可写模式1.可读内容，写则是追加的写 1f=open("d://test1.txt",mode="r+",encoding="utf-8") 2.写的时候会把原来的内容覆盖,想读取内容，需要seek调整光标位置 1f=open("d://test1.txt",mode="w+",encoding="utf-8") 3.初始光标在最后，要读，则需要将光标调到初始位置，seek(0)，要写不管光标位置在哪，都是追加的写入 1f=open("d://test1.txt",mode="a+",encoding="utf-8") 新的方法可以避免忘记写close() 1with open("d://test1.txt", encoding="utf-8") as f 导入sys模块 123import syssys.stdout.write(s)sys.stdout.flush()]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python文件操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基础二]]></title>
    <url>%2F2019%2F02%2F25%2Fpython%E5%9F%BA%E7%A1%80%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[运算符算数运算 运算符 描述 实例 + 加 - 两个对象相加 a+b输出结果 30 - 减 - 得到负数 或是一个数减去另一个数 a-b输出结果 -10 * 乘 - 两个数相乘或是返回一个被重复若干次的字符串 a*b输出结果 200 / 除 - x除以y b/a 输出结果 2 % 取模 - 返回除法的余数 b%a输出结果 0 ** 幂 - 返回x的y次幂 a**b为10的20次方，输出结果10000000000000000000 // 取整除 - 返回商的整数部分 9//2输出结果4, 9.0//2.0输出结果4.0 比较运算 运算符 描述 实例 == 等于 - 比较对象是否相等 (a==b)返回False != 不等于 - 比较两个对象是否不相等 (a!=b)返回True &lt;&gt; 不等于 - 比较两个对象是否不相等 (a&lt;&gt;b)返回True。这个运算符类似!= &gt; 大于 - 返回x是否大于y (a&gt;b)返回False &lt; 小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊变量True和False等价，注意这些变量名的大写 (a&lt;b)返回True &gt;= 大于等于 - 返回x是否大于y (a&gt;=b)返回False &lt;= 小 于等于 - 返回x是否小于y (a&lt;=b)返回True 赋值运算 运算符 描述 实例 = 简单的赋值运算符 c=a+b将a+b的运算结果赋值为c += 加法赋值运算符 c+=a等效于c=c+a -= 减法赋值运算符 c-=a等效于c=c-a *= 乘法赋值运算符 等效于c=c*a /= 除法赋值运算符 c/=a等效于c=c/a %= 取模赋值运算符 c%=a等效于c=c%a **= 幂赋值运算符 等效于c=c**a //= 取整除赋值运算符 c//=a等效于c=c//1 逻辑运算 运算符 描述 实例 and 布尔”与” - 如果x为False，x and y返回False，否则它返回y的计算值 (a and b)返回True or 布尔”或” - 如果x是True，它返回True，否则它返回y的计算值 (a or b)返回True not 布尔”非” - 如果x为True，返回False。如果x为False，它返回True not(a and b)返回False 如果and 和 or 同时存在，则or将整体分成两部分看 成员运算 运算符 描述 实例 in 如果在指定的序列中找到值返回True，否则返回False x在y序列中，如果x在y序列中返回True not in 如果在指定的序列中没有找到值返回True，否则返回False x不在y序列中，如果x不在y序列中返回True 三元运算1result =值1 if 条件 else 值2 如果条件为真：result =值1 如果条件为假 ：sesult =值2 123a = 3b = 7c = a if a&lt;b else b 如果a小于b则把a的值赋给c，相反则把b的值赋给c 身份运算 运算符 描述 实例 is is是判断两个标识是不是引用自一个对象 x is y，如果id(x)等于id(y)，is返回结果1 not is is not是判断两个标识是不是引用自不同对象 x is not y，如果id(x)不等于id(y)，is返回结果1 位运算 运算符 描述 实例 &amp; 按位与运算符 (a&amp;b)输出结果12，二进制解释：0000 1100 丨 按位或运算符 (a丨b)输出结果61，二进制解释：0011 1101 ^ 按位异或运算符 (a^b)输出结果49，二进制解释：0011 0001 ~ 按位取反运算符 (~a)输出结果-61，二进制解释：1100 0011，在一个有符号二进制数的补码形式 &lt;&lt; 左移动运算符 a&lt;&lt;2输出结果240，二进制解释：1111 0000 &gt;&gt; 右移动运算符 a&gt;&gt;2输出结果15，二进制解释：0000 1111 运算符优先级 运算符 描述 ** 指数(最高优先级) ~ + - 按位翻转，一元加号和减号(最后两个方法名为+@和-@) * / % // 乘，除，取模和取整除 + - 加法减法 &gt;&gt; &lt;&lt; 右移，左移运算 &amp; 位’AND’ ^ 丨 位运算符 &lt;= &lt;&gt; &gt;= 比较运算符 &lt;&gt; == != 等于运算符 = %= /= //= -= += *= **= 赋值运算符 is is not 身份运算符 in not in 成员运算符 not or and 逻辑运算符 bytes类型Python3中内置类型bytes和str用法及byte和string之间各种编码转换Python 3最重要的新特性大概要算是对文本和二进制数据作了更为清晰的区分。文本总是Unicode，由str类型表示，二进制数据则由bytes类型表示。Python 3不会以任意隐式的方式混用str和bytes，正是这使得两者的区分特别清晰。你不能拼接字符串和字节包，也无法在字节包里搜索字符串（反之亦然），也不能将字符串传入参数为字节包的函数（反之亦然）. 1234msg = "我爱北京天安门"print(msg)print(msg.encode(encoding="utf-8"))print(msg.encode(encoding="utf-8").decode(encoding="utf-8")) 执行结果： 123我爱北京天安门b'\xe6\x88\x91\xe7\x88\xb1\xe5\x8c\x97\xe4\xba\xac\xe5\xa4\xa9\xe5\xae\x89\xe9\x97\xa8'我爱北京天安门 格式化%s 字符串 例： 123456789101112131415161718192021string="hello"#%s打印时结果是helloprint "string=%s" % string # output: string=hello#%2s意思是字符串长度为2，当原字符串的长度超过2时，按原长度打印，所以%2s的打印结果还是helloprint "string=%2s" % string # output: string=hello#%7s意思是字符串长度为7，当原字符串的长度小于7时，在原字符串左侧补空格，#所以%7s的打印结果是 helloprint "string=%7s" % string # output: string= hello#%-7s意思是字符串长度为7，当原字符串的长度小于7时，在原字符串右侧补空格，#所以%-7s的打印结果是 helloprint "string=%-7s!" % string # output: string=hello !#%.2s意思是截取字符串的前2个字符，所以%.2s的打印结果是heprint "string=%.2s" % string # output: string=he#%.7s意思是截取字符串的前7个字符，当原字符串长度小于7时，即是字符串本身，#所以%.7s的打印结果是helloprint "string=%.7s" % string # output: string=hello#%a.bs这种格式是上面两种格式的综合，首先根据小数点后面的数b截取字符串，#当截取的字符串长度小于a时，还需要在其左侧补空格print "string=%7.2s" % string # output: string= heprint "string=%2.7s" % string # output: string=helloprint "string=%10.7s" % string # output: string= hello %d 整数 %f 浮点数 编码 在python3中不需要申明编码 从英文意思上看，encode和decode分别指编码和解码。在python中，Unicode类型是作为编码的基础类型，即： 12decode encodestr ---------&gt; str(Unicode) ---------&gt; str 12345678910111213141516171819&gt;&gt;&gt; u = '中文' # 指定字符串类型对象u &gt;&gt;&gt; str1 = u.encode('gb2312') # 以gb2312编码对u进行编码，获得bytes类型对象&gt;&gt;&gt; print(str1)b'\xd6\xd0\xce\xc4' &gt;&gt;&gt; str2 = u.encode('gbk') # 以gbk编码对u进行编码，获得bytes类型对象&gt;&gt;&gt; print(str2)b'\xd6\xd0\xce\xc4'&gt;&gt;&gt; str3 = u.encode('utf-8') # 以utf-8编码对u进行编码，获得bytes类型对象&gt;&gt;&gt; print(str3)b'\xe4\xb8\xad\xe6\x96\x87' &gt;&gt;&gt; u1 = str1.decode('gb2312') # 以gb2312编码对字符串str进行解码，获得字符串类型对象&gt;&gt;&gt; print('u1')'中文' &gt;&gt;&gt; u2 = str1.decode('utf-8') # 报错，因为str1是gb2312编码的UnicodeDecodeError: 'utf-8' codec can't decode byte 0xd6 in position 0: invalid continuation byte 其他break 跳出本层循环 continue 跳出本次循环 1234567for i in range(10): print(i) if i ==5: breakelse: print("done")print("done2") 只有正常结束for循环才会执行else的命令，所以done不会被输出 判断是否为数字 isdigit() 取嵌套列表的值 name = [12,23,34,[34,55]] 取55的值 ：name[3][1]]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>运算符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基础一]]></title>
    <url>%2F2019%2F02%2F25%2Fpython%E5%9F%BA%E7%A1%80%E4%B8%80%2F</url>
    <content type="text"><![CDATA[数据类型数字整型 int 长整型 long 浮点型 float 复数 complex 字符str它只是人类可读的一种抽象表示形式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263name="helloworld" name.capitalize() #将字符串变成首字母大写，其他全部小写 name.casefold() #将字符串变成全部变小写 nam.lower() #将字符串变成全部变小写 name.upper() #将字符串变成全部变大写 name.swapcase() #大小写互换 name.center(50,'-') #将字符串长度变成50，且字符串居中,不够的由-填充，如果50后面不写，则默认空格填充 name.ljust(50,'-') #同上，字符串左对齐 name.rjust(50,'-') #同上，字符串右对齐 name.count('e') #查找整个字符串有几个e name.count('e',2,4) #从字符串的第3到4中找有几个e ,含头不含尾 name.startwith() #以..什么开头 name.endwith() #以..什么结尾 name.expandtabs(10) #定义\t的长度 name.find('h') #查找h的位置 name.index('h') #返回h的索引值 name.find('h',2,6) #在3到6之间找第一个h的位置，返回的是整个字符串的位置，找不到-1 name.format() #format的用法是： name=“hello&#123;0&#125;,fuck&#123;1&#125;” name.format('world',144) # output: helloworld,fuck144 “-”.join(["fuck","u","every","day"]) # output:fuck-u-every-day 将列表的内容用指定的字符串串起来，变成一个字符串 name.lstrip() #从左边开始删指定的字符串 name.rstrip() #从右边开始删指定的字符串 name.replace('he','she') #把he替换成she name.replace('he','she',1) #把he替换成she,只替换一次 name.strip() #移除空白 len(name) #判断 name.index("f") #以0开始，索引 name[0:8] #从第1个切到第8个 取头不取尾(切得最后一个不取) name[-6:] #从倒数第5个切到最后一个，因为-1在尾部，取不到，直接不写 name[2::2] #从第3个开始，隔2个取一个 布尔型boolbool，从Python2.3开始Python中添加了布尔类型。布尔类型有两种True和False。对于没有nozero方法的对象默认是True。 bool运算： 以下情况都为False [] 空列表 {} 空字典 空集合 () 空元祖 ‘’ 空字符串 0 数字0 list 列表list [] name=[“萨德”,”委屈”,”多行”,”太容易”,”电风扇”] name[0] 取第一个的值 name.index(“多行”) 查询多行的位置 得到结果 2 name.count(“太容易”) 查询太容易在列表中数量 name.append(“付出”) 追加 name.insert(4,”陈涛”) 把陈涛插到4的位置 name.pop(4) 删除第四个 ()内不写则默认删除最后一个 name.remove(“陈涛”) 删除成涛 del name[0] 删除第一个 name[name.index(“陈涛”)]=”水” 修改陈涛为水 dict 字典字典(dictionary)是除列表之外python中最灵活的内置数据结构类型。列表是有序的对象结合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。 字典由键和对应的值组成。字典也被称作关联数组或哈希表。基本语法如下： 1dict = &#123;'Alice': '2341', 'Beth': '9102', 'Cecil': '3258'&#125;; 也可如此创建字典： 12dict1 = &#123; 'abc': 456 &#125;;dict2 = &#123; 'abc': 123, 98.6: 37 &#125;; 可以字典中加字典，嵌套 key必须是唯一的 实例：name = {1 : [’fuck‘], 2 : [‘fuck’], 3: {’name‘:’d‘}, 34 : [‘wzc’,’hsy’] } 增name[34].append(“love”) 在key为34中添加值love name[”nice“]=”whatever“ 在name中新插入key为nice,value为whatever的键/值对 删name.pop(34) 删除key为34的键/值对 del name[34] 删除key为34的键/值对 改name[34][0]=’’love’’ 将key为34内的第一个值改为love name[24]=name.pop(34) 将key名为34的改成24，值不变 查name.get(34) 查找key为34的值，没有则返回None name[34] 查找key为34的值，没有则报错 113 in name 判断字典中是否有key为113的键/值对 name.keys() 查找字典中所有的key name.values() 查找字典中所有的值 循环for i in name: print( i ,name[i] ) 更新name.update(name1) 将name1的键值对合并到name中，如果两者之间有相同名字的key，则取name1中的值 set 集合集合与字典的区别是没有key值 特点：天然去重，无序 12345678910111213141516171819202122232425262728linux = &#123;"alex", "jack", "rain", "lizhi", "sb", "lizhi"&#125;python = &#123;"sb", "alex", "mack", "rachel"&#125; print(linux.intersection(python)) # 交集print(linux &amp; python) # 交集print(linux.difference(python)) # 差集 linux中有而python中没有print(linux - python) # 差集 linux中有而python中没有print(linux.union(python)) # 并集print(linux | python) # 并集print(linux.symmetric_difference(python)) # 对称 互相不在的都打印print(linux ^ python) # 对称 互相不在的都打印 linux.add() #增加 linux.clear() #把linux集合中内容删光 linux.update(python) #把python合并到linux集合中 linux.discard("alex") #把linux中的alex删除，元素不存在不会报错 linux.remove('alex') #把linux中的alex删除，元素不存在会报错 linux.pop() #随机删除一个 linux.issubset(python) #判断linux是不是python的子集 linux.issuperset(python) #判断linux是不是python的父集 linux.isdisjoint(python) #如果两个集合没有任何关联，则返回Ture tuple 元祖元组类型在很多操作上都跟列表一样，许多用在列表上的例子在元组上照样能跑，我们有一节内容专门讲解元组类型。它们的主要不同在于元组是不可变的，或者说是只读的，所以那些用于更新列表的操作，比如用切片操作来更新一部分元素的操作，就不能用于元组类型 12345678CPython&gt;&gt;&gt; a = ('a','123',['a',123])&gt;&gt;&gt; a('a', '123', ['a', 123])&gt;&gt;&gt; type(a)&lt;class 'tuple'&gt;&gt;&gt;&gt; tu = tuple('abcde')&gt;&gt;&gt; tu('a', 'b', 'c', 'd', 'e') 列表与字典的一个methodname=[21,23,454[34,123]] h=name.copy() 当改变h[0],h[1],h[2]这些值时，name中的不变 但改变h[3]时 h[3][0]=56 name中也会变 同理 n1={12:”asda”,24:”asdasd”,33:[78,34]} n2=n1.copy() 更改n1[12]的值，n2不变 更改 n1[33][0]的值，n2中也会变 转换类型int(x [,base ]) 将x转换为一个整数 long(x [,base ]) 将x转换为一个长整数 float(x ) 将x转换到一个浮点数 complex(real [,imag ]) 创建一个复数 str(x ) 将对象 x 转换为字符串 repr(x ) 将对象 x 转换为表达式字符串 eval(str ) 用来计算在字符串中的有效Python表达式,并返回一个对象 tuple(s ) 将序列 s 转换为一个元组 list(s ) 将序列 s 转换为一个列表 chr(x ) 将一个整数转换为一个字符 unichr(x ) 将一个整数转换为Unicode字符 ord(x ) 将一个字符转换为它的整数值 hex(x ) 将一个整数转换为一个十六进制字符串 oct(x ) 将一个整数转换为一个八进制字符串 编码utf -8 英文1个字节 中文3个字节 gbk 中文2个字节]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo的next主题详细配置]]></title>
    <url>%2F2019%2F02%2F23%2Fhexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E8%AF%A6%E7%BB%86%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 为了描述方便，在以下说明中，将前者称为站点配置文件， 后者称为主题配置文件。 以下所有终端执行的命令都在你的Hexo根目录下 基本信息配置打开 站点配置文件 ，找到Site模块 123456title: 标题subtitle: 副标题description: 描述author: 作者language: 语言（简体中文是zh-Hans）timezone: 网站时区（Hexo 默认使用您电脑的时区，不用写） 关于 站点配置文件 中的其他配置可参考站点配置 菜单设置菜单包括：首页、归档、分类、标签、关于等等 我们刚开始默认的菜单只有首页和归档两个，不能够满足我们的要求，所以需要添加菜单，打开 主题配置文件 找到Menu Settings 看看你需要哪个菜单就把哪个取消注释打开就行了； 关于后面的格式，以archives: /archives/ || archive为例： || 之前的/archives/表示标题“归档”，关于标题的格式可以去themes/next/languages/zh-Hans.yml中参考或修改 ||之后的archive表示图标，可以去Font Awesome中查看或修改，Next主题所有的图标都来自Font Awesome Next主题样式设置我们百里挑一选择了Next主题，不过Next主题还有4种风格供我们选择，打开 主题配置文件 找到Scheme Settings 12345# Schemes# scheme: Muse# scheme: Mist# scheme: Piscesscheme: Gemini 4种风格大同小异，本人用的是Gemini风格，你们可以选择自己喜欢的风格 侧栏设置开启侧边栏社交链接1234567891011# Social linkssocial: GitHub: https://github.com/hydcoder Weibo: https://weibo.com/3180967953/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo # 等等social_icons: enable: true # Icon Mappings. GitHub: github Weibo: weibo 开启打赏功能123reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！wechatpay: 你的微信收款码链接alipay: 你的支付宝收款码链接 开启友情链接1234links_title: Linkslinks: MacTalk: http://macshuo.com/ Title: http://example.com/ 开启订阅微信公众号1234wechat_subscriber:enabled: trueqcode: /uploads/wechat-qcode.jpgdescription: 欢迎您扫一扫上面的微信公众号，订阅我的博客！ 头像设置打开 主题配置文件 找到Sidebar Avatar字段 12# Sidebar Avataravatar: /images/header.jpg 这是头像的路径，只需把你的头像命名为header.jpg（随便命名）放入themes/next/source/images中，将avatar的路径名改成你的头像名就OK啦！ 设置侧边栏设置圆形可旋转头像 找到生成的Hexo目录\themes\next\source\css_common\components\sidebar下的sidebar-author.styl，将里面的css样式内容全部替换为： 123456789101112131415161718192021222324252627282930313233.site-author-image &#123; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; border-radius: 50%; -webkit-border-radius: 50%; -moz-border-radius: 50%; transition: 1.4s all;&#125;.site-author-image:hover &#123; -webkit-transform: rotate(360deg); -moz-transform: rotate(360deg); -ms-transform: rotate(360deg); -transform: rotate(360deg);&#125;.site-author-name &#123; margin: $site-author-name-margin; text-align: $site-author-name-align; color: $site-author-name-color; font-weight: $site-author-name-weight;&#125;.site-description &#123; margin-top: $site-description-margin-top; text-align: $site-description-align; font-size: $site-description-font-size; color: $site-description-color;&#125; 设置首页不显示全文(只显示预览)打开主题配置文件_config.yml，ctrl + F搜索找到”auto_excerpt”，可以看见 12345# Automatically Excerpt. Not recommand.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt:enable: falselength: 150 把enable改为对应的false改为true，length就是预览显示的文字长度，你可以根据你的需要进行更改，然后重新部署，再进主页，你就发现你首页的文章多了一个阅读全文的按钮。 添加动态背景先上张图 打开生成的Hexo目录\themes\next/layout/_layout.swig文件，在 &lt; head&gt;中的添加代码 123&#123;% if theme.canvas_nest %&#125;&lt;script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"&gt;&lt;/script&gt;&#123;% endif %&#125; 打开主题配置文件，搜索canvas_nest，将其改成true 1canvas_nest: true 什么？线条太多了？没事，来看看怎么让线条变少点 在上一步修改的主题配置文件中，把刚才的那些代码改成下面这样： 1234&#123;% if theme.canvas_nest %&#125;&lt;script type="text/javascript"color="0,0,255" opacity='0.7' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"&gt;&lt;/script&gt;&#123;% e 配置项说明 color ：线条颜色, 默认: ‘0,0,0’；三个数字分别为(R,G,B) opacity: 线条透明度（0~1）, 默认: 0.5 count: 线条的总数量, 默认: 150 zIndex: 背景的z-index属性，css属性用于控制所在层的位置, 默认: -1 分类和标签设置这里主要说的是在编写文章的时候，怎么给文章设置标签和分类。 首先通过hexo n &quot;name&quot;命令来新建一个页面，在source/_posts目录下找到刚才新建的name.md文件，用Typora或者notepad++t打开(推荐Typora) 1234title: namedate: 2014-08-05 11:15:00 tags: --- 页面默认就是长这样的，可以编辑标题、日期、标签和内容，但是没有分类的选项。我们可以手动加入categories:项,但是下次创建新的页面的时候还是没有，所以我们直接打开scaffolds/post.md文件，在tages:上面加入categories:,保存后，重新执行hexo n ‘name’命令，会发现新建的页面里有categories:项了。 scaffolds目录下，是新建页面的模板，执行新建命令时，是根据这里的模板页来完成的，所以可以在这里根据你自己的需求添加一些默认值。 设置分类列表在我们编辑文章的时候，直接在categories:项填写属于哪个分类，但如果分类是中文的时候，路径也会包含中文。 比如分类我们设置的是： 1categories: 开车 那在生成页面后，分类列表就会出现开车这个选项，他的访问路径是： 1*/categories/开车 我们都知道，有时候中文路径可能会出现一些奇奇怪怪的问题，所以我们需要路径名和分类名分别设置。 打开站点配置文件_config.yml，找到如下位置做更改： 1234567# Category &amp; Tagdefault_category: uncategorizedcategory_map: 开车: drive 生活: life 其他: othertag_map: 在这里category_map:是设置分类的地方，每行一个分类，冒号前面是分类名称，后面是访问路径。可以提前在这里设置好一些分类，当编辑的文章填写了对应的分类名时，就会自动的按照对应的路径来访问。 设置标签在编辑文章的时候，tags:后面是设置标签的地方，如果有多个标签的话，可以用下面两种办法来设置： 第一种： 1tages: [标签1,标签2,...标签n] 第二种： 12345 tages: - 标签1- 标签2...- 标签n 添加文章更新时间修改（博客主目录）/themes/next/layout/_macro/post.swig 文件，在&lt;span class=&quot;post-time&quot;&gt;...&lt;/span&gt;标签后添加 12345678&#123;%if post.updated and post.updated &gt; post.date%&#125; &lt;span class="post-updated"&gt; &amp;nbsp; | &amp;nbsp; &#123;&#123; __('post.updated') &#125;&#125; &lt;time itemprop="dateUpdated" datetime="&#123;&#123; moment(post.updated).format() &#125;&#125;" content="&#123;&#123; date(post.updated, config.date_format) &#125;&#125;"&gt; &#123;&#123; date(post.updated, config.date_format) &#125;&#125; &lt;/time&gt; &lt;/span&gt;&#123;% endif %&#125; 根据博客配置文件中的 language 参数修改对应的语言配置文件（博客主目录）/themes/next/languages/zh_Hans.yml 12post: updated: 更新于 修改主题配置文件（博客主目录）/themes/next/_config.yml，增加一行 1display_updated: true 或者写文章的时候可以直接在文章开头设置更新时间，没有这参数的话将会显示md文件的修改日期 1updated: 2018-01-01 12:00:00 添加搜索功能安装 hexo-generator-searchdb 插件 1$ npm install hexo-generator-searchdb --save 打开 站点配置文件 找到Extensions在下面添加 123456# 搜索search: path: search.xml field: post format: html limit: 10000 3、打开 主题配置文件 找到Local search，将enable设置为true 添加阅读全文按钮因为在你的博客主页会有多篇文章，如果你想让你的文章只显示一部分，多余的可以点击阅读全文来查看，那么你需要在你的文章中添加 1&lt;!--more--&gt; 其后面的部分就不会显示了，只能点击阅读全文才能看 修改文章内链接文本样式打开文件 themes/next/source/css/_common/components/post/post.styl，在末尾添加 12345678910.post-body p a &#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125; 其中选择 .post-body 是为了不影响标题，选择 p 是为了不影响首页“阅读全文”的显示样式,颜色可以自己定义。 设置网站缩略图标从网上看了很多设置方法都是说把favicon.ico放到站点目录的source目录下就可以了，可是我试了好多遍，并不行 我的设置方法是这样的：把你的图片（png或jpg格式，不是favicon.ico）放在themes/next/source/images里，然后打开 主题配置文件 找到favicon，将small、medium、apple_touch_icon三个字段的值都设置成/images/图片名.jpg就可以了，其他字段都注释掉。 设置文章字体的颜色、大小 如果想设置某一句的颜色或大小，只需用html语法写出来就行了 1234接下来就是见证奇迹的时刻&lt;font color="#FF0000"&gt; 我可以设置这一句的颜色哈哈 &lt;/font&gt; &lt;font size=6&gt; 我还可以设置这一句的大小嘻嘻 &lt;/font&gt; &lt;font size=5 color="#FF0000"&gt; 我甚至可以设置这一句的颜色和大小呵呵&lt;/font&gt; 设置文字居中1&lt;center&gt;这一行需要居中&lt;/center&gt; 添加评论系统目前国内比较有名的多说、网易云跟帖评论系统都已停止服务了，国外的Disqus评论系统还得需要翻墙，所以不推荐使用，剩下的还有搜狐畅言、友言、来必力等。本来想使用畅言的，结果注册完之后还得要求备案，我只想说F开头的那个单词，果断放弃。后来选择了友言 1、进入友言官网注册、登录步骤我就不介绍了2、登录完成之后，点击获取代码，你会发现出来了一段代码，里面有你的uid=12345673、打开 主题配置文件 找到youyan_uid将值设置为上面的uid就可以了 添加站点访问计数站点访问计数有名的就是不蒜子，使用起来非常方便1、安装脚本打开 themes/next/layout/_partial/footer.swig，将下面这段代码添加到里面 12345678910&lt;div&gt;&lt;script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt;&lt;span id="busuanzi_container_site_pv" style='display:none'&gt; 本站总访问量 &lt;span id="busuanzi_value_site_pv"&gt;&lt;/span&gt; 次 &lt;span class="post-meta-divider"&gt;|&lt;/span&gt;&lt;/span&gt;&lt;span id="busuanzi_container_site_uv" style='display:none'&gt; 有&lt;span id="busuanzi_value_site_uv"&gt;&lt;/span&gt;人看过我的博客啦&lt;/span&gt;&lt;/div&gt; 添加的位置如下图，可自行根据个人喜好更换位置 2、以上只是显示站点的访问次数，如果想显示每篇文章的访问次数，打开 themes/next/layout/_macro/post.swig，在第一行增加is_pv字段 1&#123;% macro render(post, is_index, is_pv, post_extra_class) %&#125; 然后将这段代码插入到里面 1234&#123;% if is_pv %&#125; &lt;span class="post-meta-divider"&gt;|&lt;/span&gt; &lt;span id="busuanzi_value_page_pv"&gt;&lt;/span&gt;次阅读&#123;% endif %&#125; 插入的位置 然后再打开 themes/next/layout/post.swig，这个文件是文章的模板，给render方法传入参数（对应刚才添加的is_pv字段） 最后再打开 themes/next/layout/index.swig，这个文件是首页的模板，给render方法传入参数（对应刚才添加的is_pv字段） OK！设置完毕 去掉文章目录标题的自动编号我们自己写文章的时候一般都会自己带上标题编号，但是默认的主题会给我们带上编号，很是别扭，如何去掉呢？打开主题配置文件，找到 123456789# Table Of Contents in the Sidebartoc: enable: true # Automatically add list number to toc. number: true # If true, all words will placed on next lines if header width longer then sidebar width. wrap: false 将number改为false即可 自定义样式 引用需加入custom.styl的代码 文件位置：~/blog/themes/next/source/css/_custom/custom.styl 123456789// 自定义的引用样式blockquote.question &#123; color: #555; border-left: 4px solid rgb(16, 152, 173); background-color: rgb(227, 242, 253); border-top-right-radius: 3px; border-bottom-right-radius: 3px; margin-bottom: 20px;&#125; 文字颜色改color的值 背景色改background-color的值 边框颜色和粗细改border-left的值 效果： 内容 使用方法： 1&lt;blockquote class="question"&gt;内容&lt;/blockquote&gt; 修改hexo的主题nexT中的Pisces主题宽度在source/css/_schemes/Picses/_layout.styl文件末尾添加如下代码 12345678910111213141516171819202122232425262728293031323334// 以下为新增代码！！header&#123; width: 90% !important; &#125;header.post-header &#123; width: auto !important;&#125;.container .main-inner &#123; width: 90%; &#125;.content-wrap &#123; width: calc(100% - 260px); &#125;.header &#123; +tablet() &#123; width: auto !important; &#125; +mobile() &#123; width: auto !important; &#125;&#125;.container .main-inner &#123; +tablet() &#123; width: auto !important; &#125; +mobile() &#123; width: auto !important; &#125;&#125;.content-wrap &#123; +tablet() &#123; width: 100% !important; &#125; +mobile() &#123; width: 100% !important; &#125;&#125; 更多还有其他更多的主题配置，请查看主题配置 还有其他更多的插件，请查看Hexo插件]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>next主题配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何更换hexo博客主题]]></title>
    <url>%2F2019%2F02%2F23%2F%E5%A6%82%E4%BD%95%E6%9B%B4%E6%8D%A2hexo%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%2F</url>
    <content type="text"><![CDATA[在成功用github+hexo搭建好个人博客之后，原生的主题一般不大讨喜。在此，简单介绍一下如何找一个自己喜欢的主题并运用到自己的博客中： 挑个好看的主题hexo官方：Themes 知乎话题：有哪些好看的 Hexo 主题？ 下载用git bash，进入到博客的本地目录中 然后使用clone的方法将想要的主题下载下来。（我选用的是NexT主题） 1$ git clone https://github.com/theme-next/hexo-theme-next themes/next 修改配置文件，安装git克隆完成后，打开当前目录下的“_config.yml”配置文件。 找到theme的配置选项，一般在文件的最后。之后，将theme选项配置为我们新下载好的next主题即可。（“：”冒号之后空格不可少） 调试，发布回到git bash，输入调试命令： 1hexo server --debug 在浏览器中输入localhost:4000查看 在本地查看无误之后，输入生成和发布命令,就可已将新主题发布到自己的博客网站上了 12hexo ghexo d 如出现缓存引起的异常，可以在生成命令前执行清除缓存命令 1hexo clean 完成做完这些之后，就可以打开你的博客网站，查看新更换的主题效果了。]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>hexo更换主题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用hexo+github搭建属于自己的博客]]></title>
    <url>%2F2019%2F02%2F23%2F%E4%BD%BF%E7%94%A8hexo-github%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[一、注册GitHub账号（已经有GitHub账号的请忽略这一步）先在Github注册一个账号:https://github.com/ 新建项目，项目必须要遵守格式：账户名.github.io，不然接下来会有很多麻烦。并且需要勾选Initialize this repository with a README 在建好的项目右侧有个settings按钮，点击它，向下拉到GitHub Pages，你会看到那边有个网址，访问它，你将会发现该项目已经被部署到网络上，能够通过外网来访问它。 二、环境搭建下载Node.js安装文件现在电脑基本都是64位的，我就放64位的下载地址：https://nodejs.org/dist/v8.9.4/node-v8.9.4-x64.msi 或者自行到官网下载最新版本： https://nodejs.org 安装Git：Git下载包（64位） Git下载包（32位） 完成之后到桌面空白处单击鼠标右键，选择Git Bash Here进入bash窗口输入命令 node -v 和 npm -v 验证安装是否成功,成功界面如下 三、Hexo安装Hexo简介Hexo是什么呢？也许引用Hexo官方文档里面的说明是再好不过了： 1Hexo is a fast, simple and powerful blog framework. You write posts in Markdown (or other languages) and Hexo generates static files with a beautiful theme in seconds. 1Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装Git下载地址：https://git-scm.com/download，按照默认傻瓜式安装就好了 补充一句，如果你已经安装了Git，你可以通过Git本身获得最新的开发版本： 1$ git clone https://github.com/git/git 完成之后到桌面空白处单击鼠标右键，如果有出现Git Bash Here选项则证明已经安装成功 下载Hexo在桌面空白处单击鼠标右键，选择Git Bash Here进入bash窗口，在自己认为合适的地方创个文件夹，我是在D盘建了一个blog文件夹。然后通过命令行进入到该文件夹里面 再输入命令 npm install -g hexo 下载Hexo 1$ npm install -g hexo 等待完成之后，输入命令 hexo -v 验证安装是否成功 初始化输入hexo init，初始化该文件夹 输入npm install，安装所需要的组件 输入hexo g，首次体验Hexo 输入hexo s，开启服务器，访问该网址，正式体验Hexo 问题：假如页面一直无法跳转，那么可能4000端口被占用了。此时我们ctrl+c停止服务器，接着输入hexo server -p 端口号来改变端口号 那么出现如下图就成功了 四、将Hexo与Github page联系起来安装插件打开git bash，进入hexo根文件夹，输入npm install hexo-deployer-git --save 命令安装插件 配置SSH设置全局配置user.name 和user.email（如果是第一次的话） 12git config –-global user.name “shuaibi” //(“”的账号是刚才Github里面自己注册的账号) git config –-global user.email “okjbk.gmail.com” //(""的邮箱是你自己注册的邮箱) 输入cd ~/.ssh，检查是否有.ssh的文件夹 输入ssh-keygen -t rsa -C &quot;ojbk.gmail.com&quot;(&quot;&quot;中间写你直接设置的邮箱)，连续三个回车，生成密钥，最后得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\Users\Administrator.ssh）。 输入eval &quot;$(ssh-agent -s)&quot;，添加密钥到ssh-agent 再输入ssh-add ~/.ssh/id_rsa，添加生成的SSH key到ssh-agent 登录Github，点击头像下的settings，添加ssh 新建一个new ssh key，将id_rsa.pub文件里的内容复制上去 回到git bash 输入ssh -T git@github.com，测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明成功了 问题: 假如ssh-key配置失败，那么只要以下步骤就能完全解决 首先，清除所有的key-pairssh-add -Drm -r ~/.ssh删除你在github中的public-key 重新生成ssh密钥对ssh-keygen -t rsa -C “xxx@xxx.com“ 接下来正常操作在github上添加公钥public-key:1、首先在你的终端运行 xclip -sel c ~/.ssh/id_rsa.pub将公钥内容复制到剪切板2、在github上添加公钥时，直接复制即可3、保存 测试： 在终端 ssh -T git@github.com 配置配置Deployment，在根文件夹中，找到_config.yml文件，修改repo值（在末尾） 1234deploy: type: git repository: git@github.com:RobotNo42/RobotNo42.github.io.git branch: master repo值是你在github项目里的ssh（右下角） 部署用git bash部署hexo到github hexo server 或者 hexo s hexo generate 或者 hexo g hexo deploy 或者 hexo d 看到这样的进程，代表成功部署hexo到github 等待10分钟左右，打开用户名.github.io,会出现如下界面（代表成功搭建博客）：]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>hexo+github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LINUX命令三]]></title>
    <url>%2F2019%2F02%2F23%2FLINUX%E5%91%BD%E4%BB%A4%E4%B8%89%2F</url>
    <content type="text"><![CDATA[网络相关配置ifconfig 查看ip信息 远程复制 scp /etc/h.txt 192.168.1.1:/tmp 配置ssh（之后访问无需密码）： ssh-keygen ssh-copy-id -i 192.168.1.16 赋值变量 x=2 调用x echo $x 取消变量 unset x 设置别名 alias x=‘ls /’ 将命令得到的结果赋值到变量 x=$(ls) 搜索文件 ls [a-z][0-9].txt []代表在中间取一个值, a-z代表aAbBcC…..z不包含Z ls [!0-9],txt 查找不以数字开头的文件 执行历史命令 ！638 查看上条命令执行是否成功 echo $? 成功则为0 注释 || 前面命令成功，则后面不执行 ；只有前面命令失败后面才执行 &amp;&amp; 只有前面的命令执行成功才会执行后面的命令 \ 转义符号 ? 匹配一个任意字符 例： ls ???.txt 固化命令在登录时就加载出命令 在/etc/bashrc 文件中添加想要的命令 grep命令grep -A 2 ‘fuck’ /etc/passwd 显示查询结果及后两行 grep -B 2 ‘fuck’ /etc/passwd 显示查询结果及前两行 grep -C 2 ‘fuck’ /etc/passwd 显示查询结果及前后两行 grep -c ‘fuck’ /etc/passwd 显示查询行数 grep -i ‘fuck’ /etc/passwd 无视大小写查询 grep -v ‘fuck’ /etc/passwd 取目标之外的剩余结果 grep -w ‘fuck’ /etc/passwd 单词匹配 grep -rl ‘fuck’ /etc/passwd 匹配文件内容中带fuck的文件路径 正则grep ‘^root’ 匹配以root开头的 grep ‘root$’ 匹配以root结尾的 grep ‘a.b’ .代表任意一个字符 grep ‘ab‘ 代表b有0个或者多个 grep ‘ab?’ 代表b有0个或者1个 egrep ‘ab+’ 必须用egrep +代表b有1个或者多个 egrep ‘ab{2}’ 2个b egrep ‘ab{2，4}’ 2到4个b egrep ‘ab{2，}’ 2个以上b egrep ‘[abc\ / -]’ 含abc/-中一个字符的 [a-z] 代表所有的小写字母 [A-Z] 代表所有的大写字母 [a-Z] 代表所有的大小写字母 注意点如果要匹配的是-本身，则必须放到最后[asd-] echo ^[^0-9] 匹配不是数字开头的 sed命令sed ‘3d’ 删除第三行 sed ‘1,4d’ 删除1-4行 sed ‘1;4d’ 删除第1行和第4行 sed ‘s/sb/fuck’ 把所有行的第一个sb换成fuck sed ‘s/sb/fuck/g’ 把所有行的所有sb换成fuck sed ‘3p’ 打印第三行 sed ‘3c 123456’ 把第三行改成123456 sed ‘3a 123’ 在第三行后插入123 sed ‘3i 123’ 在第三行前插入123 sed’/^root/d’ 加入正则法 sed -r ‘/^[0-9][a-Z]+sb$/ s/sb/SB/g’ r为扩展模式 sed -ri 多加一个i则是直接将文件内容改掉，而不是仅仅输入到终端 sed -r ‘s/^([a-Z]+)([^a-Z])([a-Z]+)([^a-Z])/\3\2\1\4/‘ 将第一个单词和第三个单词换位置 sed -r ‘s/ //g’ 将所有的空格去掉 sed -r ‘s/[0-9]//g’ 将所有的数字去掉 awk文本处理awk -F: ‘{print $1,$7}’ 打印以：为分隔符取第1段和第7段 (:后面加空格) awk -F: ‘{print $1,$NF}’ 打印以：为分隔符取第1段和最后一段 awk -F: ‘NR&lt;=3{print $1,NR}’ 打印前三行的第一段 awk -F: ‘NR&lt;=3{print NR,”—–”,$1}’ 打印出前三段 1——root 的样式 awk -F: ‘/log$/{print $1}’ 匹配有log的行，打印第1段 awk -F: ‘$1~/^r.*t$/{print $3}’ 匹配第一段中以r开头t结尾的行，并打印出这些行的第三段 awk -F: ‘$1==”root”{print $3,NR}’ 匹配第一段是root的行，并打印出这些行的第三段和行号 awk -v x=$count -F: ‘$3&gt;=x{print NR,$1}’ 匹配第三段大于参数x的行，打印行号和第一段 其他命令cat a.txt |sort |uniq 排序 去重 du -sh 统计文件大小 find /file -name “*.txt” 查找file文件夹中以txt结尾的文件 find /file -size +30M 查找file文件夹中大于30M的文件 find /file -size +10M -30M 查找file文件夹中大于10M小于30M的文件 变量linux 没有数据类型之分 set 显示所有变量 env 显示环境变量 变量关系操作test [] 括号里前后要空格 测试数值[ $x -gt $y ] 判断x的值大于y [ $x -ge $y ] 判断x大于等于y [ $x -lt $y ] 判断x小于y [ $x -le $y ] 判断x小于等于y [ $x -eq $y ] 判断x等于y [ $x -ne $y ] 判断x不等于y [ $x -gt $y -a $a -eq $b ] 判断x大于y并且a等于b [ $x -gt $y -o $a -eq $b ] 判断x大于y或者a等于b 测试文件状态-d 目录 -f 普通文件- -w 可写 -r 可读 -x 可执行 3.字符串测试 = 两字符串相等 != 两字符串不相等 -z 空串 -n 非空串 赋值运算符 ((x=x+1)) ——–((x+=1)) echo $((x-=2)) expr $x + $y echo “scale=2;20/100” | bc -l 保留两位小数 bc要先安装]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LINUX命令二]]></title>
    <url>%2F2019%2F02%2F22%2FLINUX%E5%91%BD%E4%BB%A4%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[打包压缩打包命令 tar -cvf /test.tar /a.txt /b.txt /c.txt 查看包内的内容 tar -tf /test.tar 解压包到当前目录 tar -xvf /test.tar 解压包到指定目录 tar -xvf /test.tar -C /try 压缩文件 gzip /test.tar (压缩快但大) 或者bzip2 /test.tar （压缩慢但小） 解压文件 tar -xf /test.tar.zp tar-xf /test.tar.bz2 打包并同时压缩文件tar -cvzf /test.tar.zp /a.txt /b.txt /c.txt 或 tar -cvjf /test.tar.bz2 /a.txt /b.txt /c.txt 如果要连同目录一起压缩则最后用/ 如果只想压缩目录下面的文件则/* vi查看并编辑文档 vim 按a 编辑 按 :wq 保存并退出 q！不保存 x 小写的x表示向后删除一个字符,也就是删除光标所在字符 nx n表示数字，表示向后删除每个字符，例如：10x表示删除包括光标在内的后面10个字符 dd 删除当前一行 ,就是截切 ndd删除n行（例如3dd删除3行） yy复制一行 nyy复制n行 p 粘贴到目标位置的下一行 P 粘贴到目标位置的上一行 u 撤销上一步操作 ctrl+r 返回前一步 gg 光标移动到文件的第一行 G 光标移动到文件的最后一行 nG 光标移动到文件的第n行 dgg 删除光标所在行到第一行数据 dG 删除光标所在行到最后一行数据 磁盘分区/dev fdisk -l /dev/sda 查看磁盘信息 fdisk /dev/sdb 进入磁盘分区 p 输出目前磁盘分区信息 n 分区 分为p主分区 e扩展分区 d 删除分区 给分区装装指定系统 mkfs.xfs /dev/sdb1 挂载一个目录 mount /dev/sdb1 /test 卸除挂载目录 umount /dev/sdb1 一个分区挂载两个目录时，则两个目录同时指向该分区，即同步 df 查看磁盘分区信息 df-Th 创建软连接相当于创建快捷方式ln -s /test/a.txt /sb/a.txt 前面是被创建的软连接 内存查看内存信息 swapon -s 增加内存区 mkswap /dev/sdb2 swapon -a /dev/sdb2 删除内存区swapoff /dev/sdb2 查看内存 free 进程firefox &amp; 后台运行程序 ps aux 查看全部进程 ps aux|grep fire 查找带fire的进程 pgrep firefox 查找firefox进程号 kill -9 3315 强制杀死进程(3315代表进程编号) pkill -9 firefox 指定名称的杀死进程 软件安装二进制软件安装 rpm -ivh /vsf-3.0.2-9.e17.x86_64.rpm覆盖安装 rpm -ivh /vsf-3.0.2-9.e17.x86_64.rpm –force 查看系统中所有安装的rpm包 rpm -qa 查看指定的包 rpm -qa|grep vsf 查看rpm包安装在哪 rpm -ql vsf 查看rmp包详细信息 rpm -qi vsf 查看文件是由那个包产生 rpm -qf /test/b1.txt 删除rmp包 rmp -e vsf 使用yum安装和卸载软件，有个前提是yum安装的软件包都是rpm格式的 yum update 升级系统 yum install ～ 安装指定软件包 yum update ～ 升级指定软件包 yum remove ～ 卸载指定软件 yum grouplist 查看系统中已经安装的和可用的软件组，可用的可以安装 yum grooupinstall ～安装上一个命令显示的可用的软件组中的一个 源代码安装python安装 python官网下载file源代码 安装环境 查看group列表 yum grouplist 安装组包 yum groupinstall ‘开发工具’ -y 解压文件 tar -xvf pytho-3.7.0.tgz cd到解压好的文件目录，更改源码包安装路径 ./configure –prefix=/usr/local/python3.7 编码 make 安装 make install（安装时会出现下面两种错误 1. 需要安装zlib包 yum install zlib* 2.ModuleNotFoundError: No module named ‘_ctypes’ 解决方法：3.7版本需要一个新的包libffi-devel，安装此包之后再次进行编译安装即可 yum install libffi-* 把python3.7加到path环境中 更改profile文件 vim /etc/profile 在文件的最后面加上 PATH=$PATH:/usr/local/python3.7/bin export PATH netstat -tunapl 查看网络状态]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LINUX命令一]]></title>
    <url>%2F2019%2F02%2F22%2FLINUX%E5%91%BD%E4%BB%A4%E4%B8%80%2F</url>
    <content type="text"><![CDATA[快捷键：ctrl+c 取消命令 ctrl+l 清屏 命令：更换用户 su - 或sudo su 关机 init 0 重启 init 6 立即关机 shutdown -h now 查询当前用户 who am i 查看当前日期 date 修改当前日期 date -s “2012-01-02 14:00:00”（必须切换到root用户） 查看今天日历 cal 查看某天 cal 日月年（cal 3 4 2012） 改密码 passwd 查看文件下的子文件 ls 查看文件夹下的子文件详细信息 ls -l (简写ll) 查看文件的详细信息 ls -dl(简写ll -d) 查看文件夹下的所有文件包括隐藏文件 ls-a 切换目录 cd 退到上级目录 cd ,, 返回到上一次的目录 cd - 查看当前目录 pwd 递归建文件夹 mkdir -p 改名/移动 mv /a/b1 /a/b2(把a文件下的b1改成b2) mv /a/b1 /z/(把b1移动到z文件下) 文件复制顺便改名 cp /a/b1 /a/b2 文件夹的复制 cp -rf /a/b /c 删除文件夹 rm 删除文件夹下的所有子文件 rm -rf (不建议使用，最好用mv /a /tmp/ 移动到临时文件，还可以还原） ,如果文件带特殊符号，则加上“”即可删除 创建文件 touch a.txt 查看内容 cat 百分比查看 more 分页查看 less 查看前三行 head - n3 查看后三行 tail -n3 监控文件 tail -f 覆盖内容 echo 内容 &gt; 新增内容 echo 内容 &gt;&gt; 查看历史命令 history 使用第57行的历史命令 !57 直接修改密码 echo 123456 | passwd –stdin Messiless 用户信息文件 /etc/passwd 用户密码文件 /etc/shadow 用户组 /etc/group 用户组密码 /etc/gshadow 创建hsy用户 useradd hsy 完全删除hsy用户 userdel -r hsy 第一段代表文件权限信息，第一个数字是-代表普通文件，d则是目录 ，后面的一堆分3个3个来看，rwx代表属主的权限（可读可执行可写） r-x代表属组的权限（可读可执行） r-x代表其他用户的权限（可读可执行） 在jack组中附加一个tom用户 usermod -G jack tom 手动创建一个用户的流程 /etc/passwd /etc/shadow /etc/group /etc/gshaow mkdir /home/hsy cp -r /etc/skel/.[!.]* /home/hsy chown -R hsy.hsy /home/hsy touch /var/spool/mail/hsy chown -R hsy.mail /var/spool/mail/hsy 更换文件权限： 方法一：chmod u=rw,g=r,o=rx /a.txt 方法二：chmod 744 /a.txt (r=4,w=2,x=1) 如果要在一个目录下创建删除重命名文件，则该用户需要同时有wx权限 如果要修改一个目录下文件的内容，则需要文件的w权限，和前面目录的x权限]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
</search>
