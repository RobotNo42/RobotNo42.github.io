<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python装饰器]]></title>
    <url>%2F2019%2F02%2F26%2Fpython%E8%A3%85%E9%A5%B0%E5%99%A8%2F</url>
    <content type="text"><![CDATA[python装饰器就是用于在不改变原函数代码的情况下拓展新功能的一种函数，这个函数的特殊之处在于它的返回值也是一个函数，使用python装饰器的好处就是在不用更改原函数的代码前提下给函数增加新的功能。 装饰器分为有参和无参两种 无参123456789101112131415161718192021import timedef happy(func): def f1(*args, **kwargs): start_time = time.time() func(*args, **kwargs) end_time = time.time() print('run time is %s' % (end_time-start_time)) return f1 @happy #auto=happy(auto)def auto(name, password): print(name, password) @happydef shadow(): time.sleep(3) print("hello_world") shadow()auto('wzc', '123456') auto函数为原函数，我们需要对其进行功能扩展 因为原函数可能有形参或者没有，因此我们将函数定义为 def f1(*args, **kwargs)，这样不管是有参还是无参，都可以接收，不会报错 这里的happy函数就是最原始的装饰器，把auto当做了一个参数传了进去 auto=happy(auto) 然后返回值也是一个函数，返回一个f1，相当于auto=f1 其中作为参数的这个函数auto就在返回函数f1的内部执行。在函数auto前面加上@happy，auto函数就相当于被注入了计时功能，现在只要调用auto，它就已经变身为“新的功能更多”的函数了。 有参有参装饰器与无参装饰器的区别就是在外面多加一个嵌套函数，实现闭包功能 12345678910111213141516171819import time def mom(x='blee'): def happy(func): def f1(*args, **kwargs): print(x) start_time = time.time() func(*args, **kwargs) end_time = time.time() print('run time is %s' % (end_time-start_time)) return f1 return happy @mom('red')def auto(name, password): print(name, password) auto('wzc', '123456') 在原函数前面写@装饰器名，并加入参数 @mom(‘red’) 这时候我们先看mom(‘red’)，传回一个函数happy，等同于 @happy 接下来就和上面一样，这样就实现了有参装饰器]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>装饰器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python函数]]></title>
    <url>%2F2019%2F02%2F26%2Fpython%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[内置函数比如print,len,max等，后面有详细介绍的文章 自定义函数函数定义1234def 函数名():'写注释，描述信息'函数体return 返回值可以是任意类型，不写return，则默认返回None 无参函数通常情况不需要return值 12def fly():函数体 有参函数123def fly(a,b):函数体return a+b 调用函数有参 money=fly(1,2) #定义一个变量来接收return的值 无参 fly() #无参函数不写return，则默认返回None 函数的参数介绍从形参的角度分析位置参数：必须传值的参数 123def fly(x,y): print(x) print(y) 默认参数 123def fly(x,y=1): print(x) print(y) fly(1) #output : 1 1 fly(1,4) #output : 1 4 默认参数要注意的问题：默认参数必须放到位置参数的后面,def fly(x=1,y)则会报错 特殊的两种参数 * args 接收所有除了正常传参的位置传参，保存为元祖 **kwagrs 接收所有除了正常传参的关键字传参，保存为字典 例1： 1234567def fly(x, y=1, *args, **kwargs): print(x) print(y) print(args) print(kwargs) fly(1,y=78,a=1,b=2) 输出结果： 1234178()&#123;'a': 1, 'b': 2&#125; 例2： 1234567def fly(x, y=1, *args, **kwargs): print(x) print(y) print(args) print(kwargs) fly(1,20,300,78,w=1,l=2) 输出结果： 1234120(300, 78)&#123;'w': 1, 'l': 2&#125; 从实参的角度分析：第一种按位置传参 1fly(1,4) 第二种按关键字传参 12fly(x=1,y=2)fly(y=1,x=2) 第三种混着用 1fly(1,y=2) 如果写成fly(1,x=1)则会报错，因为参数只能赋值一次 如果写成fly(x=1,2)则会报错，因为按位置传值必须在按关键字传值前面 以上两条是混合实参的原则，不能违反 特殊的实参写法 1fly(*(12,16,14,15,18),**&#123;"ni":"fuck","sad":"many"&#125;) 上面的写法相当于： fly(12,16,14,15,18,ni=fuck,sad=many) 名称空间名称空间分为： 内部名称空间 全局名称空间 内置名称空间 搜索顺讯为：内置 全局 内部 闭包：内部函数包含对外部作用域而不是对全局作用域的名字的引用 下面是一个闭包例子： 123456789def f3(): x = 1 def f4(): print(x) return f4 x = 1000f4 = f3()f4() 输出结果：1 不管在哪调用内置函数，变量一定是由内向外搜索]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python文件操作]]></title>
    <url>%2F2019%2F02%2F26%2Fpython%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[流程1.打开文件 open() 2.操作文件 read write 3.关闭文件 close() 在window系统上 默认的编码是gbk 用open()打开时，window系统会使用默认的gbk编码，所以如果打开的文件是别的编码保存，则需要手动指定编码，例如打开utf-8保存的文件时 1f = open("test",encoding="utf-8") 而在linux系统上 默认的编码是utf-8 操作方法读整个文件的内容 1f.read() 读文件前5个字符的内容 1f.read(5) 如果再来一次 f.read(5),则读接下来的5个字符，read的内容取决于光标的位置 读一行 1f.readline() 一行一行打印，并移除空白 12for i in f: print(i.strip()) 写入模式1f = open("d://test1.txt", mode="w", encoding="utf-8") 当文件不存在时，会自动创建 这个模式只能写，不能读 覆盖的写 1f.write(hello\nworld) 多行一起写 1f.write(['11111\n','222222\n']) 追加模式跟w模式一样也是只能写，但是是追加的写 1f=open("d://test1.txt",mode="a",encoding="utf-8") 光标移动seek()的三种模式： （1）f.seek(p,0) 移动当文件第p个字节处，绝对位置 （2）f.seek(p,1) 移动到相对于当前位置之后的p个字节 （3）f.seek(p,2) 移动到相对文章尾之后的p个字节 seek是按字节移动 可读可写模式1.可读内容，写则是追加的写 1f=open("d://test1.txt",mode="r+",encoding="utf-8") 2.写的时候会把原来的内容覆盖,想读取内容，需要seek调整光标位置 1f=open("d://test1.txt",mode="w+",encoding="utf-8") 3.初始光标在最后，要读，则需要将光标调到初始位置，seek(0)，要写不管光标位置在哪，都是追加的写入 1f=open("d://test1.txt",mode="a+",encoding="utf-8") 新的方法可以避免忘记写close() 1with open("d://test1.txt", encoding="utf-8") as f 导入sys模块 123import syssys.stdout.write(s)sys.stdout.flush()]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python文件操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基础二]]></title>
    <url>%2F2019%2F02%2F25%2Fpython%E5%9F%BA%E7%A1%80%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[运算符算数运算 运算符 描述 实例 + 加 - 两个对象相加 a+b输出结果 30 - 减 - 得到负数 或是一个数减去另一个数 a-b输出结果 -10 * 乘 - 两个数相乘或是返回一个被重复若干次的字符串 a*b输出结果 200 / 除 - x除以y b/a 输出结果 2 % 取模 - 返回除法的余数 b%a输出结果 0 ** 幂 - 返回x的y次幂 a**b为10的20次方，输出结果10000000000000000000 // 取整除 - 返回商的整数部分 9//2输出结果4, 9.0//2.0输出结果4.0 比较运算 运算符 描述 实例 == 等于 - 比较对象是否相等 (a==b)返回False != 不等于 - 比较两个对象是否不相等 (a!=b)返回True &lt;&gt; 不等于 - 比较两个对象是否不相等 (a&lt;&gt;b)返回True。这个运算符类似!= &gt; 大于 - 返回x是否大于y (a&gt;b)返回False &lt; 小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊变量True和False等价，注意这些变量名的大写 (a&lt;b)返回True &gt;= 大于等于 - 返回x是否大于y (a&gt;=b)返回False &lt;= 小 于等于 - 返回x是否小于y (a&lt;=b)返回True 赋值运算 运算符 描述 实例 = 简单的赋值运算符 c=a+b将a+b的运算结果赋值为c += 加法赋值运算符 c+=a等效于c=c+a -= 减法赋值运算符 c-=a等效于c=c-a *= 乘法赋值运算符 等效于c=c*a /= 除法赋值运算符 c/=a等效于c=c/a %= 取模赋值运算符 c%=a等效于c=c%a **= 幂赋值运算符 等效于c=c**a //= 取整除赋值运算符 c//=a等效于c=c//1 逻辑运算 运算符 描述 实例 and 布尔”与” - 如果x为False，x and y返回False，否则它返回y的计算值 (a and b)返回True or 布尔”或” - 如果x是True，它返回True，否则它返回y的计算值 (a or b)返回True not 布尔”非” - 如果x为True，返回False。如果x为False，它返回True not(a and b)返回False 如果and 和 or 同时存在，则or将整体分成两部分看 成员运算 运算符 描述 实例 in 如果在指定的序列中找到值返回True，否则返回False x在y序列中，如果x在y序列中返回True not in 如果在指定的序列中没有找到值返回True，否则返回False x不在y序列中，如果x不在y序列中返回True 三元运算1result =值1 if 条件 else 值2 如果条件为真：result =值1 如果条件为假 ：sesult =值2 123a = 3b = 7c = a if a&lt;b else b 如果a小于b则把a的值赋给c，相反则把b的值赋给c 身份运算 运算符 描述 实例 is is是判断两个标识是不是引用自一个对象 x is y，如果id(x)等于id(y)，is返回结果1 not is is not是判断两个标识是不是引用自不同对象 x is not y，如果id(x)不等于id(y)，is返回结果1 位运算 运算符 描述 实例 &amp; 按位与运算符 (a&amp;b)输出结果12，二进制解释：0000 1100 丨 按位或运算符 (a丨b)输出结果61，二进制解释：0011 1101 ^ 按位异或运算符 (a^b)输出结果49，二进制解释：0011 0001 ~ 按位取反运算符 (~a)输出结果-61，二进制解释：1100 0011，在一个有符号二进制数的补码形式 &lt;&lt; 左移动运算符 a&lt;&lt;2输出结果240，二进制解释：1111 0000 &gt;&gt; 右移动运算符 a&gt;&gt;2输出结果15，二进制解释：0000 1111 运算符优先级 运算符 描述 ** 指数(最高优先级) ~ + - 按位翻转，一元加号和减号(最后两个方法名为+@和-@) * / % // 乘，除，取模和取整除 + - 加法减法 &gt;&gt; &lt;&lt; 右移，左移运算 &amp; 位’AND’ ^ 丨 位运算符 &lt;= &lt;&gt; &gt;= 比较运算符 &lt;&gt; == != 等于运算符 = %= /= //= -= += *= **= 赋值运算符 is is not 身份运算符 in not in 成员运算符 not or and 逻辑运算符 bytes类型Python3中内置类型bytes和str用法及byte和string之间各种编码转换Python 3最重要的新特性大概要算是对文本和二进制数据作了更为清晰的区分。文本总是Unicode，由str类型表示，二进制数据则由bytes类型表示。Python 3不会以任意隐式的方式混用str和bytes，正是这使得两者的区分特别清晰。你不能拼接字符串和字节包，也无法在字节包里搜索字符串（反之亦然），也不能将字符串传入参数为字节包的函数（反之亦然）. 1234msg = "我爱北京天安门"print(msg)print(msg.encode(encoding="utf-8"))print(msg.encode(encoding="utf-8").decode(encoding="utf-8")) 执行结果： 123我爱北京天安门b'\xe6\x88\x91\xe7\x88\xb1\xe5\x8c\x97\xe4\xba\xac\xe5\xa4\xa9\xe5\xae\x89\xe9\x97\xa8'我爱北京天安门 格式化%s 字符串 例： 123456789101112131415161718192021string="hello"#%s打印时结果是helloprint "string=%s" % string # output: string=hello#%2s意思是字符串长度为2，当原字符串的长度超过2时，按原长度打印，所以%2s的打印结果还是helloprint "string=%2s" % string # output: string=hello#%7s意思是字符串长度为7，当原字符串的长度小于7时，在原字符串左侧补空格，#所以%7s的打印结果是 helloprint "string=%7s" % string # output: string= hello#%-7s意思是字符串长度为7，当原字符串的长度小于7时，在原字符串右侧补空格，#所以%-7s的打印结果是 helloprint "string=%-7s!" % string # output: string=hello !#%.2s意思是截取字符串的前2个字符，所以%.2s的打印结果是heprint "string=%.2s" % string # output: string=he#%.7s意思是截取字符串的前7个字符，当原字符串长度小于7时，即是字符串本身，#所以%.7s的打印结果是helloprint "string=%.7s" % string # output: string=hello#%a.bs这种格式是上面两种格式的综合，首先根据小数点后面的数b截取字符串，#当截取的字符串长度小于a时，还需要在其左侧补空格print "string=%7.2s" % string # output: string= heprint "string=%2.7s" % string # output: string=helloprint "string=%10.7s" % string # output: string= hello %d 整数 %f 浮点数 编码 在python3中不需要申明编码 从英文意思上看，encode和decode分别指编码和解码。在python中，Unicode类型是作为编码的基础类型，即： 12decode encodestr ---------&gt; str(Unicode) ---------&gt; str 12345678910111213141516171819&gt;&gt;&gt; u = '中文' # 指定字符串类型对象u &gt;&gt;&gt; str1 = u.encode('gb2312') # 以gb2312编码对u进行编码，获得bytes类型对象&gt;&gt;&gt; print(str1)b'\xd6\xd0\xce\xc4' &gt;&gt;&gt; str2 = u.encode('gbk') # 以gbk编码对u进行编码，获得bytes类型对象&gt;&gt;&gt; print(str2)b'\xd6\xd0\xce\xc4'&gt;&gt;&gt; str3 = u.encode('utf-8') # 以utf-8编码对u进行编码，获得bytes类型对象&gt;&gt;&gt; print(str3)b'\xe4\xb8\xad\xe6\x96\x87' &gt;&gt;&gt; u1 = str1.decode('gb2312') # 以gb2312编码对字符串str进行解码，获得字符串类型对象&gt;&gt;&gt; print('u1')'中文' &gt;&gt;&gt; u2 = str1.decode('utf-8') # 报错，因为str1是gb2312编码的UnicodeDecodeError: 'utf-8' codec can't decode byte 0xd6 in position 0: invalid continuation byte 其他break 跳出本层循环 continue 跳出本次循环 1234567for i in range(10): print(i) if i ==5: breakelse: print("done")print("done2") 只有正常结束for循环才会执行else的命令，所以done不会被输出 判断是否为数字 isdigit() 取嵌套列表的值 name = [12,23,34,[34,55]] 取55的值 ：name[3][1]]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>运算符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基础一]]></title>
    <url>%2F2019%2F02%2F25%2Fpython%E5%9F%BA%E7%A1%80%E4%B8%80%2F</url>
    <content type="text"><![CDATA[数据类型数字整型 int 长整型 long 浮点型 float 复数 complex 字符str它只是人类可读的一种抽象表示形式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263name="helloworld" name.capitalize() #将字符串变成首字母大写，其他全部小写 name.casefold() #将字符串变成全部变小写 nam.lower() #将字符串变成全部变小写 name.upper() #将字符串变成全部变大写 name.swapcase() #大小写互换 name.center(50,'-') #将字符串长度变成50，且字符串居中,不够的由-填充，如果50后面不写，则默认空格填充 name.ljust(50,'-') #同上，字符串左对齐 name.rjust(50,'-') #同上，字符串右对齐 name.count('e') #查找整个字符串有几个e name.count('e',2,4) #从字符串的第3到4中找有几个e ,含头不含尾 name.startwith() #以..什么开头 name.endwith() #以..什么结尾 name.expandtabs(10) #定义\t的长度 name.find('h') #查找h的位置 name.index('h') #返回h的索引值 name.find('h',2,6) #在3到6之间找第一个h的位置，返回的是整个字符串的位置，找不到-1 name.format() #format的用法是： name=“hello&#123;0&#125;,fuck&#123;1&#125;” name.format('world',144) # output: helloworld,fuck144 “-”.join(["fuck","u","every","day"]) # output:fuck-u-every-day 将列表的内容用指定的字符串串起来，变成一个字符串 name.lstrip() #从左边开始删指定的字符串 name.rstrip() #从右边开始删指定的字符串 name.replace('he','she') #把he替换成she name.replace('he','she',1) #把he替换成she,只替换一次 name.strip() #移除空白 len(name) #判断 name.index("f") #以0开始，索引 name[0:8] #从第1个切到第8个 取头不取尾(切得最后一个不取) name[-6:] #从倒数第5个切到最后一个，因为-1在尾部，取不到，直接不写 name[2::2] #从第3个开始，隔2个取一个 布尔型boolbool，从Python2.3开始Python中添加了布尔类型。布尔类型有两种True和False。对于没有nozero方法的对象默认是True。 bool运算： 以下情况都为False [] 空列表 {} 空字典 空集合 () 空元祖 ‘’ 空字符串 0 数字0 list 列表list [] name=[“萨德”,”委屈”,”多行”,”太容易”,”电风扇”] name[0] 取第一个的值 name.index(“多行”) 查询多行的位置 得到结果 2 name.count(“太容易”) 查询太容易在列表中数量 name.append(“付出”) 追加 name.insert(4,”陈涛”) 把陈涛插到4的位置 name.pop(4) 删除第四个 ()内不写则默认删除最后一个 name.remove(“陈涛”) 删除成涛 del name[0] 删除第一个 name[name.index(“陈涛”)]=”水” 修改陈涛为水 dict 字典字典(dictionary)是除列表之外python中最灵活的内置数据结构类型。列表是有序的对象结合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。 字典由键和对应的值组成。字典也被称作关联数组或哈希表。基本语法如下： 1dict = &#123;'Alice': '2341', 'Beth': '9102', 'Cecil': '3258'&#125;; 也可如此创建字典： 12dict1 = &#123; 'abc': 456 &#125;;dict2 = &#123; 'abc': 123, 98.6: 37 &#125;; 可以字典中加字典，嵌套 key必须是唯一的 实例：name = {1 : [’fuck‘], 2 : [‘fuck’], 3: {’name‘:’d‘}, 34 : [‘wzc’,’hsy’] } 增name[34].append(“love”) 在key为34中添加值love name[”nice“]=”whatever“ 在name中新插入key为nice,value为whatever的键/值对 删name.pop(34) 删除key为34的键/值对 del name[34] 删除key为34的键/值对 改name[34][0]=’’love’’ 将key为34内的第一个值改为love name[24]=name.pop(34) 将key名为34的改成24，值不变 查name.get(34) 查找key为34的值，没有则返回None name[34] 查找key为34的值，没有则报错 113 in name 判断字典中是否有key为113的键/值对 name.keys() 查找字典中所有的key name.values() 查找字典中所有的值 循环for i in name: print( i ,name[i] ) 更新name.update(name1) 将name1的键值对合并到name中，如果两者之间有相同名字的key，则取name1中的值 set 集合集合与字典的区别是没有key值 特点：天然去重，无序 12345678910111213141516171819202122232425262728linux = &#123;"alex", "jack", "rain", "lizhi", "sb", "lizhi"&#125;python = &#123;"sb", "alex", "mack", "rachel"&#125; print(linux.intersection(python)) # 交集print(linux &amp; python) # 交集print(linux.difference(python)) # 差集 linux中有而python中没有print(linux - python) # 差集 linux中有而python中没有print(linux.union(python)) # 并集print(linux | python) # 并集print(linux.symmetric_difference(python)) # 对称 互相不在的都打印print(linux ^ python) # 对称 互相不在的都打印 linux.add() #增加 linux.clear() #把linux集合中内容删光 linux.update(python) #把python合并到linux集合中 linux.discard("alex") #把linux中的alex删除，元素不存在不会报错 linux.remove('alex') #把linux中的alex删除，元素不存在会报错 linux.pop() #随机删除一个 linux.issubset(python) #判断linux是不是python的子集 linux.issuperset(python) #判断linux是不是python的父集 linux.isdisjoint(python) #如果两个集合没有任何关联，则返回Ture tuple 元祖元组类型在很多操作上都跟列表一样，许多用在列表上的例子在元组上照样能跑，我们有一节内容专门讲解元组类型。它们的主要不同在于元组是不可变的，或者说是只读的，所以那些用于更新列表的操作，比如用切片操作来更新一部分元素的操作，就不能用于元组类型 12345678CPython&gt;&gt;&gt; a = ('a','123',['a',123])&gt;&gt;&gt; a('a', '123', ['a', 123])&gt;&gt;&gt; type(a)&lt;class 'tuple'&gt;&gt;&gt;&gt; tu = tuple('abcde')&gt;&gt;&gt; tu('a', 'b', 'c', 'd', 'e') 列表与字典的一个methodname=[21,23,454[34,123]] h=name.copy() 当改变h[0],h[1],h[2]这些值时，name中的不变 但改变h[3]时 h[3][0]=56 name中也会变 同理 n1={12:”asda”,24:”asdasd”,33:[78,34]} n2=n1.copy() 更改n1[12]的值，n2不变 更改 n1[33][0]的值，n2中也会变 转换类型int(x [,base ]) 将x转换为一个整数 long(x [,base ]) 将x转换为一个长整数 float(x ) 将x转换到一个浮点数 complex(real [,imag ]) 创建一个复数 str(x ) 将对象 x 转换为字符串 repr(x ) 将对象 x 转换为表达式字符串 eval(str ) 用来计算在字符串中的有效Python表达式,并返回一个对象 tuple(s ) 将序列 s 转换为一个元组 list(s ) 将序列 s 转换为一个列表 chr(x ) 将一个整数转换为一个字符 unichr(x ) 将一个整数转换为Unicode字符 ord(x ) 将一个字符转换为它的整数值 hex(x ) 将一个整数转换为一个十六进制字符串 oct(x ) 将一个整数转换为一个八进制字符串 编码utf -8 英文1个字节 中文3个字节 gbk 中文2个字节]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo的next主题详细配置]]></title>
    <url>%2F2019%2F02%2F23%2Fhexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E8%AF%A6%E7%BB%86%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 为了描述方便，在以下说明中，将前者称为站点配置文件， 后者称为主题配置文件。 以下所有终端执行的命令都在你的Hexo根目录下 基本信息配置打开 站点配置文件 ，找到Site模块 123456title: 标题subtitle: 副标题description: 描述author: 作者language: 语言（简体中文是zh-Hans）timezone: 网站时区（Hexo 默认使用您电脑的时区，不用写） 关于 站点配置文件 中的其他配置可参考站点配置 菜单设置菜单包括：首页、归档、分类、标签、关于等等 我们刚开始默认的菜单只有首页和归档两个，不能够满足我们的要求，所以需要添加菜单，打开 主题配置文件 找到Menu Settings 看看你需要哪个菜单就把哪个取消注释打开就行了； 关于后面的格式，以archives: /archives/ || archive为例： || 之前的/archives/表示标题“归档”，关于标题的格式可以去themes/next/languages/zh-Hans.yml中参考或修改 ||之后的archive表示图标，可以去Font Awesome中查看或修改，Next主题所有的图标都来自Font Awesome Next主题样式设置我们百里挑一选择了Next主题，不过Next主题还有4种风格供我们选择，打开 主题配置文件 找到Scheme Settings 12345# Schemes# scheme: Muse# scheme: Mist# scheme: Piscesscheme: Gemini 4种风格大同小异，本人用的是Gemini风格，你们可以选择自己喜欢的风格 侧栏设置开启侧边栏社交链接1234567891011# Social linkssocial: GitHub: https://github.com/hydcoder Weibo: https://weibo.com/3180967953/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo # 等等social_icons: enable: true # Icon Mappings. GitHub: github Weibo: weibo 开启打赏功能123reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！wechatpay: 你的微信收款码链接alipay: 你的支付宝收款码链接 开启友情链接1234links_title: Linkslinks: MacTalk: http://macshuo.com/ Title: http://example.com/ 开启订阅微信公众号1234wechat_subscriber:enabled: trueqcode: /uploads/wechat-qcode.jpgdescription: 欢迎您扫一扫上面的微信公众号，订阅我的博客！ 头像设置打开 主题配置文件 找到Sidebar Avatar字段 12# Sidebar Avataravatar: /images/header.jpg 这是头像的路径，只需把你的头像命名为header.jpg（随便命名）放入themes/next/source/images中，将avatar的路径名改成你的头像名就OK啦！ 设置侧边栏设置圆形可旋转头像 找到生成的Hexo目录\themes\next\source\css_common\components\sidebar下的sidebar-author.styl，将里面的css样式内容全部替换为： 123456789101112131415161718192021222324252627282930313233.site-author-image &#123; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; border-radius: 50%; -webkit-border-radius: 50%; -moz-border-radius: 50%; transition: 1.4s all;&#125;.site-author-image:hover &#123; -webkit-transform: rotate(360deg); -moz-transform: rotate(360deg); -ms-transform: rotate(360deg); -transform: rotate(360deg);&#125;.site-author-name &#123; margin: $site-author-name-margin; text-align: $site-author-name-align; color: $site-author-name-color; font-weight: $site-author-name-weight;&#125;.site-description &#123; margin-top: $site-description-margin-top; text-align: $site-description-align; font-size: $site-description-font-size; color: $site-description-color;&#125; 设置首页不显示全文(只显示预览)打开主题配置文件_config.yml，ctrl + F搜索找到”auto_excerpt”，可以看见 12345# Automatically Excerpt. Not recommand.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt:enable: falselength: 150 把enable改为对应的false改为true，length就是预览显示的文字长度，你可以根据你的需要进行更改，然后重新部署，再进主页，你就发现你首页的文章多了一个阅读全文的按钮。 添加动态背景先上张图 打开生成的Hexo目录\themes\next/layout/_layout.swig文件，在 &lt; head&gt;中的添加代码 123&#123;% if theme.canvas_nest %&#125;&lt;script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"&gt;&lt;/script&gt;&#123;% endif %&#125; 打开主题配置文件，搜索canvas_nest，将其改成true 1canvas_nest: true 什么？线条太多了？没事，来看看怎么让线条变少点 在上一步修改的主题配置文件中，把刚才的那些代码改成下面这样： 1234&#123;% if theme.canvas_nest %&#125;&lt;script type="text/javascript"color="0,0,255" opacity='0.7' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"&gt;&lt;/script&gt;&#123;% e 配置项说明 color ：线条颜色, 默认: ‘0,0,0’；三个数字分别为(R,G,B) opacity: 线条透明度（0~1）, 默认: 0.5 count: 线条的总数量, 默认: 150 zIndex: 背景的z-index属性，css属性用于控制所在层的位置, 默认: -1 分类和标签设置这里主要说的是在编写文章的时候，怎么给文章设置标签和分类。 首先通过hexo n &quot;name&quot;命令来新建一个页面，在source/_posts目录下找到刚才新建的name.md文件，用Typora或者notepad++t打开(推荐Typora) 1234title: namedate: 2014-08-05 11:15:00 tags: --- 页面默认就是长这样的，可以编辑标题、日期、标签和内容，但是没有分类的选项。我们可以手动加入categories:项,但是下次创建新的页面的时候还是没有，所以我们直接打开scaffolds/post.md文件，在tages:上面加入categories:,保存后，重新执行hexo n ‘name’命令，会发现新建的页面里有categories:项了。 scaffolds目录下，是新建页面的模板，执行新建命令时，是根据这里的模板页来完成的，所以可以在这里根据你自己的需求添加一些默认值。 设置分类列表在我们编辑文章的时候，直接在categories:项填写属于哪个分类，但如果分类是中文的时候，路径也会包含中文。 比如分类我们设置的是： 1categories: 开车 那在生成页面后，分类列表就会出现开车这个选项，他的访问路径是： 1*/categories/开车 我们都知道，有时候中文路径可能会出现一些奇奇怪怪的问题，所以我们需要路径名和分类名分别设置。 打开站点配置文件_config.yml，找到如下位置做更改： 1234567# Category &amp; Tagdefault_category: uncategorizedcategory_map: 开车: drive 生活: life 其他: othertag_map: 在这里category_map:是设置分类的地方，每行一个分类，冒号前面是分类名称，后面是访问路径。可以提前在这里设置好一些分类，当编辑的文章填写了对应的分类名时，就会自动的按照对应的路径来访问。 设置标签在编辑文章的时候，tags:后面是设置标签的地方，如果有多个标签的话，可以用下面两种办法来设置： 第一种： 1tages: [标签1,标签2,...标签n] 第二种： 12345 tages: - 标签1- 标签2...- 标签n 添加文章更新时间修改（博客主目录）/themes/next/layout/_macro/post.swig 文件，在&lt;span class=&quot;post-time&quot;&gt;...&lt;/span&gt;标签后添加 12345678&#123;%if post.updated and post.updated &gt; post.date%&#125; &lt;span class="post-updated"&gt; &amp;nbsp; | &amp;nbsp; &#123;&#123; __('post.updated') &#125;&#125; &lt;time itemprop="dateUpdated" datetime="&#123;&#123; moment(post.updated).format() &#125;&#125;" content="&#123;&#123; date(post.updated, config.date_format) &#125;&#125;"&gt; &#123;&#123; date(post.updated, config.date_format) &#125;&#125; &lt;/time&gt; &lt;/span&gt;&#123;% endif %&#125; 根据博客配置文件中的 language 参数修改对应的语言配置文件（博客主目录）/themes/next/languages/zh_Hans.yml 12post: updated: 更新于 修改主题配置文件（博客主目录）/themes/next/_config.yml，增加一行 1display_updated: true 或者写文章的时候可以直接在文章开头设置更新时间，没有这参数的话将会显示md文件的修改日期 1updated: 2018-01-01 12:00:00 添加搜索功能安装 hexo-generator-searchdb 插件 1$ npm install hexo-generator-searchdb --save 打开 站点配置文件 找到Extensions在下面添加 123456# 搜索search: path: search.xml field: post format: html limit: 10000 3、打开 主题配置文件 找到Local search，将enable设置为true 添加阅读全文按钮因为在你的博客主页会有多篇文章，如果你想让你的文章只显示一部分，多余的可以点击阅读全文来查看，那么你需要在你的文章中添加 1&lt;!--more--&gt; 其后面的部分就不会显示了，只能点击阅读全文才能看 修改文章内链接文本样式打开文件 themes/next/source/css/_common/components/post/post.styl，在末尾添加 12345678910.post-body p a &#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125; 其中选择 .post-body 是为了不影响标题，选择 p 是为了不影响首页“阅读全文”的显示样式,颜色可以自己定义。 设置网站缩略图标从网上看了很多设置方法都是说把favicon.ico放到站点目录的source目录下就可以了，可是我试了好多遍，并不行 我的设置方法是这样的：把你的图片（png或jpg格式，不是favicon.ico）放在themes/next/source/images里，然后打开 主题配置文件 找到favicon，将small、medium、apple_touch_icon三个字段的值都设置成/images/图片名.jpg就可以了，其他字段都注释掉。 设置文章字体的颜色、大小 如果想设置某一句的颜色或大小，只需用html语法写出来就行了 1234接下来就是见证奇迹的时刻&lt;font color="#FF0000"&gt; 我可以设置这一句的颜色哈哈 &lt;/font&gt; &lt;font size=6&gt; 我还可以设置这一句的大小嘻嘻 &lt;/font&gt; &lt;font size=5 color="#FF0000"&gt; 我甚至可以设置这一句的颜色和大小呵呵&lt;/font&gt; 设置文字居中1&lt;center&gt;这一行需要居中&lt;/center&gt; 添加评论系统目前国内比较有名的多说、网易云跟帖评论系统都已停止服务了，国外的Disqus评论系统还得需要翻墙，所以不推荐使用，剩下的还有搜狐畅言、友言、来必力等。本来想使用畅言的，结果注册完之后还得要求备案，我只想说F开头的那个单词，果断放弃。后来选择了友言 1、进入友言官网注册、登录步骤我就不介绍了2、登录完成之后，点击获取代码，你会发现出来了一段代码，里面有你的uid=12345673、打开 主题配置文件 找到youyan_uid将值设置为上面的uid就可以了 添加站点访问计数站点访问计数有名的就是不蒜子，使用起来非常方便1、安装脚本打开 themes/next/layout/_partial/footer.swig，将下面这段代码添加到里面 12345678910&lt;div&gt;&lt;script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt;&lt;span id="busuanzi_container_site_pv" style='display:none'&gt; 本站总访问量 &lt;span id="busuanzi_value_site_pv"&gt;&lt;/span&gt; 次 &lt;span class="post-meta-divider"&gt;|&lt;/span&gt;&lt;/span&gt;&lt;span id="busuanzi_container_site_uv" style='display:none'&gt; 有&lt;span id="busuanzi_value_site_uv"&gt;&lt;/span&gt;人看过我的博客啦&lt;/span&gt;&lt;/div&gt; 添加的位置如下图，可自行根据个人喜好更换位置 2、以上只是显示站点的访问次数，如果想显示每篇文章的访问次数，打开 themes/next/layout/_macro/post.swig，在第一行增加is_pv字段 1&#123;% macro render(post, is_index, is_pv, post_extra_class) %&#125; 然后将这段代码插入到里面 1234&#123;% if is_pv %&#125; &lt;span class="post-meta-divider"&gt;|&lt;/span&gt; &lt;span id="busuanzi_value_page_pv"&gt;&lt;/span&gt;次阅读&#123;% endif %&#125; 插入的位置 然后再打开 themes/next/layout/post.swig，这个文件是文章的模板，给render方法传入参数（对应刚才添加的is_pv字段） 最后再打开 themes/next/layout/index.swig，这个文件是首页的模板，给render方法传入参数（对应刚才添加的is_pv字段） OK！设置完毕 去掉文章目录标题的自动编号我们自己写文章的时候一般都会自己带上标题编号，但是默认的主题会给我们带上编号，很是别扭，如何去掉呢？打开主题配置文件，找到 123456789# Table Of Contents in the Sidebartoc: enable: true # Automatically add list number to toc. number: true # If true, all words will placed on next lines if header width longer then sidebar width. wrap: false 将number改为false即可 自定义样式 引用需加入custom.styl的代码 文件位置：~/blog/themes/next/source/css/_custom/custom.styl 123456789// 自定义的引用样式blockquote.question &#123; color: #555; border-left: 4px solid rgb(16, 152, 173); background-color: rgb(227, 242, 253); border-top-right-radius: 3px; border-bottom-right-radius: 3px; margin-bottom: 20px;&#125; 文字颜色改color的值 背景色改background-color的值 边框颜色和粗细改border-left的值 效果： 内容 使用方法： 1&lt;blockquote class="question"&gt;内容&lt;/blockquote&gt; 修改hexo的主题nexT中的Pisces主题宽度在source/css/_schemes/Picses/_layout.styl文件末尾添加如下代码 12345678910111213141516171819202122232425262728293031323334// 以下为新增代码！！header&#123; width: 90% !important; &#125;header.post-header &#123; width: auto !important;&#125;.container .main-inner &#123; width: 90%; &#125;.content-wrap &#123; width: calc(100% - 260px); &#125;.header &#123; +tablet() &#123; width: auto !important; &#125; +mobile() &#123; width: auto !important; &#125;&#125;.container .main-inner &#123; +tablet() &#123; width: auto !important; &#125; +mobile() &#123; width: auto !important; &#125;&#125;.content-wrap &#123; +tablet() &#123; width: 100% !important; &#125; +mobile() &#123; width: 100% !important; &#125;&#125; 更多还有其他更多的主题配置，请查看主题配置 还有其他更多的插件，请查看Hexo插件]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>next主题配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何更换hexo博客主题]]></title>
    <url>%2F2019%2F02%2F23%2F%E5%A6%82%E4%BD%95%E6%9B%B4%E6%8D%A2hexo%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%2F</url>
    <content type="text"><![CDATA[在成功用github+hexo搭建好个人博客之后，原生的主题一般不大讨喜。在此，简单介绍一下如何找一个自己喜欢的主题并运用到自己的博客中： 挑个好看的主题hexo官方：Themes 知乎话题：有哪些好看的 Hexo 主题？ 下载用git bash，进入到博客的本地目录中 然后使用clone的方法将想要的主题下载下来。（我选用的是NexT主题） 1$ git clone https://github.com/theme-next/hexo-theme-next themes/next 修改配置文件，安装git克隆完成后，打开当前目录下的“_config.yml”配置文件。 找到theme的配置选项，一般在文件的最后。之后，将theme选项配置为我们新下载好的next主题即可。（“：”冒号之后空格不可少） 调试，发布回到git bash，输入调试命令： 1hexo server --debug 在浏览器中输入localhost:4000查看 在本地查看无误之后，输入生成和发布命令,就可已将新主题发布到自己的博客网站上了 12hexo ghexo d 如出现缓存引起的异常，可以在生成命令前执行清除缓存命令 1hexo clean 完成做完这些之后，就可以打开你的博客网站，查看新更换的主题效果了。]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>hexo更换主题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用hexo+github搭建属于自己的博客]]></title>
    <url>%2F2019%2F02%2F23%2F%E4%BD%BF%E7%94%A8hexo-github%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[一、注册GitHub账号（已经有GitHub账号的请忽略这一步）先在Github注册一个账号:https://github.com/ 新建项目，项目必须要遵守格式：账户名.github.io，不然接下来会有很多麻烦。并且需要勾选Initialize this repository with a README 在建好的项目右侧有个settings按钮，点击它，向下拉到GitHub Pages，你会看到那边有个网址，访问它，你将会发现该项目已经被部署到网络上，能够通过外网来访问它。 二、环境搭建下载Node.js安装文件现在电脑基本都是64位的，我就放64位的下载地址：https://nodejs.org/dist/v8.9.4/node-v8.9.4-x64.msi 或者自行到官网下载最新版本： https://nodejs.org 安装Git：Git下载包（64位） Git下载包（32位） 完成之后到桌面空白处单击鼠标右键，选择Git Bash Here进入bash窗口输入命令 node -v 和 npm -v 验证安装是否成功,成功界面如下 三、Hexo安装Hexo简介Hexo是什么呢？也许引用Hexo官方文档里面的说明是再好不过了： 1Hexo is a fast, simple and powerful blog framework. You write posts in Markdown (or other languages) and Hexo generates static files with a beautiful theme in seconds. 1Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装Git下载地址：https://git-scm.com/download，按照默认傻瓜式安装就好了 补充一句，如果你已经安装了Git，你可以通过Git本身获得最新的开发版本： 1$ git clone https://github.com/git/git 完成之后到桌面空白处单击鼠标右键，如果有出现Git Bash Here选项则证明已经安装成功 下载Hexo在桌面空白处单击鼠标右键，选择Git Bash Here进入bash窗口，在自己认为合适的地方创个文件夹，我是在D盘建了一个blog文件夹。然后通过命令行进入到该文件夹里面 再输入命令 npm install -g hexo 下载Hexo 1$ npm install -g hexo 等待完成之后，输入命令 hexo -v 验证安装是否成功 初始化输入hexo init，初始化该文件夹 输入npm install，安装所需要的组件 输入hexo g，首次体验Hexo 输入hexo s，开启服务器，访问该网址，正式体验Hexo 问题：假如页面一直无法跳转，那么可能4000端口被占用了。此时我们ctrl+c停止服务器，接着输入hexo server -p 端口号来改变端口号 那么出现如下图就成功了 四、将Hexo与Github page联系起来安装插件打开git bash，进入hexo根文件夹，输入npm install hexo-deployer-git --save 命令安装插件 配置SSH设置全局配置user.name 和user.email（如果是第一次的话） 12git config –-global user.name “shuaibi” //(“”的账号是刚才Github里面自己注册的账号) git config –-global user.email “okjbk.gmail.com” //(""的邮箱是你自己注册的邮箱) 输入cd ~/.ssh，检查是否有.ssh的文件夹 输入ssh-keygen -t rsa -C &quot;ojbk.gmail.com&quot;(&quot;&quot;中间写你直接设置的邮箱)，连续三个回车，生成密钥，最后得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\Users\Administrator.ssh）。 输入eval &quot;$(ssh-agent -s)&quot;，添加密钥到ssh-agent 再输入ssh-add ~/.ssh/id_rsa，添加生成的SSH key到ssh-agent 登录Github，点击头像下的settings，添加ssh 新建一个new ssh key，将id_rsa.pub文件里的内容复制上去 回到git bash 输入ssh -T git@github.com，测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明成功了 问题: 假如ssh-key配置失败，那么只要以下步骤就能完全解决 首先，清除所有的key-pairssh-add -Drm -r ~/.ssh删除你在github中的public-key 重新生成ssh密钥对ssh-keygen -t rsa -C “xxx@xxx.com“ 接下来正常操作在github上添加公钥public-key:1、首先在你的终端运行 xclip -sel c ~/.ssh/id_rsa.pub将公钥内容复制到剪切板2、在github上添加公钥时，直接复制即可3、保存 测试： 在终端 ssh -T git@github.com 配置配置Deployment，在根文件夹中，找到_config.yml文件，修改repo值（在末尾） 1234deploy: type: git repository: git@github.com:RobotNo42/RobotNo42.github.io.git branch: master repo值是你在github项目里的ssh（右下角） 部署用git bash部署hexo到github hexo server 或者 hexo s hexo generate 或者 hexo g hexo deploy 或者 hexo d 看到这样的进程，代表成功部署hexo到github 等待10分钟左右，打开用户名.github.io,会出现如下界面（代表成功搭建博客）：]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>hexo+github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LINUX命令三]]></title>
    <url>%2F2019%2F02%2F23%2FLINUX%E5%91%BD%E4%BB%A4%E4%B8%89%2F</url>
    <content type="text"><![CDATA[网络相关配置ifconfig 查看ip信息 远程复制 scp /etc/h.txt 192.168.1.1:/tmp 配置ssh（之后访问无需密码）： ssh-keygen ssh-copy-id -i 192.168.1.16 赋值变量 x=2 调用x echo $x 取消变量 unset x 设置别名 alias x=‘ls /’ 将命令得到的结果赋值到变量 x=$(ls) 搜索文件 ls [a-z][0-9].txt []代表在中间取一个值, a-z代表aAbBcC…..z不包含Z ls [!0-9],txt 查找不以数字开头的文件 执行历史命令 ！638 查看上条命令执行是否成功 echo $? 成功则为0 注释 || 前面命令成功，则后面不执行 ；只有前面命令失败后面才执行 &amp;&amp; 只有前面的命令执行成功才会执行后面的命令 \ 转义符号 ? 匹配一个任意字符 例： ls ???.txt 固化命令在登录时就加载出命令 在/etc/bashrc 文件中添加想要的命令 grep命令grep -A 2 ‘fuck’ /etc/passwd 显示查询结果及后两行 grep -B 2 ‘fuck’ /etc/passwd 显示查询结果及前两行 grep -C 2 ‘fuck’ /etc/passwd 显示查询结果及前后两行 grep -c ‘fuck’ /etc/passwd 显示查询行数 grep -i ‘fuck’ /etc/passwd 无视大小写查询 grep -v ‘fuck’ /etc/passwd 取目标之外的剩余结果 grep -w ‘fuck’ /etc/passwd 单词匹配 grep -rl ‘fuck’ /etc/passwd 匹配文件内容中带fuck的文件路径 正则grep ‘^root’ 匹配以root开头的 grep ‘root$’ 匹配以root结尾的 grep ‘a.b’ .代表任意一个字符 grep ‘ab‘ 代表b有0个或者多个 grep ‘ab?’ 代表b有0个或者1个 egrep ‘ab+’ 必须用egrep +代表b有1个或者多个 egrep ‘ab{2}’ 2个b egrep ‘ab{2，4}’ 2到4个b egrep ‘ab{2，}’ 2个以上b egrep ‘[abc\ / -]’ 含abc/-中一个字符的 [a-z] 代表所有的小写字母 [A-Z] 代表所有的大写字母 [a-Z] 代表所有的大小写字母 注意点如果要匹配的是-本身，则必须放到最后[asd-] echo ^[^0-9] 匹配不是数字开头的 sed命令sed ‘3d’ 删除第三行 sed ‘1,4d’ 删除1-4行 sed ‘1;4d’ 删除第1行和第4行 sed ‘s/sb/fuck’ 把所有行的第一个sb换成fuck sed ‘s/sb/fuck/g’ 把所有行的所有sb换成fuck sed ‘3p’ 打印第三行 sed ‘3c 123456’ 把第三行改成123456 sed ‘3a 123’ 在第三行后插入123 sed ‘3i 123’ 在第三行前插入123 sed’/^root/d’ 加入正则法 sed -r ‘/^[0-9][a-Z]+sb$/ s/sb/SB/g’ r为扩展模式 sed -ri 多加一个i则是直接将文件内容改掉，而不是仅仅输入到终端 sed -r ‘s/^([a-Z]+)([^a-Z])([a-Z]+)([^a-Z])/\3\2\1\4/‘ 将第一个单词和第三个单词换位置 sed -r ‘s/ //g’ 将所有的空格去掉 sed -r ‘s/[0-9]//g’ 将所有的数字去掉 awk文本处理awk -F: ‘{print $1,$7}’ 打印以：为分隔符取第1段和第7段 (:后面加空格) awk -F: ‘{print $1,$NF}’ 打印以：为分隔符取第1段和最后一段 awk -F: ‘NR&lt;=3{print $1,NR}’ 打印前三行的第一段 awk -F: ‘NR&lt;=3{print NR,”—–”,$1}’ 打印出前三段 1——root 的样式 awk -F: ‘/log$/{print $1}’ 匹配有log的行，打印第1段 awk -F: ‘$1~/^r.*t$/{print $3}’ 匹配第一段中以r开头t结尾的行，并打印出这些行的第三段 awk -F: ‘$1==”root”{print $3,NR}’ 匹配第一段是root的行，并打印出这些行的第三段和行号 awk -v x=$count -F: ‘$3&gt;=x{print NR,$1}’ 匹配第三段大于参数x的行，打印行号和第一段 其他命令cat a.txt |sort |uniq 排序 去重 du -sh 统计文件大小 find /file -name “*.txt” 查找file文件夹中以txt结尾的文件 find /file -size +30M 查找file文件夹中大于30M的文件 find /file -size +10M -30M 查找file文件夹中大于10M小于30M的文件 变量linux 没有数据类型之分 set 显示所有变量 env 显示环境变量 变量关系操作test [] 括号里前后要空格 测试数值[ $x -gt $y ] 判断x的值大于y [ $x -ge $y ] 判断x大于等于y [ $x -lt $y ] 判断x小于y [ $x -le $y ] 判断x小于等于y [ $x -eq $y ] 判断x等于y [ $x -ne $y ] 判断x不等于y [ $x -gt $y -a $a -eq $b ] 判断x大于y并且a等于b [ $x -gt $y -o $a -eq $b ] 判断x大于y或者a等于b 测试文件状态-d 目录 -f 普通文件- -w 可写 -r 可读 -x 可执行 3.字符串测试 = 两字符串相等 != 两字符串不相等 -z 空串 -n 非空串 赋值运算符 ((x=x+1)) ——–((x+=1)) echo $((x-=2)) expr $x + $y echo “scale=2;20/100” | bc -l 保留两位小数 bc要先安装]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LINUX命令二]]></title>
    <url>%2F2019%2F02%2F22%2FLINUX%E5%91%BD%E4%BB%A4%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[打包压缩打包命令 tar -cvf /test.tar /a.txt /b.txt /c.txt 查看包内的内容 tar -tf /test.tar 解压包到当前目录 tar -xvf /test.tar 解压包到指定目录 tar -xvf /test.tar -C /try 压缩文件 gzip /test.tar (压缩快但大) 或者bzip2 /test.tar （压缩慢但小） 解压文件 tar -xf /test.tar.zp tar-xf /test.tar.bz2 打包并同时压缩文件tar -cvzf /test.tar.zp /a.txt /b.txt /c.txt 或 tar -cvjf /test.tar.bz2 /a.txt /b.txt /c.txt 如果要连同目录一起压缩则最后用/ 如果只想压缩目录下面的文件则/* vi查看并编辑文档 vim 按a 编辑 按 :wq 保存并退出 q！不保存 x 小写的x表示向后删除一个字符,也就是删除光标所在字符 nx n表示数字，表示向后删除每个字符，例如：10x表示删除包括光标在内的后面10个字符 dd 删除当前一行 ,就是截切 ndd删除n行（例如3dd删除3行） yy复制一行 nyy复制n行 p 粘贴到目标位置的下一行 P 粘贴到目标位置的上一行 u 撤销上一步操作 ctrl+r 返回前一步 gg 光标移动到文件的第一行 G 光标移动到文件的最后一行 nG 光标移动到文件的第n行 dgg 删除光标所在行到第一行数据 dG 删除光标所在行到最后一行数据 磁盘分区/dev fdisk -l /dev/sda 查看磁盘信息 fdisk /dev/sdb 进入磁盘分区 p 输出目前磁盘分区信息 n 分区 分为p主分区 e扩展分区 d 删除分区 给分区装装指定系统 mkfs.xfs /dev/sdb1 挂载一个目录 mount /dev/sdb1 /test 卸除挂载目录 umount /dev/sdb1 一个分区挂载两个目录时，则两个目录同时指向该分区，即同步 df 查看磁盘分区信息 df-Th 创建软连接相当于创建快捷方式ln -s /test/a.txt /sb/a.txt 前面是被创建的软连接 内存查看内存信息 swapon -s 增加内存区 mkswap /dev/sdb2 swapon -a /dev/sdb2 删除内存区swapoff /dev/sdb2 查看内存 free 进程firefox &amp; 后台运行程序 ps aux 查看全部进程 ps aux|grep fire 查找带fire的进程 pgrep firefox 查找firefox进程号 kill -9 3315 强制杀死进程(3315代表进程编号) pkill -9 firefox 指定名称的杀死进程 软件安装二进制软件安装 rpm -ivh /vsf-3.0.2-9.e17.x86_64.rpm覆盖安装 rpm -ivh /vsf-3.0.2-9.e17.x86_64.rpm –force 查看系统中所有安装的rpm包 rpm -qa 查看指定的包 rpm -qa|grep vsf 查看rpm包安装在哪 rpm -ql vsf 查看rmp包详细信息 rpm -qi vsf 查看文件是由那个包产生 rpm -qf /test/b1.txt 删除rmp包 rmp -e vsf 使用yum安装和卸载软件，有个前提是yum安装的软件包都是rpm格式的 yum update 升级系统 yum install ～ 安装指定软件包 yum update ～ 升级指定软件包 yum remove ～ 卸载指定软件 yum grouplist 查看系统中已经安装的和可用的软件组，可用的可以安装 yum grooupinstall ～安装上一个命令显示的可用的软件组中的一个 源代码安装python安装 python官网下载file源代码 安装环境 查看group列表 yum grouplist 安装组包 yum groupinstall ‘开发工具’ -y 解压文件 tar -xvf pytho-3.7.0.tgz cd到解压好的文件目录，更改源码包安装路径 ./configure –prefix=/usr/local/python3.7 编码 make 安装 make install（安装时会出现下面两种错误 1. 需要安装zlib包 yum install zlib* 2.ModuleNotFoundError: No module named ‘_ctypes’ 解决方法：3.7版本需要一个新的包libffi-devel，安装此包之后再次进行编译安装即可 yum install libffi-* 把python3.7加到path环境中 更改profile文件 vim /etc/profile 在文件的最后面加上 PATH=$PATH:/usr/local/python3.7/bin export PATH netstat -tunapl 查看网络状态]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LINUX命令一]]></title>
    <url>%2F2019%2F02%2F22%2FLINUX%E5%91%BD%E4%BB%A4%E4%B8%80%2F</url>
    <content type="text"><![CDATA[快捷键：ctrl+c 取消命令 ctrl+l 清屏 命令：更换用户 su - 或sudo su 关机 init 0 重启 init 6 立即关机 shutdown -h now 查询当前用户 who am i 查看当前日期 date 修改当前日期 date -s “2012-01-02 14:00:00”（必须切换到root用户） 查看今天日历 cal 查看某天 cal 日月年（cal 3 4 2012） 改密码 passwd 查看文件下的子文件 ls 查看文件夹下的子文件详细信息 ls -l (简写ll) 查看文件的详细信息 ls -dl(简写ll -d) 查看文件夹下的所有文件包括隐藏文件 ls-a 切换目录 cd 退到上级目录 cd ,, 返回到上一次的目录 cd - 查看当前目录 pwd 递归建文件夹 mkdir -p 改名/移动 mv /a/b1 /a/b2(把a文件下的b1改成b2) mv /a/b1 /z/(把b1移动到z文件下) 文件复制顺便改名 cp /a/b1 /a/b2 文件夹的复制 cp -rf /a/b /c 删除文件夹 rm 删除文件夹下的所有子文件 rm -rf (不建议使用，最好用mv /a /tmp/ 移动到临时文件，还可以还原） ,如果文件带特殊符号，则加上“”即可删除 创建文件 touch a.txt 查看内容 cat 百分比查看 more 分页查看 less 查看前三行 head - n3 查看后三行 tail -n3 监控文件 tail -f 覆盖内容 echo 内容 &gt; 新增内容 echo 内容 &gt;&gt; 查看历史命令 history 使用第57行的历史命令 !57 直接修改密码 echo 123456 | passwd –stdin Messiless 用户信息文件 /etc/passwd 用户密码文件 /etc/shadow 用户组 /etc/group 用户组密码 /etc/gshadow 创建hsy用户 useradd hsy 完全删除hsy用户 userdel -r hsy 第一段代表文件权限信息，第一个数字是-代表普通文件，d则是目录 ，后面的一堆分3个3个来看，rwx代表属主的权限（可读可执行可写） r-x代表属组的权限（可读可执行） r-x代表其他用户的权限（可读可执行） 在jack组中附加一个tom用户 usermod -G jack tom 手动创建一个用户的流程 /etc/passwd /etc/shadow /etc/group /etc/gshaow mkdir /home/hsy cp -r /etc/skel/.[!.]* /home/hsy chown -R hsy.hsy /home/hsy touch /var/spool/mail/hsy chown -R hsy.mail /var/spool/mail/hsy 更换文件权限： 方法一：chmod u=rw,g=r,o=rx /a.txt 方法二：chmod 744 /a.txt (r=4,w=2,x=1) 如果要在一个目录下创建删除重命名文件，则该用户需要同时有wx权限 如果要修改一个目录下文件的内容，则需要文件的w权限，和前面目录的x权限]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
</search>
